/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.0.6.0 (NJsonSchema v10.0.23.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AccountServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    isTenantAvailable(input: IsTenantAvailableInput | null | undefined): Observable<IsTenantAvailableOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/IsTenantAvailable";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsTenantAvailable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsTenantAvailable(<any>response_);
                } catch (e) {
                    return <Observable<IsTenantAvailableOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<IsTenantAvailableOutput>><any>_observableThrow(response_);
        }));
    }

    protected processIsTenantAvailable(response: HttpResponseBase): Observable<IsTenantAvailableOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IsTenantAvailableOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IsTenantAvailableOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    resolveTenantId(input: ResolveTenantIdInput | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Account/ResolveTenantId";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResolveTenantId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResolveTenantId(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processResolveTenantId(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    register(input: RegisterInput | null | undefined): Observable<RegisterOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(<any>response_);
                } catch (e) {
                    return <Observable<RegisterOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<RegisterOutput>><any>_observableThrow(response_);
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<RegisterOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RegisterOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegisterOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    sendPasswordResetCode(input: SendPasswordResetCodeInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Account/SendPasswordResetCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendPasswordResetCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendPasswordResetCode(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendPasswordResetCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    resetPassword(input: ResetPasswordInput | null | undefined): Observable<ResetPasswordOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(<any>response_);
                } catch (e) {
                    return <Observable<ResetPasswordOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResetPasswordOutput>><any>_observableThrow(response_);
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<ResetPasswordOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ResetPasswordOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResetPasswordOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    sendEmailActivationLink(input: SendEmailActivationLinkInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Account/SendEmailActivationLink";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendEmailActivationLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendEmailActivationLink(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendEmailActivationLink(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    activateEmail(input: ActivateEmailInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Account/ActivateEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivateEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivateEmail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processActivateEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    impersonate(input: ImpersonateInput | null | undefined): Observable<ImpersonateOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/Impersonate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImpersonate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImpersonate(<any>response_);
                } catch (e) {
                    return <Observable<ImpersonateOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImpersonateOutput>><any>_observableThrow(response_);
        }));
    }

    protected processImpersonate(response: HttpResponseBase): Observable<ImpersonateOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImpersonateOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImpersonateOutput>(<any>null);
    }

    /**
     * @return Success
     */
    backToImpersonator(): Observable<ImpersonateOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/BackToImpersonator";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBackToImpersonator(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBackToImpersonator(<any>response_);
                } catch (e) {
                    return <Observable<ImpersonateOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImpersonateOutput>><any>_observableThrow(response_);
        }));
    }

    protected processBackToImpersonator(response: HttpResponseBase): Observable<ImpersonateOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImpersonateOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImpersonateOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    switchToLinkedAccount(input: SwitchToLinkedAccountInput | null | undefined): Observable<SwitchToLinkedAccountOutput> {
        let url_ = this.baseUrl + "/api/services/app/Account/SwitchToLinkedAccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSwitchToLinkedAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSwitchToLinkedAccount(<any>response_);
                } catch (e) {
                    return <Observable<SwitchToLinkedAccountOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwitchToLinkedAccountOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSwitchToLinkedAccount(response: HttpResponseBase): Observable<SwitchToLinkedAccountOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SwitchToLinkedAccountOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwitchToLinkedAccountOutput>(<any>null);
    }
}

@Injectable()
export class AddressesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param addressEntryNameFilter (optional) 
     * @param isHeadOfficeFilter (optional) 
     * @param addressLine1Filter (optional) 
     * @param addressLine2Filter (optional) 
     * @param postalCodeFilter (optional) 
     * @param cityFilter (optional) 
     * @param stateFilter (optional) 
     * @param countryFilter (optional) 
     * @param addressLoc8GUIDFilter (optional) 
     * @param isDefaultForBillingFilter (optional) 
     * @param isDefaultForShippingFilter (optional) 
     * @param customerNameFilter (optional) 
     * @param assetOwnerNameFilter (optional) 
     * @param vendorNameFilter (optional) 
     * @param customerId (optional) 
     * @param assetOwnerId (optional) 
     * @param vendorId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, addressEntryNameFilter: string | null | undefined, isHeadOfficeFilter: number | null | undefined, addressLine1Filter: string | null | undefined, addressLine2Filter: string | null | undefined, postalCodeFilter: string | null | undefined, cityFilter: string | null | undefined, stateFilter: string | null | undefined, countryFilter: string | null | undefined, addressLoc8GUIDFilter: string | null | undefined, isDefaultForBillingFilter: number | null | undefined, isDefaultForShippingFilter: number | null | undefined, customerNameFilter: string | null | undefined, assetOwnerNameFilter: string | null | undefined, vendorNameFilter: string | null | undefined, customerId: number | null | undefined, assetOwnerId: number | null | undefined, vendorId: number | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetAddressForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Addresses/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (addressEntryNameFilter !== undefined)
            url_ += "AddressEntryNameFilter=" + encodeURIComponent("" + addressEntryNameFilter) + "&"; 
        if (isHeadOfficeFilter !== undefined)
            url_ += "IsHeadOfficeFilter=" + encodeURIComponent("" + isHeadOfficeFilter) + "&"; 
        if (addressLine1Filter !== undefined)
            url_ += "AddressLine1Filter=" + encodeURIComponent("" + addressLine1Filter) + "&"; 
        if (addressLine2Filter !== undefined)
            url_ += "AddressLine2Filter=" + encodeURIComponent("" + addressLine2Filter) + "&"; 
        if (postalCodeFilter !== undefined)
            url_ += "PostalCodeFilter=" + encodeURIComponent("" + postalCodeFilter) + "&"; 
        if (cityFilter !== undefined)
            url_ += "CityFilter=" + encodeURIComponent("" + cityFilter) + "&"; 
        if (stateFilter !== undefined)
            url_ += "StateFilter=" + encodeURIComponent("" + stateFilter) + "&"; 
        if (countryFilter !== undefined)
            url_ += "CountryFilter=" + encodeURIComponent("" + countryFilter) + "&"; 
        if (addressLoc8GUIDFilter !== undefined)
            url_ += "AddressLoc8GUIDFilter=" + encodeURIComponent("" + addressLoc8GUIDFilter) + "&"; 
        if (isDefaultForBillingFilter !== undefined)
            url_ += "IsDefaultForBillingFilter=" + encodeURIComponent("" + isDefaultForBillingFilter) + "&"; 
        if (isDefaultForShippingFilter !== undefined)
            url_ += "IsDefaultForShippingFilter=" + encodeURIComponent("" + isDefaultForShippingFilter) + "&"; 
        if (customerNameFilter !== undefined)
            url_ += "CustomerNameFilter=" + encodeURIComponent("" + customerNameFilter) + "&"; 
        if (assetOwnerNameFilter !== undefined)
            url_ += "AssetOwnerNameFilter=" + encodeURIComponent("" + assetOwnerNameFilter) + "&"; 
        if (vendorNameFilter !== undefined)
            url_ += "VendorNameFilter=" + encodeURIComponent("" + vendorNameFilter) + "&"; 
        if (customerId !== undefined)
            url_ += "CustomerId=" + encodeURIComponent("" + customerId) + "&"; 
        if (assetOwnerId !== undefined)
            url_ += "AssetOwnerId=" + encodeURIComponent("" + assetOwnerId) + "&"; 
        if (vendorId !== undefined)
            url_ += "VendorId=" + encodeURIComponent("" + vendorId) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetAddressForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetAddressForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetAddressForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetAddressForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetAddressForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAddressForView(id: number | null | undefined): Observable<GetAddressForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Addresses/GetAddressForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAddressForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAddressForView(<any>response_);
                } catch (e) {
                    return <Observable<GetAddressForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAddressForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAddressForView(response: HttpResponseBase): Observable<GetAddressForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAddressForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAddressForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAddressForEdit(id: number | null | undefined): Observable<GetAddressForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Addresses/GetAddressForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAddressForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAddressForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetAddressForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAddressForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetAddressForEdit(response: HttpResponseBase): Observable<GetAddressForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAddressForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAddressForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditAddressDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Addresses/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Addresses/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllCustomerForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfAddressCustomerLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Addresses/GetAllCustomerForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCustomerForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCustomerForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAddressCustomerLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAddressCustomerLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCustomerForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfAddressCustomerLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAddressCustomerLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAddressCustomerLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllAssetOwnerForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfAddressAssetOwnerLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Addresses/GetAllAssetOwnerForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAssetOwnerForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAssetOwnerForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAddressAssetOwnerLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAddressAssetOwnerLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAssetOwnerForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfAddressAssetOwnerLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAddressAssetOwnerLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAddressAssetOwnerLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllVendorForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfAddressVendorLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Addresses/GetAllVendorForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllVendorForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllVendorForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAddressVendorLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAddressVendorLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllVendorForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfAddressVendorLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAddressVendorLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAddressVendorLookupTableDto>(<any>null);
    }
}

@Injectable()
export class AgedReceivablesPeriodsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param maxPeriodFilter (optional) 
     * @param minPeriodFilter (optional) 
     * @param maxCurrentFilter (optional) 
     * @param minCurrentFilter (optional) 
     * @param maxOver30Filter (optional) 
     * @param minOver30Filter (optional) 
     * @param maxOver60Filter (optional) 
     * @param minOver60Filter (optional) 
     * @param maxOver90Filter (optional) 
     * @param minOver90Filter (optional) 
     * @param maxOver120Filter (optional) 
     * @param minOver120Filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, maxPeriodFilter: moment.Moment | null | undefined, minPeriodFilter: moment.Moment | null | undefined, maxCurrentFilter: number | null | undefined, minCurrentFilter: number | null | undefined, maxOver30Filter: number | null | undefined, minOver30Filter: number | null | undefined, maxOver60Filter: number | null | undefined, minOver60Filter: number | null | undefined, maxOver90Filter: number | null | undefined, minOver90Filter: number | null | undefined, maxOver120Filter: number | null | undefined, minOver120Filter: number | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetAgedReceivablesPeriodForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/AgedReceivablesPeriods/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxPeriodFilter !== undefined)
            url_ += "MaxPeriodFilter=" + encodeURIComponent(maxPeriodFilter ? "" + maxPeriodFilter.toJSON() : "") + "&"; 
        if (minPeriodFilter !== undefined)
            url_ += "MinPeriodFilter=" + encodeURIComponent(minPeriodFilter ? "" + minPeriodFilter.toJSON() : "") + "&"; 
        if (maxCurrentFilter !== undefined)
            url_ += "MaxCurrentFilter=" + encodeURIComponent("" + maxCurrentFilter) + "&"; 
        if (minCurrentFilter !== undefined)
            url_ += "MinCurrentFilter=" + encodeURIComponent("" + minCurrentFilter) + "&"; 
        if (maxOver30Filter !== undefined)
            url_ += "MaxOver30Filter=" + encodeURIComponent("" + maxOver30Filter) + "&"; 
        if (minOver30Filter !== undefined)
            url_ += "MinOver30Filter=" + encodeURIComponent("" + minOver30Filter) + "&"; 
        if (maxOver60Filter !== undefined)
            url_ += "MaxOver60Filter=" + encodeURIComponent("" + maxOver60Filter) + "&"; 
        if (minOver60Filter !== undefined)
            url_ += "MinOver60Filter=" + encodeURIComponent("" + minOver60Filter) + "&"; 
        if (maxOver90Filter !== undefined)
            url_ += "MaxOver90Filter=" + encodeURIComponent("" + maxOver90Filter) + "&"; 
        if (minOver90Filter !== undefined)
            url_ += "MinOver90Filter=" + encodeURIComponent("" + minOver90Filter) + "&"; 
        if (maxOver120Filter !== undefined)
            url_ += "MaxOver120Filter=" + encodeURIComponent("" + maxOver120Filter) + "&"; 
        if (minOver120Filter !== undefined)
            url_ += "MinOver120Filter=" + encodeURIComponent("" + minOver120Filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetAgedReceivablesPeriodForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetAgedReceivablesPeriodForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetAgedReceivablesPeriodForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetAgedReceivablesPeriodForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetAgedReceivablesPeriodForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAgedReceivablesPeriodForView(id: number | null | undefined): Observable<GetAgedReceivablesPeriodForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/AgedReceivablesPeriods/GetAgedReceivablesPeriodForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAgedReceivablesPeriodForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAgedReceivablesPeriodForView(<any>response_);
                } catch (e) {
                    return <Observable<GetAgedReceivablesPeriodForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAgedReceivablesPeriodForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAgedReceivablesPeriodForView(response: HttpResponseBase): Observable<GetAgedReceivablesPeriodForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAgedReceivablesPeriodForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAgedReceivablesPeriodForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAgedReceivablesPeriodForEdit(id: number | null | undefined): Observable<GetAgedReceivablesPeriodForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/AgedReceivablesPeriods/GetAgedReceivablesPeriodForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAgedReceivablesPeriodForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAgedReceivablesPeriodForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetAgedReceivablesPeriodForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAgedReceivablesPeriodForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetAgedReceivablesPeriodForEdit(response: HttpResponseBase): Observable<GetAgedReceivablesPeriodForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAgedReceivablesPeriodForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAgedReceivablesPeriodForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditAgedReceivablesPeriodDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AgedReceivablesPeriods/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AgedReceivablesPeriods/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param maxPeriodFilter (optional) 
     * @param minPeriodFilter (optional) 
     * @param maxCurrentFilter (optional) 
     * @param minCurrentFilter (optional) 
     * @param maxOver30Filter (optional) 
     * @param minOver30Filter (optional) 
     * @param maxOver60Filter (optional) 
     * @param minOver60Filter (optional) 
     * @param maxOver90Filter (optional) 
     * @param minOver90Filter (optional) 
     * @param maxOver120Filter (optional) 
     * @param minOver120Filter (optional) 
     * @return Success
     */
    getAgedReceivablesPeriodsToExcel(filter: string | null | undefined, maxPeriodFilter: moment.Moment | null | undefined, minPeriodFilter: moment.Moment | null | undefined, maxCurrentFilter: number | null | undefined, minCurrentFilter: number | null | undefined, maxOver30Filter: number | null | undefined, minOver30Filter: number | null | undefined, maxOver60Filter: number | null | undefined, minOver60Filter: number | null | undefined, maxOver90Filter: number | null | undefined, minOver90Filter: number | null | undefined, maxOver120Filter: number | null | undefined, minOver120Filter: number | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/AgedReceivablesPeriods/GetAgedReceivablesPeriodsToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxPeriodFilter !== undefined)
            url_ += "MaxPeriodFilter=" + encodeURIComponent(maxPeriodFilter ? "" + maxPeriodFilter.toJSON() : "") + "&"; 
        if (minPeriodFilter !== undefined)
            url_ += "MinPeriodFilter=" + encodeURIComponent(minPeriodFilter ? "" + minPeriodFilter.toJSON() : "") + "&"; 
        if (maxCurrentFilter !== undefined)
            url_ += "MaxCurrentFilter=" + encodeURIComponent("" + maxCurrentFilter) + "&"; 
        if (minCurrentFilter !== undefined)
            url_ += "MinCurrentFilter=" + encodeURIComponent("" + minCurrentFilter) + "&"; 
        if (maxOver30Filter !== undefined)
            url_ += "MaxOver30Filter=" + encodeURIComponent("" + maxOver30Filter) + "&"; 
        if (minOver30Filter !== undefined)
            url_ += "MinOver30Filter=" + encodeURIComponent("" + minOver30Filter) + "&"; 
        if (maxOver60Filter !== undefined)
            url_ += "MaxOver60Filter=" + encodeURIComponent("" + maxOver60Filter) + "&"; 
        if (minOver60Filter !== undefined)
            url_ += "MinOver60Filter=" + encodeURIComponent("" + minOver60Filter) + "&"; 
        if (maxOver90Filter !== undefined)
            url_ += "MaxOver90Filter=" + encodeURIComponent("" + maxOver90Filter) + "&"; 
        if (minOver90Filter !== undefined)
            url_ += "MinOver90Filter=" + encodeURIComponent("" + minOver90Filter) + "&"; 
        if (maxOver120Filter !== undefined)
            url_ += "MaxOver120Filter=" + encodeURIComponent("" + maxOver120Filter) + "&"; 
        if (minOver120Filter !== undefined)
            url_ += "MinOver120Filter=" + encodeURIComponent("" + minOver120Filter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAgedReceivablesPeriodsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAgedReceivablesPeriodsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAgedReceivablesPeriodsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class AssetClassesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param classFilter (optional) 
     * @param assetTypeTypeFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, classFilter: string | null | undefined, assetTypeTypeFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetAssetClassForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/AssetClasses/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (classFilter !== undefined)
            url_ += "ClassFilter=" + encodeURIComponent("" + classFilter) + "&"; 
        if (assetTypeTypeFilter !== undefined)
            url_ += "AssetTypeTypeFilter=" + encodeURIComponent("" + assetTypeTypeFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetAssetClassForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetAssetClassForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetAssetClassForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetAssetClassForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetAssetClassForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAssetClassForView(id: number | null | undefined): Observable<GetAssetClassForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/AssetClasses/GetAssetClassForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetClassForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetClassForView(<any>response_);
                } catch (e) {
                    return <Observable<GetAssetClassForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAssetClassForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetClassForView(response: HttpResponseBase): Observable<GetAssetClassForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAssetClassForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAssetClassForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAssetClassForEdit(id: number | null | undefined): Observable<GetAssetClassForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/AssetClasses/GetAssetClassForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetClassForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetClassForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetAssetClassForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAssetClassForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetClassForEdit(response: HttpResponseBase): Observable<GetAssetClassForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAssetClassForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAssetClassForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditAssetClassDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AssetClasses/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AssetClasses/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param classFilter (optional) 
     * @param assetTypeTypeFilter (optional) 
     * @return Success
     */
    getAssetClassesToExcel(filter: string | null | undefined, classFilter: string | null | undefined, assetTypeTypeFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/AssetClasses/GetAssetClassesToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (classFilter !== undefined)
            url_ += "ClassFilter=" + encodeURIComponent("" + classFilter) + "&"; 
        if (assetTypeTypeFilter !== undefined)
            url_ += "AssetTypeTypeFilter=" + encodeURIComponent("" + assetTypeTypeFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetClassesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetClassesToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetClassesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllAssetTypeForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfAssetClassAssetTypeLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/AssetClasses/GetAllAssetTypeForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAssetTypeForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAssetTypeForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAssetClassAssetTypeLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAssetClassAssetTypeLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAssetTypeForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfAssetClassAssetTypeLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAssetClassAssetTypeLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAssetClassAssetTypeLookupTableDto>(<any>null);
    }
}

@Injectable()
export class AssetNotesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param assetId (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @param sorting (optional) 
     * @return Success
     */
    getAll(assetId: number | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined, sorting: string | null | undefined): Observable<PagedResultDtoOfGetAssetNotesForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/AssetNotes/GetAll?";
        if (assetId !== undefined)
            url_ += "assetId=" + encodeURIComponent("" + assetId) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetAssetNotesForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetAssetNotesForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetAssetNotesForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetAssetNotesForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetAssetNotesForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAssetNotesForView(id: number | null | undefined): Observable<GetAssetNotesForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/AssetNotes/GetAssetNotesForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetNotesForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetNotesForView(<any>response_);
                } catch (e) {
                    return <Observable<GetAssetNotesForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAssetNotesForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetNotesForView(response: HttpResponseBase): Observable<GetAssetNotesForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAssetNotesForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAssetNotesForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAssetNotesForEdit(id: number | null | undefined): Observable<GetAssetNotesForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/AssetNotes/GetAssetNotesForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetNotesForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetNotesForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetAssetNotesForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAssetNotesForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetNotesForEdit(response: HttpResponseBase): Observable<GetAssetNotesForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAssetNotesForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAssetNotesForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditAssetNotesDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AssetNotes/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AssetNotes/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class AssetOwnersServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param referenceFilter (optional) 
     * @param nameFilter (optional) 
     * @param identifierFilter (optional) 
     * @param websiteFilter (optional) 
     * @param currencyNameFilter (optional) 
     * @param ssicCodeCodeFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, referenceFilter: string | null | undefined, nameFilter: string | null | undefined, identifierFilter: string | null | undefined, websiteFilter: string | null | undefined, currencyNameFilter: string | null | undefined, ssicCodeCodeFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetAssetOwnerForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/AssetOwners/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (referenceFilter !== undefined)
            url_ += "ReferenceFilter=" + encodeURIComponent("" + referenceFilter) + "&"; 
        if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&"; 
        if (identifierFilter !== undefined)
            url_ += "IdentifierFilter=" + encodeURIComponent("" + identifierFilter) + "&"; 
        if (websiteFilter !== undefined)
            url_ += "WebsiteFilter=" + encodeURIComponent("" + websiteFilter) + "&"; 
        if (currencyNameFilter !== undefined)
            url_ += "CurrencyNameFilter=" + encodeURIComponent("" + currencyNameFilter) + "&"; 
        if (ssicCodeCodeFilter !== undefined)
            url_ += "SsicCodeCodeFilter=" + encodeURIComponent("" + ssicCodeCodeFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetAssetOwnerForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetAssetOwnerForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetAssetOwnerForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetAssetOwnerForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetAssetOwnerForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAssetOwnerForView(id: number | null | undefined): Observable<GetAssetOwnerForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/AssetOwners/GetAssetOwnerForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetOwnerForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetOwnerForView(<any>response_);
                } catch (e) {
                    return <Observable<GetAssetOwnerForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAssetOwnerForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetOwnerForView(response: HttpResponseBase): Observable<GetAssetOwnerForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAssetOwnerForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAssetOwnerForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAssetOwnerForEdit(id: number | null | undefined): Observable<GetAssetOwnerForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/AssetOwners/GetAssetOwnerForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetOwnerForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetOwnerForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetAssetOwnerForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAssetOwnerForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetOwnerForEdit(response: HttpResponseBase): Observable<GetAssetOwnerForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAssetOwnerForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAssetOwnerForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditAssetOwnerDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AssetOwners/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AssetOwners/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param referenceFilter (optional) 
     * @param nameFilter (optional) 
     * @param identifierFilter (optional) 
     * @param websiteFilter (optional) 
     * @param currencyNameFilter (optional) 
     * @param ssicCodeCodeFilter (optional) 
     * @return Success
     */
    getAssetOwnersToExcel(filter: string | null | undefined, referenceFilter: string | null | undefined, nameFilter: string | null | undefined, identifierFilter: string | null | undefined, websiteFilter: string | null | undefined, currencyNameFilter: string | null | undefined, ssicCodeCodeFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/AssetOwners/GetAssetOwnersToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (referenceFilter !== undefined)
            url_ += "ReferenceFilter=" + encodeURIComponent("" + referenceFilter) + "&"; 
        if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&"; 
        if (identifierFilter !== undefined)
            url_ += "IdentifierFilter=" + encodeURIComponent("" + identifierFilter) + "&"; 
        if (websiteFilter !== undefined)
            url_ += "WebsiteFilter=" + encodeURIComponent("" + websiteFilter) + "&"; 
        if (currencyNameFilter !== undefined)
            url_ += "CurrencyNameFilter=" + encodeURIComponent("" + currencyNameFilter) + "&"; 
        if (ssicCodeCodeFilter !== undefined)
            url_ += "SsicCodeCodeFilter=" + encodeURIComponent("" + ssicCodeCodeFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetOwnersToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetOwnersToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetOwnersToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllCurrencyForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfAssetOwnerCurrencyLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/AssetOwners/GetAllCurrencyForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCurrencyForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCurrencyForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAssetOwnerCurrencyLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAssetOwnerCurrencyLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCurrencyForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfAssetOwnerCurrencyLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAssetOwnerCurrencyLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAssetOwnerCurrencyLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllSsicCodeForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfAssetOwnerSsicCodeLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/AssetOwners/GetAllSsicCodeForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSsicCodeForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSsicCodeForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAssetOwnerSsicCodeLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAssetOwnerSsicCodeLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSsicCodeForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfAssetOwnerSsicCodeLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAssetOwnerSsicCodeLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAssetOwnerSsicCodeLookupTableDto>(<any>null);
    }
}

@Injectable()
export class AssetOwnershipsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param maxStartDateFilter (optional) 
     * @param minStartDateFilter (optional) 
     * @param maxFinishDateFilter (optional) 
     * @param minFinishDateFilter (optional) 
     * @param maxPercentageOwnershipFilter (optional) 
     * @param minPercentageOwnershipFilter (optional) 
     * @param assetReferenceFilter (optional) 
     * @param assetOwnerNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, maxStartDateFilter: moment.Moment | null | undefined, minStartDateFilter: moment.Moment | null | undefined, maxFinishDateFilter: moment.Moment | null | undefined, minFinishDateFilter: moment.Moment | null | undefined, maxPercentageOwnershipFilter: number | null | undefined, minPercentageOwnershipFilter: number | null | undefined, assetReferenceFilter: string | null | undefined, assetOwnerNameFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetAssetOwnershipForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/AssetOwnerships/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxStartDateFilter !== undefined)
            url_ += "MaxStartDateFilter=" + encodeURIComponent(maxStartDateFilter ? "" + maxStartDateFilter.toJSON() : "") + "&"; 
        if (minStartDateFilter !== undefined)
            url_ += "MinStartDateFilter=" + encodeURIComponent(minStartDateFilter ? "" + minStartDateFilter.toJSON() : "") + "&"; 
        if (maxFinishDateFilter !== undefined)
            url_ += "MaxFinishDateFilter=" + encodeURIComponent(maxFinishDateFilter ? "" + maxFinishDateFilter.toJSON() : "") + "&"; 
        if (minFinishDateFilter !== undefined)
            url_ += "MinFinishDateFilter=" + encodeURIComponent(minFinishDateFilter ? "" + minFinishDateFilter.toJSON() : "") + "&"; 
        if (maxPercentageOwnershipFilter !== undefined)
            url_ += "MaxPercentageOwnershipFilter=" + encodeURIComponent("" + maxPercentageOwnershipFilter) + "&"; 
        if (minPercentageOwnershipFilter !== undefined)
            url_ += "MinPercentageOwnershipFilter=" + encodeURIComponent("" + minPercentageOwnershipFilter) + "&"; 
        if (assetReferenceFilter !== undefined)
            url_ += "AssetReferenceFilter=" + encodeURIComponent("" + assetReferenceFilter) + "&"; 
        if (assetOwnerNameFilter !== undefined)
            url_ += "AssetOwnerNameFilter=" + encodeURIComponent("" + assetOwnerNameFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetAssetOwnershipForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetAssetOwnershipForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetAssetOwnershipForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetAssetOwnershipForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetAssetOwnershipForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAssetOwnershipForView(id: number | null | undefined): Observable<GetAssetOwnershipForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/AssetOwnerships/GetAssetOwnershipForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetOwnershipForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetOwnershipForView(<any>response_);
                } catch (e) {
                    return <Observable<GetAssetOwnershipForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAssetOwnershipForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetOwnershipForView(response: HttpResponseBase): Observable<GetAssetOwnershipForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAssetOwnershipForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAssetOwnershipForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAssetOwnershipForEdit(id: number | null | undefined): Observable<GetAssetOwnershipForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/AssetOwnerships/GetAssetOwnershipForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetOwnershipForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetOwnershipForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetAssetOwnershipForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAssetOwnershipForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetOwnershipForEdit(response: HttpResponseBase): Observable<GetAssetOwnershipForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAssetOwnershipForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAssetOwnershipForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditAssetOwnershipDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AssetOwnerships/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AssetOwnerships/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param maxStartDateFilter (optional) 
     * @param minStartDateFilter (optional) 
     * @param maxFinishDateFilter (optional) 
     * @param minFinishDateFilter (optional) 
     * @param maxPercentageOwnershipFilter (optional) 
     * @param minPercentageOwnershipFilter (optional) 
     * @param assetReferenceFilter (optional) 
     * @param assetOwnerNameFilter (optional) 
     * @return Success
     */
    getAssetOwnershipsToExcel(filter: string | null | undefined, maxStartDateFilter: moment.Moment | null | undefined, minStartDateFilter: moment.Moment | null | undefined, maxFinishDateFilter: moment.Moment | null | undefined, minFinishDateFilter: moment.Moment | null | undefined, maxPercentageOwnershipFilter: number | null | undefined, minPercentageOwnershipFilter: number | null | undefined, assetReferenceFilter: string | null | undefined, assetOwnerNameFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/AssetOwnerships/GetAssetOwnershipsToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxStartDateFilter !== undefined)
            url_ += "MaxStartDateFilter=" + encodeURIComponent(maxStartDateFilter ? "" + maxStartDateFilter.toJSON() : "") + "&"; 
        if (minStartDateFilter !== undefined)
            url_ += "MinStartDateFilter=" + encodeURIComponent(minStartDateFilter ? "" + minStartDateFilter.toJSON() : "") + "&"; 
        if (maxFinishDateFilter !== undefined)
            url_ += "MaxFinishDateFilter=" + encodeURIComponent(maxFinishDateFilter ? "" + maxFinishDateFilter.toJSON() : "") + "&"; 
        if (minFinishDateFilter !== undefined)
            url_ += "MinFinishDateFilter=" + encodeURIComponent(minFinishDateFilter ? "" + minFinishDateFilter.toJSON() : "") + "&"; 
        if (maxPercentageOwnershipFilter !== undefined)
            url_ += "MaxPercentageOwnershipFilter=" + encodeURIComponent("" + maxPercentageOwnershipFilter) + "&"; 
        if (minPercentageOwnershipFilter !== undefined)
            url_ += "MinPercentageOwnershipFilter=" + encodeURIComponent("" + minPercentageOwnershipFilter) + "&"; 
        if (assetReferenceFilter !== undefined)
            url_ += "AssetReferenceFilter=" + encodeURIComponent("" + assetReferenceFilter) + "&"; 
        if (assetOwnerNameFilter !== undefined)
            url_ += "AssetOwnerNameFilter=" + encodeURIComponent("" + assetOwnerNameFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetOwnershipsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetOwnershipsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetOwnershipsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllAssetForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfAssetOwnershipAssetLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/AssetOwnerships/GetAllAssetForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAssetForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAssetForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAssetOwnershipAssetLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAssetOwnershipAssetLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAssetForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfAssetOwnershipAssetLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAssetOwnershipAssetLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAssetOwnershipAssetLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllAssetOwnerForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfAssetOwnershipAssetOwnerLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/AssetOwnerships/GetAllAssetOwnerForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAssetOwnerForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAssetOwnerForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAssetOwnershipAssetOwnerLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAssetOwnershipAssetOwnerLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAssetOwnerForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfAssetOwnershipAssetOwnerLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAssetOwnershipAssetOwnerLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAssetOwnershipAssetOwnerLookupTableDto>(<any>null);
    }
}

@Injectable()
export class AssetPartsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param assetId (optional) 
     * @return Success
     */
    getAssetParts(assetId: number | null | undefined): Observable<ListResultDtoOfAssetPartExtendedDto> {
        let url_ = this.baseUrl + "/api/services/app/AssetParts/GetAssetParts?";
        if (assetId !== undefined)
            url_ += "assetId=" + encodeURIComponent("" + assetId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetParts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetParts(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfAssetPartExtendedDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfAssetPartExtendedDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetParts(response: HttpResponseBase): Observable<ListResultDtoOfAssetPartExtendedDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfAssetPartExtendedDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfAssetPartExtendedDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    moveAssetPart(input: MoveAssetPartInput | null | undefined): Observable<AssetPartDto> {
        let url_ = this.baseUrl + "/api/services/app/AssetParts/MoveAssetPart";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMoveAssetPart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMoveAssetPart(<any>response_);
                } catch (e) {
                    return <Observable<AssetPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processMoveAssetPart(response: HttpResponseBase): Observable<AssetPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetPartDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetPartDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    moveAssetPartToAsset(input: MoveAssetPartToAssetInput | null | undefined): Observable<AssetPartDto> {
        let url_ = this.baseUrl + "/api/services/app/AssetParts/MoveAssetPartToAsset";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMoveAssetPartToAsset(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMoveAssetPartToAsset(<any>response_);
                } catch (e) {
                    return <Observable<AssetPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processMoveAssetPartToAsset(response: HttpResponseBase): Observable<AssetPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetPartDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetPartDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    moveBranchToAsset(input: MoveAssetPartToAssetInput | null | undefined): Observable<AssetPartDto> {
        let url_ = this.baseUrl + "/api/services/app/AssetParts/MoveBranchToAsset";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMoveBranchToAsset(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMoveBranchToAsset(<any>response_);
                } catch (e) {
                    return <Observable<AssetPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processMoveBranchToAsset(response: HttpResponseBase): Observable<AssetPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetPartDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetPartDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    moveAssetPartToWarehouse(input: MoveAssetPartToWarehouseInput | null | undefined): Observable<AssetPartDto> {
        let url_ = this.baseUrl + "/api/services/app/AssetParts/MoveAssetPartToWarehouse";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMoveAssetPartToWarehouse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMoveAssetPartToWarehouse(<any>response_);
                } catch (e) {
                    return <Observable<AssetPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processMoveAssetPartToWarehouse(response: HttpResponseBase): Observable<AssetPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetPartDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetPartDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    moveBranchToWarehouse(input: MoveAssetPartToWarehouseInput | null | undefined): Observable<AssetPartDto> {
        let url_ = this.baseUrl + "/api/services/app/AssetParts/MoveBranchToWarehouse";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMoveBranchToWarehouse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMoveBranchToWarehouse(<any>response_);
                } catch (e) {
                    return <Observable<AssetPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AssetPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processMoveBranchToWarehouse(response: HttpResponseBase): Observable<AssetPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AssetPartDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AssetPartDto>(<any>null);
    }

    /**
     * @param assetId (optional) 
     * @param warehouseId (optional) 
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param serialNumberFilter (optional) 
     * @param maxInstallDateFilter (optional) 
     * @param minInstallDateFilter (optional) 
     * @param installedFilter (optional) 
     * @param assetPartTypeTypeFilter (optional) 
     * @param assetPartNameFilter (optional) 
     * @param assetPartStatusStatusFilter (optional) 
     * @param assetReferenceFilter (optional) 
     * @param itemTypeTypeFilter (optional) 
     * @param warehouseNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(assetId: number | null | undefined, warehouseId: number | null | undefined, filter: string | null | undefined, nameFilter: string | null | undefined, descriptionFilter: string | null | undefined, serialNumberFilter: string | null | undefined, maxInstallDateFilter: moment.Moment | null | undefined, minInstallDateFilter: moment.Moment | null | undefined, installedFilter: number | null | undefined, assetPartTypeTypeFilter: string | null | undefined, assetPartNameFilter: string | null | undefined, assetPartStatusStatusFilter: string | null | undefined, assetReferenceFilter: string | null | undefined, itemTypeTypeFilter: string | null | undefined, warehouseNameFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetAssetPartForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/AssetParts/GetAll?";
        if (assetId !== undefined)
            url_ += "AssetId=" + encodeURIComponent("" + assetId) + "&"; 
        if (warehouseId !== undefined)
            url_ += "WarehouseId=" + encodeURIComponent("" + warehouseId) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&"; 
        if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (serialNumberFilter !== undefined)
            url_ += "SerialNumberFilter=" + encodeURIComponent("" + serialNumberFilter) + "&"; 
        if (maxInstallDateFilter !== undefined)
            url_ += "MaxInstallDateFilter=" + encodeURIComponent(maxInstallDateFilter ? "" + maxInstallDateFilter.toJSON() : "") + "&"; 
        if (minInstallDateFilter !== undefined)
            url_ += "MinInstallDateFilter=" + encodeURIComponent(minInstallDateFilter ? "" + minInstallDateFilter.toJSON() : "") + "&"; 
        if (installedFilter !== undefined)
            url_ += "InstalledFilter=" + encodeURIComponent("" + installedFilter) + "&"; 
        if (assetPartTypeTypeFilter !== undefined)
            url_ += "AssetPartTypeTypeFilter=" + encodeURIComponent("" + assetPartTypeTypeFilter) + "&"; 
        if (assetPartNameFilter !== undefined)
            url_ += "AssetPartNameFilter=" + encodeURIComponent("" + assetPartNameFilter) + "&"; 
        if (assetPartStatusStatusFilter !== undefined)
            url_ += "AssetPartStatusStatusFilter=" + encodeURIComponent("" + assetPartStatusStatusFilter) + "&"; 
        if (assetReferenceFilter !== undefined)
            url_ += "AssetReferenceFilter=" + encodeURIComponent("" + assetReferenceFilter) + "&"; 
        if (itemTypeTypeFilter !== undefined)
            url_ += "ItemTypeTypeFilter=" + encodeURIComponent("" + itemTypeTypeFilter) + "&"; 
        if (warehouseNameFilter !== undefined)
            url_ += "WarehouseNameFilter=" + encodeURIComponent("" + warehouseNameFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetAssetPartForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetAssetPartForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetAssetPartForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetAssetPartForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetAssetPartForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAssetPartForView(id: number | null | undefined): Observable<GetAssetPartForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/AssetParts/GetAssetPartForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetPartForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetPartForView(<any>response_);
                } catch (e) {
                    return <Observable<GetAssetPartForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAssetPartForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetPartForView(response: HttpResponseBase): Observable<GetAssetPartForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAssetPartForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAssetPartForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAssetPartForEdit(id: number | null | undefined): Observable<GetAssetPartForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/AssetParts/GetAssetPartForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetPartForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetPartForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetAssetPartForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAssetPartForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetPartForEdit(response: HttpResponseBase): Observable<GetAssetPartForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAssetPartForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAssetPartForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditAssetPartDto | null | undefined): Observable<CreateOrEditAssetPartDto> {
        let url_ = this.baseUrl + "/api/services/app/AssetParts/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<CreateOrEditAssetPartDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CreateOrEditAssetPartDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<CreateOrEditAssetPartDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CreateOrEditAssetPartDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CreateOrEditAssetPartDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AssetParts/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteComponent(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AssetParts/DeleteComponent?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteComponent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteComponent(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteComponent(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteBranch(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AssetParts/DeleteBranch?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteBranch(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteBranch(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteBranch(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param serialNumberFilter (optional) 
     * @param maxInstallDateFilter (optional) 
     * @param minInstallDateFilter (optional) 
     * @param installedFilter (optional) 
     * @param assetPartTypeTypeFilter (optional) 
     * @param assetPartNameFilter (optional) 
     * @param assetPartStatusStatusFilter (optional) 
     * @param assetReferenceFilter (optional) 
     * @param itemTypeTypeFilter (optional) 
     * @param warehouseNameFilter (optional) 
     * @return Success
     */
    getAssetPartsToExcel(filter: string | null | undefined, nameFilter: string | null | undefined, descriptionFilter: string | null | undefined, serialNumberFilter: string | null | undefined, maxInstallDateFilter: moment.Moment | null | undefined, minInstallDateFilter: moment.Moment | null | undefined, installedFilter: number | null | undefined, assetPartTypeTypeFilter: string | null | undefined, assetPartNameFilter: string | null | undefined, assetPartStatusStatusFilter: string | null | undefined, assetReferenceFilter: string | null | undefined, itemTypeTypeFilter: string | null | undefined, warehouseNameFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/AssetParts/GetAssetPartsToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&"; 
        if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (serialNumberFilter !== undefined)
            url_ += "SerialNumberFilter=" + encodeURIComponent("" + serialNumberFilter) + "&"; 
        if (maxInstallDateFilter !== undefined)
            url_ += "MaxInstallDateFilter=" + encodeURIComponent(maxInstallDateFilter ? "" + maxInstallDateFilter.toJSON() : "") + "&"; 
        if (minInstallDateFilter !== undefined)
            url_ += "MinInstallDateFilter=" + encodeURIComponent(minInstallDateFilter ? "" + minInstallDateFilter.toJSON() : "") + "&"; 
        if (installedFilter !== undefined)
            url_ += "InstalledFilter=" + encodeURIComponent("" + installedFilter) + "&"; 
        if (assetPartTypeTypeFilter !== undefined)
            url_ += "AssetPartTypeTypeFilter=" + encodeURIComponent("" + assetPartTypeTypeFilter) + "&"; 
        if (assetPartNameFilter !== undefined)
            url_ += "AssetPartNameFilter=" + encodeURIComponent("" + assetPartNameFilter) + "&"; 
        if (assetPartStatusStatusFilter !== undefined)
            url_ += "AssetPartStatusStatusFilter=" + encodeURIComponent("" + assetPartStatusStatusFilter) + "&"; 
        if (assetReferenceFilter !== undefined)
            url_ += "AssetReferenceFilter=" + encodeURIComponent("" + assetReferenceFilter) + "&"; 
        if (itemTypeTypeFilter !== undefined)
            url_ += "ItemTypeTypeFilter=" + encodeURIComponent("" + itemTypeTypeFilter) + "&"; 
        if (warehouseNameFilter !== undefined)
            url_ += "WarehouseNameFilter=" + encodeURIComponent("" + warehouseNameFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetPartsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetPartsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetPartsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllAssetPartTypeForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfAssetPartAssetPartTypeLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/AssetParts/GetAllAssetPartTypeForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAssetPartTypeForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAssetPartTypeForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAssetPartAssetPartTypeLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAssetPartAssetPartTypeLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAssetPartTypeForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfAssetPartAssetPartTypeLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAssetPartAssetPartTypeLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAssetPartAssetPartTypeLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param warehouseId (optional) 
     * @param assetId (optional) 
     * @param forImportFromWarehouses (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllAssetPartForLookupTable(filter: string | null | undefined, warehouseId: number | null | undefined, assetId: number | null | undefined, forImportFromWarehouses: boolean | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfAssetPartAssetPartLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/AssetParts/GetAllAssetPartForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (warehouseId !== undefined)
            url_ += "WarehouseId=" + encodeURIComponent("" + warehouseId) + "&"; 
        if (assetId !== undefined)
            url_ += "AssetId=" + encodeURIComponent("" + assetId) + "&"; 
        if (forImportFromWarehouses !== undefined)
            url_ += "ForImportFromWarehouses=" + encodeURIComponent("" + forImportFromWarehouses) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAssetPartForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAssetPartForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAssetPartAssetPartLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAssetPartAssetPartLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAssetPartForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfAssetPartAssetPartLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAssetPartAssetPartLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAssetPartAssetPartLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllAssetPartStatusForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfAssetPartAssetPartStatusLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/AssetParts/GetAllAssetPartStatusForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAssetPartStatusForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAssetPartStatusForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAssetPartAssetPartStatusLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAssetPartAssetPartStatusLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAssetPartStatusForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfAssetPartAssetPartStatusLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAssetPartAssetPartStatusLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAssetPartAssetPartStatusLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllAssetForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfAssetPartAssetLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/AssetParts/GetAllAssetForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAssetForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAssetForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAssetPartAssetLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAssetPartAssetLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAssetForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfAssetPartAssetLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAssetPartAssetLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAssetPartAssetLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllItemTypeForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfAssetPartItemTypeLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/AssetParts/GetAllItemTypeForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllItemTypeForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllItemTypeForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAssetPartItemTypeLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAssetPartItemTypeLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllItemTypeForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfAssetPartItemTypeLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAssetPartItemTypeLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAssetPartItemTypeLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllWarehouseForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfAssetPartWarehouseLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/AssetParts/GetAllWarehouseForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWarehouseForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWarehouseForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAssetPartWarehouseLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAssetPartWarehouseLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllWarehouseForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfAssetPartWarehouseLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAssetPartWarehouseLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAssetPartWarehouseLookupTableDto>(<any>null);
    }
}

@Injectable()
export class AssetPartStatusesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetAssetPartStatusForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/AssetPartStatuses/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetAssetPartStatusForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetAssetPartStatusForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetAssetPartStatusForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetAssetPartStatusForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetAssetPartStatusForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAssetPartStatusForView(id: number | null | undefined): Observable<GetAssetPartStatusForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/AssetPartStatuses/GetAssetPartStatusForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetPartStatusForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetPartStatusForView(<any>response_);
                } catch (e) {
                    return <Observable<GetAssetPartStatusForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAssetPartStatusForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetPartStatusForView(response: HttpResponseBase): Observable<GetAssetPartStatusForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAssetPartStatusForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAssetPartStatusForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAssetPartStatusForEdit(id: number | null | undefined): Observable<GetAssetPartStatusForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/AssetPartStatuses/GetAssetPartStatusForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetPartStatusForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetPartStatusForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetAssetPartStatusForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAssetPartStatusForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetPartStatusForEdit(response: HttpResponseBase): Observable<GetAssetPartStatusForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAssetPartStatusForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAssetPartStatusForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditAssetPartStatusDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AssetPartStatuses/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AssetPartStatuses/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class AssetPartTypesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param typeFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, typeFilter: string | null | undefined, descriptionFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetAssetPartTypeForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/AssetPartTypes/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (typeFilter !== undefined)
            url_ += "TypeFilter=" + encodeURIComponent("" + typeFilter) + "&"; 
        if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetAssetPartTypeForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetAssetPartTypeForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetAssetPartTypeForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetAssetPartTypeForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetAssetPartTypeForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAssetPartTypeForView(id: number | null | undefined): Observable<GetAssetPartTypeForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/AssetPartTypes/GetAssetPartTypeForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetPartTypeForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetPartTypeForView(<any>response_);
                } catch (e) {
                    return <Observable<GetAssetPartTypeForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAssetPartTypeForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetPartTypeForView(response: HttpResponseBase): Observable<GetAssetPartTypeForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAssetPartTypeForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAssetPartTypeForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAssetPartTypeForEdit(id: number | null | undefined): Observable<GetAssetPartTypeForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/AssetPartTypes/GetAssetPartTypeForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetPartTypeForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetPartTypeForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetAssetPartTypeForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAssetPartTypeForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetPartTypeForEdit(response: HttpResponseBase): Observable<GetAssetPartTypeForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAssetPartTypeForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAssetPartTypeForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditAssetPartTypeDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AssetPartTypes/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AssetPartTypes/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param typeFilter (optional) 
     * @param descriptionFilter (optional) 
     * @return Success
     */
    getAssetPartTypesToExcel(filter: string | null | undefined, typeFilter: string | null | undefined, descriptionFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/AssetPartTypes/GetAssetPartTypesToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (typeFilter !== undefined)
            url_ += "TypeFilter=" + encodeURIComponent("" + typeFilter) + "&"; 
        if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetPartTypesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetPartTypesToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetPartTypesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class AssetsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param referenceFilter (optional) 
     * @param vehicleRegistrationNoFilter (optional) 
     * @param isExternalAssetFilter (optional) 
     * @param locationFilter (optional) 
     * @param serialNumberFilter (optional) 
     * @param engineNoFilter (optional) 
     * @param chassisNoFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param purchaseOrderNoFilter (optional) 
     * @param maxPurchaseDateFilter (optional) 
     * @param minPurchaseDateFilter (optional) 
     * @param maxPurchaseCostFilter (optional) 
     * @param minPurchaseCostFilter (optional) 
     * @param assetLoc8GUIDFilter (optional) 
     * @param assetClassClassFilter (optional) 
     * @param assetStatusStatusFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, referenceFilter: string | null | undefined, vehicleRegistrationNoFilter: string | null | undefined, isExternalAssetFilter: number | null | undefined, locationFilter: string | null | undefined, serialNumberFilter: string | null | undefined, engineNoFilter: string | null | undefined, chassisNoFilter: string | null | undefined, descriptionFilter: string | null | undefined, purchaseOrderNoFilter: string | null | undefined, maxPurchaseDateFilter: moment.Moment | null | undefined, minPurchaseDateFilter: moment.Moment | null | undefined, maxPurchaseCostFilter: number | null | undefined, minPurchaseCostFilter: number | null | undefined, assetLoc8GUIDFilter: string | null | undefined, assetClassClassFilter: string | null | undefined, assetStatusStatusFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetAssetForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Assets/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (referenceFilter !== undefined)
            url_ += "ReferenceFilter=" + encodeURIComponent("" + referenceFilter) + "&"; 
        if (vehicleRegistrationNoFilter !== undefined)
            url_ += "VehicleRegistrationNoFilter=" + encodeURIComponent("" + vehicleRegistrationNoFilter) + "&"; 
        if (isExternalAssetFilter !== undefined)
            url_ += "IsExternalAssetFilter=" + encodeURIComponent("" + isExternalAssetFilter) + "&"; 
        if (locationFilter !== undefined)
            url_ += "LocationFilter=" + encodeURIComponent("" + locationFilter) + "&"; 
        if (serialNumberFilter !== undefined)
            url_ += "SerialNumberFilter=" + encodeURIComponent("" + serialNumberFilter) + "&"; 
        if (engineNoFilter !== undefined)
            url_ += "EngineNoFilter=" + encodeURIComponent("" + engineNoFilter) + "&"; 
        if (chassisNoFilter !== undefined)
            url_ += "ChassisNoFilter=" + encodeURIComponent("" + chassisNoFilter) + "&"; 
        if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (purchaseOrderNoFilter !== undefined)
            url_ += "PurchaseOrderNoFilter=" + encodeURIComponent("" + purchaseOrderNoFilter) + "&"; 
        if (maxPurchaseDateFilter !== undefined)
            url_ += "MaxPurchaseDateFilter=" + encodeURIComponent(maxPurchaseDateFilter ? "" + maxPurchaseDateFilter.toJSON() : "") + "&"; 
        if (minPurchaseDateFilter !== undefined)
            url_ += "MinPurchaseDateFilter=" + encodeURIComponent(minPurchaseDateFilter ? "" + minPurchaseDateFilter.toJSON() : "") + "&"; 
        if (maxPurchaseCostFilter !== undefined)
            url_ += "MaxPurchaseCostFilter=" + encodeURIComponent("" + maxPurchaseCostFilter) + "&"; 
        if (minPurchaseCostFilter !== undefined)
            url_ += "MinPurchaseCostFilter=" + encodeURIComponent("" + minPurchaseCostFilter) + "&"; 
        if (assetLoc8GUIDFilter !== undefined)
            url_ += "AssetLoc8GUIDFilter=" + encodeURIComponent("" + assetLoc8GUIDFilter) + "&"; 
        if (assetClassClassFilter !== undefined)
            url_ += "AssetClassClassFilter=" + encodeURIComponent("" + assetClassClassFilter) + "&"; 
        if (assetStatusStatusFilter !== undefined)
            url_ += "AssetStatusStatusFilter=" + encodeURIComponent("" + assetStatusStatusFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetAssetForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetAssetForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetAssetForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetAssetForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetAssetForViewDto>(<any>null);
    }

    /**
     * @param assetId (optional) 
     * @param filter (optional) 
     * @param referenceFilter (optional) 
     * @param maxStartTimeFilter (optional) 
     * @param minStartTimeFilter (optional) 
     * @param maxEndTimeFilter (optional) 
     * @param minEndTimeFilter (optional) 
     * @param maxUnitsConsumedFilter (optional) 
     * @param minUnitsConsumedFilter (optional) 
     * @param usageMetricMetricFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getSomeUsageMetricRecords(assetId: number | null | undefined, filter: string | null | undefined, referenceFilter: string | null | undefined, maxStartTimeFilter: moment.Moment | null | undefined, minStartTimeFilter: moment.Moment | null | undefined, maxEndTimeFilter: moment.Moment | null | undefined, minEndTimeFilter: moment.Moment | null | undefined, maxUnitsConsumedFilter: number | null | undefined, minUnitsConsumedFilter: number | null | undefined, usageMetricMetricFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetUsageMetricRecordForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Assets/GetSomeUsageMetricRecords?";
        if (assetId !== undefined)
            url_ += "AssetId=" + encodeURIComponent("" + assetId) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (referenceFilter !== undefined)
            url_ += "ReferenceFilter=" + encodeURIComponent("" + referenceFilter) + "&"; 
        if (maxStartTimeFilter !== undefined)
            url_ += "MaxStartTimeFilter=" + encodeURIComponent(maxStartTimeFilter ? "" + maxStartTimeFilter.toJSON() : "") + "&"; 
        if (minStartTimeFilter !== undefined)
            url_ += "MinStartTimeFilter=" + encodeURIComponent(minStartTimeFilter ? "" + minStartTimeFilter.toJSON() : "") + "&"; 
        if (maxEndTimeFilter !== undefined)
            url_ += "MaxEndTimeFilter=" + encodeURIComponent(maxEndTimeFilter ? "" + maxEndTimeFilter.toJSON() : "") + "&"; 
        if (minEndTimeFilter !== undefined)
            url_ += "MinEndTimeFilter=" + encodeURIComponent(minEndTimeFilter ? "" + minEndTimeFilter.toJSON() : "") + "&"; 
        if (maxUnitsConsumedFilter !== undefined)
            url_ += "MaxUnitsConsumedFilter=" + encodeURIComponent("" + maxUnitsConsumedFilter) + "&"; 
        if (minUnitsConsumedFilter !== undefined)
            url_ += "MinUnitsConsumedFilter=" + encodeURIComponent("" + minUnitsConsumedFilter) + "&"; 
        if (usageMetricMetricFilter !== undefined)
            url_ += "UsageMetricMetricFilter=" + encodeURIComponent("" + usageMetricMetricFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSomeUsageMetricRecords(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSomeUsageMetricRecords(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetUsageMetricRecordForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetUsageMetricRecordForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSomeUsageMetricRecords(response: HttpResponseBase): Observable<PagedResultDtoOfGetUsageMetricRecordForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetUsageMetricRecordForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetUsageMetricRecordForViewDto>(<any>null);
    }

    /**
     * @param days (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAssetsWithWorkorders(days: number | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<GetAssetsWithWorkordersForViewDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Assets/GetAssetsWithWorkorders?";
        if (days !== undefined)
            url_ += "Days=" + encodeURIComponent("" + days) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetsWithWorkorders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetsWithWorkorders(<any>response_);
                } catch (e) {
                    return <Observable<GetAssetsWithWorkordersForViewDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAssetsWithWorkordersForViewDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetsWithWorkorders(response: HttpResponseBase): Observable<GetAssetsWithWorkordersForViewDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetAssetsWithWorkordersForViewDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAssetsWithWorkordersForViewDto[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAssetForView(id: number | null | undefined): Observable<GetAssetForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Assets/GetAssetForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetForView(<any>response_);
                } catch (e) {
                    return <Observable<GetAssetForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAssetForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetForView(response: HttpResponseBase): Observable<GetAssetForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAssetForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAssetForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAssetForEdit(id: number | null | undefined): Observable<GetAssetForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Assets/GetAssetForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetAssetForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAssetForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetForEdit(response: HttpResponseBase): Observable<GetAssetForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAssetForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAssetForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditAssetDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Assets/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Assets/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param referenceFilter (optional) 
     * @param vehicleRegistrationNoFilter (optional) 
     * @param isExternalAssetFilter (optional) 
     * @param locationFilter (optional) 
     * @param serialNumberFilter (optional) 
     * @param engineNoFilter (optional) 
     * @param chassisNoFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param purchaseOrderNoFilter (optional) 
     * @param maxPurchaseDateFilter (optional) 
     * @param minPurchaseDateFilter (optional) 
     * @param maxPurchaseCostFilter (optional) 
     * @param minPurchaseCostFilter (optional) 
     * @param assetLoc8GUIDFilter (optional) 
     * @param assetClassClassFilter (optional) 
     * @param assetStatusStatusFilter (optional) 
     * @return Success
     */
    getAssetsToExcel(filter: string | null | undefined, referenceFilter: string | null | undefined, vehicleRegistrationNoFilter: string | null | undefined, isExternalAssetFilter: number | null | undefined, locationFilter: string | null | undefined, serialNumberFilter: string | null | undefined, engineNoFilter: string | null | undefined, chassisNoFilter: string | null | undefined, descriptionFilter: string | null | undefined, purchaseOrderNoFilter: string | null | undefined, maxPurchaseDateFilter: moment.Moment | null | undefined, minPurchaseDateFilter: moment.Moment | null | undefined, maxPurchaseCostFilter: number | null | undefined, minPurchaseCostFilter: number | null | undefined, assetLoc8GUIDFilter: string | null | undefined, assetClassClassFilter: string | null | undefined, assetStatusStatusFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Assets/GetAssetsToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (referenceFilter !== undefined)
            url_ += "ReferenceFilter=" + encodeURIComponent("" + referenceFilter) + "&"; 
        if (vehicleRegistrationNoFilter !== undefined)
            url_ += "VehicleRegistrationNoFilter=" + encodeURIComponent("" + vehicleRegistrationNoFilter) + "&"; 
        if (isExternalAssetFilter !== undefined)
            url_ += "IsExternalAssetFilter=" + encodeURIComponent("" + isExternalAssetFilter) + "&"; 
        if (locationFilter !== undefined)
            url_ += "LocationFilter=" + encodeURIComponent("" + locationFilter) + "&"; 
        if (serialNumberFilter !== undefined)
            url_ += "SerialNumberFilter=" + encodeURIComponent("" + serialNumberFilter) + "&"; 
        if (engineNoFilter !== undefined)
            url_ += "EngineNoFilter=" + encodeURIComponent("" + engineNoFilter) + "&"; 
        if (chassisNoFilter !== undefined)
            url_ += "ChassisNoFilter=" + encodeURIComponent("" + chassisNoFilter) + "&"; 
        if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (purchaseOrderNoFilter !== undefined)
            url_ += "PurchaseOrderNoFilter=" + encodeURIComponent("" + purchaseOrderNoFilter) + "&"; 
        if (maxPurchaseDateFilter !== undefined)
            url_ += "MaxPurchaseDateFilter=" + encodeURIComponent(maxPurchaseDateFilter ? "" + maxPurchaseDateFilter.toJSON() : "") + "&"; 
        if (minPurchaseDateFilter !== undefined)
            url_ += "MinPurchaseDateFilter=" + encodeURIComponent(minPurchaseDateFilter ? "" + minPurchaseDateFilter.toJSON() : "") + "&"; 
        if (maxPurchaseCostFilter !== undefined)
            url_ += "MaxPurchaseCostFilter=" + encodeURIComponent("" + maxPurchaseCostFilter) + "&"; 
        if (minPurchaseCostFilter !== undefined)
            url_ += "MinPurchaseCostFilter=" + encodeURIComponent("" + minPurchaseCostFilter) + "&"; 
        if (assetLoc8GUIDFilter !== undefined)
            url_ += "AssetLoc8GUIDFilter=" + encodeURIComponent("" + assetLoc8GUIDFilter) + "&"; 
        if (assetClassClassFilter !== undefined)
            url_ += "AssetClassClassFilter=" + encodeURIComponent("" + assetClassClassFilter) + "&"; 
        if (assetStatusStatusFilter !== undefined)
            url_ += "AssetStatusStatusFilter=" + encodeURIComponent("" + assetStatusStatusFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllAssetClassForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfAssetAssetClassLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Assets/GetAllAssetClassForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAssetClassForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAssetClassForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAssetAssetClassLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAssetAssetClassLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAssetClassForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfAssetAssetClassLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAssetAssetClassLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAssetAssetClassLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllAssetStatusForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfAssetAssetStatusLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Assets/GetAllAssetStatusForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAssetStatusForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAssetStatusForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAssetAssetStatusLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAssetAssetStatusLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAssetStatusForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfAssetAssetStatusLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAssetAssetStatusLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAssetAssetStatusLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllLocationForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfLocationLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Assets/GetAllLocationForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllLocationForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllLocationForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfLocationLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfLocationLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllLocationForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfLocationLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfLocationLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfLocationLookupTableDto>(<any>null);
    }

    /**
     * @param assetId (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @param sorting (optional) 
     * @return Success
     */
    getAllLeaseItems(assetId: number | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined, sorting: string | null | undefined): Observable<PagedResultDtoOfGetLeaseItemForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Assets/GetAllLeaseItems?";
        if (assetId !== undefined)
            url_ += "assetId=" + encodeURIComponent("" + assetId) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllLeaseItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllLeaseItems(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetLeaseItemForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetLeaseItemForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllLeaseItems(response: HttpResponseBase): Observable<PagedResultDtoOfGetLeaseItemForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetLeaseItemForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetLeaseItemForViewDto>(<any>null);
    }

    /**
     * @param assetId (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @param sorting (optional) 
     * @return Success
     */
    getAllSupportItems(assetId: number | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined, sorting: string | null | undefined): Observable<PagedResultDtoOfGetSupportItemForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Assets/GetAllSupportItems?";
        if (assetId !== undefined)
            url_ += "assetId=" + encodeURIComponent("" + assetId) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSupportItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSupportItems(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetSupportItemForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetSupportItemForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSupportItems(response: HttpResponseBase): Observable<PagedResultDtoOfGetSupportItemForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetSupportItemForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetSupportItemForViewDto>(<any>null);
    }

    /**
     * @param assetId (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @param sorting (optional) 
     * @return Success
     */
    getAllWorkOrders(assetId: number | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined, sorting: string | null | undefined): Observable<PagedResultDtoOfGetWorkOrderForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Assets/GetAllWorkOrders?";
        if (assetId !== undefined)
            url_ += "assetId=" + encodeURIComponent("" + assetId) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWorkOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWorkOrders(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetWorkOrderForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetWorkOrderForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllWorkOrders(response: HttpResponseBase): Observable<PagedResultDtoOfGetWorkOrderForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetWorkOrderForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetWorkOrderForViewDto>(<any>null);
    }

    /**
     * @param assetId (optional) 
     * @param periodType (optional) 
     * @param periods (optional) 
     * @return Success
     */
    getUsageMetricsData(assetId: number | null | undefined, periodType: string | null | undefined, periods: number | null | undefined): Observable<UsageMetricsChartOutput[]> {
        let url_ = this.baseUrl + "/api/services/app/Assets/GetUsageMetricsData?";
        if (assetId !== undefined)
            url_ += "assetId=" + encodeURIComponent("" + assetId) + "&"; 
        if (periodType !== undefined)
            url_ += "periodType=" + encodeURIComponent("" + periodType) + "&"; 
        if (periods !== undefined)
            url_ += "periods=" + encodeURIComponent("" + periods) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsageMetricsData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsageMetricsData(<any>response_);
                } catch (e) {
                    return <Observable<UsageMetricsChartOutput[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UsageMetricsChartOutput[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsageMetricsData(response: HttpResponseBase): Observable<UsageMetricsChartOutput[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UsageMetricsChartOutput.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UsageMetricsChartOutput[]>(<any>null);
    }
}

@Injectable()
export class AssetStatusesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetAssetStatusForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/AssetStatuses/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetAssetStatusForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetAssetStatusForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetAssetStatusForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetAssetStatusForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetAssetStatusForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAssetStatusForView(id: number | null | undefined): Observable<GetAssetStatusForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/AssetStatuses/GetAssetStatusForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetStatusForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetStatusForView(<any>response_);
                } catch (e) {
                    return <Observable<GetAssetStatusForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAssetStatusForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetStatusForView(response: HttpResponseBase): Observable<GetAssetStatusForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAssetStatusForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAssetStatusForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAssetStatusForEdit(id: number | null | undefined): Observable<GetAssetStatusForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/AssetStatuses/GetAssetStatusForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetStatusForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetStatusForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetAssetStatusForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAssetStatusForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetStatusForEdit(response: HttpResponseBase): Observable<GetAssetStatusForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAssetStatusForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAssetStatusForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditAssetStatusDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AssetStatuses/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AssetStatuses/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class AssetTypesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetAssetTypeForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/AssetTypes/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetAssetTypeForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetAssetTypeForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetAssetTypeForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetAssetTypeForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetAssetTypeForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAssetTypeForView(id: number | null | undefined): Observable<GetAssetTypeForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/AssetTypes/GetAssetTypeForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetTypeForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetTypeForView(<any>response_);
                } catch (e) {
                    return <Observable<GetAssetTypeForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAssetTypeForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetTypeForView(response: HttpResponseBase): Observable<GetAssetTypeForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAssetTypeForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAssetTypeForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAssetTypeForEdit(id: number | null | undefined): Observable<GetAssetTypeForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/AssetTypes/GetAssetTypeForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetTypeForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetTypeForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetAssetTypeForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAssetTypeForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetTypeForEdit(response: HttpResponseBase): Observable<GetAssetTypeForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAssetTypeForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAssetTypeForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditAssetTypeDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AssetTypes/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AssetTypes/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class AttachmentsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param filenameFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param maxUploadedAtFilter (optional) 
     * @param minUploadedAtFilter (optional) 
     * @param maxUploadedByFilter (optional) 
     * @param minUploadedByFilter (optional) 
     * @param blobFolderFilter (optional) 
     * @param blobIdFilter (optional) 
     * @param assetReferenceFilter (optional) 
     * @param incidentDescriptionFilter (optional) 
     * @param leaseAgreementReferenceFilter (optional) 
     * @param quotationTitleFilter (optional) 
     * @param supportContractTitleFilter (optional) 
     * @param workOrderSubjectFilter (optional) 
     * @param customerInvoiceDescriptionFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, filenameFilter: string | null | undefined, descriptionFilter: string | null | undefined, maxUploadedAtFilter: moment.Moment | null | undefined, minUploadedAtFilter: moment.Moment | null | undefined, maxUploadedByFilter: number | null | undefined, minUploadedByFilter: number | null | undefined, blobFolderFilter: string | null | undefined, blobIdFilter: string | null | undefined, assetReferenceFilter: string | null | undefined, incidentDescriptionFilter: string | null | undefined, leaseAgreementReferenceFilter: string | null | undefined, quotationTitleFilter: string | null | undefined, supportContractTitleFilter: string | null | undefined, workOrderSubjectFilter: string | null | undefined, customerInvoiceDescriptionFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetAttachmentForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Attachments/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (filenameFilter !== undefined)
            url_ += "FilenameFilter=" + encodeURIComponent("" + filenameFilter) + "&"; 
        if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (maxUploadedAtFilter !== undefined)
            url_ += "MaxUploadedAtFilter=" + encodeURIComponent(maxUploadedAtFilter ? "" + maxUploadedAtFilter.toJSON() : "") + "&"; 
        if (minUploadedAtFilter !== undefined)
            url_ += "MinUploadedAtFilter=" + encodeURIComponent(minUploadedAtFilter ? "" + minUploadedAtFilter.toJSON() : "") + "&"; 
        if (maxUploadedByFilter !== undefined)
            url_ += "MaxUploadedByFilter=" + encodeURIComponent("" + maxUploadedByFilter) + "&"; 
        if (minUploadedByFilter !== undefined)
            url_ += "MinUploadedByFilter=" + encodeURIComponent("" + minUploadedByFilter) + "&"; 
        if (blobFolderFilter !== undefined)
            url_ += "BlobFolderFilter=" + encodeURIComponent("" + blobFolderFilter) + "&"; 
        if (blobIdFilter !== undefined)
            url_ += "BlobIdFilter=" + encodeURIComponent("" + blobIdFilter) + "&"; 
        if (assetReferenceFilter !== undefined)
            url_ += "AssetReferenceFilter=" + encodeURIComponent("" + assetReferenceFilter) + "&"; 
        if (incidentDescriptionFilter !== undefined)
            url_ += "IncidentDescriptionFilter=" + encodeURIComponent("" + incidentDescriptionFilter) + "&"; 
        if (leaseAgreementReferenceFilter !== undefined)
            url_ += "LeaseAgreementReferenceFilter=" + encodeURIComponent("" + leaseAgreementReferenceFilter) + "&"; 
        if (quotationTitleFilter !== undefined)
            url_ += "QuotationTitleFilter=" + encodeURIComponent("" + quotationTitleFilter) + "&"; 
        if (supportContractTitleFilter !== undefined)
            url_ += "SupportContractTitleFilter=" + encodeURIComponent("" + supportContractTitleFilter) + "&"; 
        if (workOrderSubjectFilter !== undefined)
            url_ += "WorkOrderSubjectFilter=" + encodeURIComponent("" + workOrderSubjectFilter) + "&"; 
        if (customerInvoiceDescriptionFilter !== undefined)
            url_ += "CustomerInvoiceDescriptionFilter=" + encodeURIComponent("" + customerInvoiceDescriptionFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetAttachmentForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetAttachmentForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetAttachmentForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetAttachmentForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetAttachmentForViewDto>(<any>null);
    }

    /**
     * @param relatedEntity (optional) 
     * @param referenceId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getSome(relatedEntity: string | null | undefined, referenceId: number | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetAttachmentForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Attachments/GetSome?";
        if (relatedEntity !== undefined)
            url_ += "RelatedEntity=" + encodeURIComponent("" + relatedEntity) + "&"; 
        if (referenceId !== undefined)
            url_ += "ReferenceId=" + encodeURIComponent("" + referenceId) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSome(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSome(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetAttachmentForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetAttachmentForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSome(response: HttpResponseBase): Observable<PagedResultDtoOfGetAttachmentForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetAttachmentForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetAttachmentForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAttachmentForView(id: number | null | undefined): Observable<GetAttachmentForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Attachments/GetAttachmentForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAttachmentForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAttachmentForView(<any>response_);
                } catch (e) {
                    return <Observable<GetAttachmentForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAttachmentForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAttachmentForView(response: HttpResponseBase): Observable<GetAttachmentForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAttachmentForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAttachmentForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAttachmentForEdit(id: number | null | undefined): Observable<GetAttachmentForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Attachments/GetAttachmentForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAttachmentForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAttachmentForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetAttachmentForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAttachmentForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetAttachmentForEdit(response: HttpResponseBase): Observable<GetAttachmentForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAttachmentForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAttachmentForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditAttachmentDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Attachments/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Attachments/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param filenameFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param maxUploadedAtFilter (optional) 
     * @param minUploadedAtFilter (optional) 
     * @param maxUploadedByFilter (optional) 
     * @param minUploadedByFilter (optional) 
     * @param blobFolderFilter (optional) 
     * @param blobIdFilter (optional) 
     * @param assetReferenceFilter (optional) 
     * @param incidentDescriptionFilter (optional) 
     * @param leaseAgreementReferenceFilter (optional) 
     * @param quotationTitleFilter (optional) 
     * @param supportContractTitleFilter (optional) 
     * @param workOrderSubjectFilter (optional) 
     * @param customerInvoiceDescriptionFilter (optional) 
     * @return Success
     */
    getAttachmentsToExcel(filter: string | null | undefined, filenameFilter: string | null | undefined, descriptionFilter: string | null | undefined, maxUploadedAtFilter: moment.Moment | null | undefined, minUploadedAtFilter: moment.Moment | null | undefined, maxUploadedByFilter: number | null | undefined, minUploadedByFilter: number | null | undefined, blobFolderFilter: string | null | undefined, blobIdFilter: string | null | undefined, assetReferenceFilter: string | null | undefined, incidentDescriptionFilter: string | null | undefined, leaseAgreementReferenceFilter: string | null | undefined, quotationTitleFilter: string | null | undefined, supportContractTitleFilter: string | null | undefined, workOrderSubjectFilter: string | null | undefined, customerInvoiceDescriptionFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Attachments/GetAttachmentsToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (filenameFilter !== undefined)
            url_ += "FilenameFilter=" + encodeURIComponent("" + filenameFilter) + "&"; 
        if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (maxUploadedAtFilter !== undefined)
            url_ += "MaxUploadedAtFilter=" + encodeURIComponent(maxUploadedAtFilter ? "" + maxUploadedAtFilter.toJSON() : "") + "&"; 
        if (minUploadedAtFilter !== undefined)
            url_ += "MinUploadedAtFilter=" + encodeURIComponent(minUploadedAtFilter ? "" + minUploadedAtFilter.toJSON() : "") + "&"; 
        if (maxUploadedByFilter !== undefined)
            url_ += "MaxUploadedByFilter=" + encodeURIComponent("" + maxUploadedByFilter) + "&"; 
        if (minUploadedByFilter !== undefined)
            url_ += "MinUploadedByFilter=" + encodeURIComponent("" + minUploadedByFilter) + "&"; 
        if (blobFolderFilter !== undefined)
            url_ += "BlobFolderFilter=" + encodeURIComponent("" + blobFolderFilter) + "&"; 
        if (blobIdFilter !== undefined)
            url_ += "BlobIdFilter=" + encodeURIComponent("" + blobIdFilter) + "&"; 
        if (assetReferenceFilter !== undefined)
            url_ += "AssetReferenceFilter=" + encodeURIComponent("" + assetReferenceFilter) + "&"; 
        if (incidentDescriptionFilter !== undefined)
            url_ += "IncidentDescriptionFilter=" + encodeURIComponent("" + incidentDescriptionFilter) + "&"; 
        if (leaseAgreementReferenceFilter !== undefined)
            url_ += "LeaseAgreementReferenceFilter=" + encodeURIComponent("" + leaseAgreementReferenceFilter) + "&"; 
        if (quotationTitleFilter !== undefined)
            url_ += "QuotationTitleFilter=" + encodeURIComponent("" + quotationTitleFilter) + "&"; 
        if (supportContractTitleFilter !== undefined)
            url_ += "SupportContractTitleFilter=" + encodeURIComponent("" + supportContractTitleFilter) + "&"; 
        if (workOrderSubjectFilter !== undefined)
            url_ += "WorkOrderSubjectFilter=" + encodeURIComponent("" + workOrderSubjectFilter) + "&"; 
        if (customerInvoiceDescriptionFilter !== undefined)
            url_ += "CustomerInvoiceDescriptionFilter=" + encodeURIComponent("" + customerInvoiceDescriptionFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAttachmentsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAttachmentsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAttachmentsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllAssetForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfAttachmentAssetLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Attachments/GetAllAssetForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAssetForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAssetForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAttachmentAssetLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAttachmentAssetLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAssetForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfAttachmentAssetLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAttachmentAssetLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAttachmentAssetLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllIncidentForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfAttachmentIncidentLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Attachments/GetAllIncidentForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllIncidentForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllIncidentForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAttachmentIncidentLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAttachmentIncidentLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllIncidentForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfAttachmentIncidentLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAttachmentIncidentLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAttachmentIncidentLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllLeaseAgreementForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfAttachmentLeaseAgreementLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Attachments/GetAllLeaseAgreementForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllLeaseAgreementForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllLeaseAgreementForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAttachmentLeaseAgreementLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAttachmentLeaseAgreementLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllLeaseAgreementForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfAttachmentLeaseAgreementLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAttachmentLeaseAgreementLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAttachmentLeaseAgreementLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllQuotationForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfAttachmentQuotationLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Attachments/GetAllQuotationForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllQuotationForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllQuotationForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAttachmentQuotationLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAttachmentQuotationLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllQuotationForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfAttachmentQuotationLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAttachmentQuotationLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAttachmentQuotationLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllSupportContractForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfAttachmentSupportContractLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Attachments/GetAllSupportContractForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSupportContractForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSupportContractForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAttachmentSupportContractLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAttachmentSupportContractLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSupportContractForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfAttachmentSupportContractLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAttachmentSupportContractLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAttachmentSupportContractLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllWorkOrderForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfAttachmentWorkOrderLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Attachments/GetAllWorkOrderForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWorkOrderForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWorkOrderForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAttachmentWorkOrderLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAttachmentWorkOrderLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllWorkOrderForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfAttachmentWorkOrderLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAttachmentWorkOrderLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAttachmentWorkOrderLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllCustomerInvoiceForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfAttachmentCustomerInvoiceLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Attachments/GetAllCustomerInvoiceForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCustomerInvoiceForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCustomerInvoiceForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAttachmentCustomerInvoiceLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAttachmentCustomerInvoiceLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCustomerInvoiceForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfAttachmentCustomerInvoiceLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAttachmentCustomerInvoiceLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAttachmentCustomerInvoiceLookupTableDto>(<any>null);
    }
}

@Injectable()
export class AuditLogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param userName (optional) 
     * @param serviceName (optional) 
     * @param methodName (optional) 
     * @param browserInfo (optional) 
     * @param hasException (optional) 
     * @param minExecutionDuration (optional) 
     * @param maxExecutionDuration (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAuditLogs(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, userName: string | null | undefined, serviceName: string | null | undefined, methodName: string | null | undefined, browserInfo: string | null | undefined, hasException: boolean | null | undefined, minExecutionDuration: number | null | undefined, maxExecutionDuration: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfAuditLogListDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetAuditLogs?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&"; 
        if (serviceName !== undefined)
            url_ += "ServiceName=" + encodeURIComponent("" + serviceName) + "&"; 
        if (methodName !== undefined)
            url_ += "MethodName=" + encodeURIComponent("" + methodName) + "&"; 
        if (browserInfo !== undefined)
            url_ += "BrowserInfo=" + encodeURIComponent("" + browserInfo) + "&"; 
        if (hasException !== undefined)
            url_ += "HasException=" + encodeURIComponent("" + hasException) + "&"; 
        if (minExecutionDuration !== undefined)
            url_ += "MinExecutionDuration=" + encodeURIComponent("" + minExecutionDuration) + "&"; 
        if (maxExecutionDuration !== undefined)
            url_ += "MaxExecutionDuration=" + encodeURIComponent("" + maxExecutionDuration) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAuditLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuditLogs(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfAuditLogListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfAuditLogListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAuditLogs(response: HttpResponseBase): Observable<PagedResultDtoOfAuditLogListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfAuditLogListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfAuditLogListDto>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param userName (optional) 
     * @param serviceName (optional) 
     * @param methodName (optional) 
     * @param browserInfo (optional) 
     * @param hasException (optional) 
     * @param minExecutionDuration (optional) 
     * @param maxExecutionDuration (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getAuditLogsToExcel(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, userName: string | null | undefined, serviceName: string | null | undefined, methodName: string | null | undefined, browserInfo: string | null | undefined, hasException: boolean | null | undefined, minExecutionDuration: number | null | undefined, maxExecutionDuration: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetAuditLogsToExcel?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&"; 
        if (serviceName !== undefined)
            url_ += "ServiceName=" + encodeURIComponent("" + serviceName) + "&"; 
        if (methodName !== undefined)
            url_ += "MethodName=" + encodeURIComponent("" + methodName) + "&"; 
        if (browserInfo !== undefined)
            url_ += "BrowserInfo=" + encodeURIComponent("" + browserInfo) + "&"; 
        if (hasException !== undefined)
            url_ += "HasException=" + encodeURIComponent("" + hasException) + "&"; 
        if (minExecutionDuration !== undefined)
            url_ += "MinExecutionDuration=" + encodeURIComponent("" + minExecutionDuration) + "&"; 
        if (maxExecutionDuration !== undefined)
            url_ += "MaxExecutionDuration=" + encodeURIComponent("" + maxExecutionDuration) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAuditLogsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuditLogsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAuditLogsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @return Success
     */
    getEntityHistoryObjectTypes(): Observable<NameValueDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityHistoryObjectTypes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityHistoryObjectTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityHistoryObjectTypes(<any>response_);
                } catch (e) {
                    return <Observable<NameValueDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityHistoryObjectTypes(response: HttpResponseBase): Observable<NameValueDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameValueDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueDto[]>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param userName (optional) 
     * @param entityTypeFullName (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getEntityChanges(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, userName: string | null | undefined, entityTypeFullName: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfEntityChangeListDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityChanges?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&"; 
        if (entityTypeFullName !== undefined)
            url_ += "EntityTypeFullName=" + encodeURIComponent("" + entityTypeFullName) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityChanges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityChanges(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfEntityChangeListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfEntityChangeListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityChanges(response: HttpResponseBase): Observable<PagedResultDtoOfEntityChangeListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfEntityChangeListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfEntityChangeListDto>(<any>null);
    }

    /**
     * @param entityTypeFullName (optional) 
     * @param entityId (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getEntityTypeChanges(entityTypeFullName: string | null | undefined, entityId: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfEntityChangeListDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityTypeChanges?";
        if (entityTypeFullName !== undefined)
            url_ += "EntityTypeFullName=" + encodeURIComponent("" + entityTypeFullName) + "&"; 
        if (entityId !== undefined)
            url_ += "EntityId=" + encodeURIComponent("" + entityId) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityTypeChanges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityTypeChanges(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfEntityChangeListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfEntityChangeListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityTypeChanges(response: HttpResponseBase): Observable<PagedResultDtoOfEntityChangeListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfEntityChangeListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfEntityChangeListDto>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param userName (optional) 
     * @param entityTypeFullName (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getEntityChangesToExcel(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, userName: string | null | undefined, entityTypeFullName: string | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityChangesToExcel?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&"; 
        if (entityTypeFullName !== undefined)
            url_ += "EntityTypeFullName=" + encodeURIComponent("" + entityTypeFullName) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityChangesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityChangesToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityChangesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param entityChangeId (optional) 
     * @return Success
     */
    getEntityPropertyChanges(entityChangeId: number | null | undefined): Observable<EntityPropertyChangeDto[]> {
        let url_ = this.baseUrl + "/api/services/app/AuditLog/GetEntityPropertyChanges?";
        if (entityChangeId !== undefined)
            url_ += "entityChangeId=" + encodeURIComponent("" + entityChangeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityPropertyChanges(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityPropertyChanges(<any>response_);
                } catch (e) {
                    return <Observable<EntityPropertyChangeDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EntityPropertyChangeDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityPropertyChanges(response: HttpResponseBase): Observable<EntityPropertyChangeDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EntityPropertyChangeDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityPropertyChangeDto[]>(<any>null);
    }
}

@Injectable()
export class AzureStorageConfigurationsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param serviceFilter (optional) 
     * @param accountNameFilter (optional) 
     * @param keyValueFilter (optional) 
     * @param blobStorageEndpointFilter (optional) 
     * @param containerNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, serviceFilter: string | null | undefined, accountNameFilter: string | null | undefined, keyValueFilter: string | null | undefined, blobStorageEndpointFilter: string | null | undefined, containerNameFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetAzureStorageConfigurationForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/AzureStorageConfigurations/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (serviceFilter !== undefined)
            url_ += "ServiceFilter=" + encodeURIComponent("" + serviceFilter) + "&"; 
        if (accountNameFilter !== undefined)
            url_ += "AccountNameFilter=" + encodeURIComponent("" + accountNameFilter) + "&"; 
        if (keyValueFilter !== undefined)
            url_ += "KeyValueFilter=" + encodeURIComponent("" + keyValueFilter) + "&"; 
        if (blobStorageEndpointFilter !== undefined)
            url_ += "BlobStorageEndpointFilter=" + encodeURIComponent("" + blobStorageEndpointFilter) + "&"; 
        if (containerNameFilter !== undefined)
            url_ += "ContainerNameFilter=" + encodeURIComponent("" + containerNameFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetAzureStorageConfigurationForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetAzureStorageConfigurationForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetAzureStorageConfigurationForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetAzureStorageConfigurationForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetAzureStorageConfigurationForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAzureStorageConfigurationForView(id: number | null | undefined): Observable<GetAzureStorageConfigurationForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/AzureStorageConfigurations/GetAzureStorageConfigurationForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAzureStorageConfigurationForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAzureStorageConfigurationForView(<any>response_);
                } catch (e) {
                    return <Observable<GetAzureStorageConfigurationForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAzureStorageConfigurationForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAzureStorageConfigurationForView(response: HttpResponseBase): Observable<GetAzureStorageConfigurationForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAzureStorageConfigurationForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAzureStorageConfigurationForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAzureStorageConfigurationForEdit(id: number | null | undefined): Observable<GetAzureStorageConfigurationForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/AzureStorageConfigurations/GetAzureStorageConfigurationForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAzureStorageConfigurationForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAzureStorageConfigurationForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetAzureStorageConfigurationForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAzureStorageConfigurationForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetAzureStorageConfigurationForEdit(response: HttpResponseBase): Observable<GetAzureStorageConfigurationForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAzureStorageConfigurationForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAzureStorageConfigurationForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditAzureStorageConfigurationDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AzureStorageConfigurations/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/AzureStorageConfigurations/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param serviceFilter (optional) 
     * @param accountNameFilter (optional) 
     * @param keyValueFilter (optional) 
     * @param blobStorageEndpointFilter (optional) 
     * @param containerNameFilter (optional) 
     * @return Success
     */
    getAzureStorageConfigurationsToExcel(filter: string | null | undefined, serviceFilter: string | null | undefined, accountNameFilter: string | null | undefined, keyValueFilter: string | null | undefined, blobStorageEndpointFilter: string | null | undefined, containerNameFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/AzureStorageConfigurations/GetAzureStorageConfigurationsToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (serviceFilter !== undefined)
            url_ += "ServiceFilter=" + encodeURIComponent("" + serviceFilter) + "&"; 
        if (accountNameFilter !== undefined)
            url_ += "AccountNameFilter=" + encodeURIComponent("" + accountNameFilter) + "&"; 
        if (keyValueFilter !== undefined)
            url_ += "KeyValueFilter=" + encodeURIComponent("" + keyValueFilter) + "&"; 
        if (blobStorageEndpointFilter !== undefined)
            url_ += "BlobStorageEndpointFilter=" + encodeURIComponent("" + blobStorageEndpointFilter) + "&"; 
        if (containerNameFilter !== undefined)
            url_ += "ContainerNameFilter=" + encodeURIComponent("" + containerNameFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAzureStorageConfigurationsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAzureStorageConfigurationsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAzureStorageConfigurationsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class BillingEventDetailsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param ruleExecutedSuccessfullyFilter (optional) 
     * @param exceptionFilter (optional) 
     * @param billingRuleNameFilter (optional) 
     * @param leaseItemItemFilter (optional) 
     * @param billingEventPurposeFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, ruleExecutedSuccessfullyFilter: number | null | undefined, exceptionFilter: string | null | undefined, billingRuleNameFilter: string | null | undefined, leaseItemItemFilter: string | null | undefined, billingEventPurposeFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetBillingEventDetailForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/BillingEventDetails/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (ruleExecutedSuccessfullyFilter !== undefined)
            url_ += "RuleExecutedSuccessfullyFilter=" + encodeURIComponent("" + ruleExecutedSuccessfullyFilter) + "&"; 
        if (exceptionFilter !== undefined)
            url_ += "ExceptionFilter=" + encodeURIComponent("" + exceptionFilter) + "&"; 
        if (billingRuleNameFilter !== undefined)
            url_ += "BillingRuleNameFilter=" + encodeURIComponent("" + billingRuleNameFilter) + "&"; 
        if (leaseItemItemFilter !== undefined)
            url_ += "LeaseItemItemFilter=" + encodeURIComponent("" + leaseItemItemFilter) + "&"; 
        if (billingEventPurposeFilter !== undefined)
            url_ += "BillingEventPurposeFilter=" + encodeURIComponent("" + billingEventPurposeFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetBillingEventDetailForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetBillingEventDetailForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetBillingEventDetailForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetBillingEventDetailForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetBillingEventDetailForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getBillingEventDetailForView(id: number | null | undefined): Observable<GetBillingEventDetailForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/BillingEventDetails/GetBillingEventDetailForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBillingEventDetailForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBillingEventDetailForView(<any>response_);
                } catch (e) {
                    return <Observable<GetBillingEventDetailForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetBillingEventDetailForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBillingEventDetailForView(response: HttpResponseBase): Observable<GetBillingEventDetailForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetBillingEventDetailForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetBillingEventDetailForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getBillingEventDetailForEdit(id: number | null | undefined): Observable<GetBillingEventDetailForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/BillingEventDetails/GetBillingEventDetailForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBillingEventDetailForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBillingEventDetailForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetBillingEventDetailForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetBillingEventDetailForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetBillingEventDetailForEdit(response: HttpResponseBase): Observable<GetBillingEventDetailForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetBillingEventDetailForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetBillingEventDetailForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditBillingEventDetailDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BillingEventDetails/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BillingEventDetails/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param ruleExecutedSuccessfullyFilter (optional) 
     * @param exceptionFilter (optional) 
     * @param billingRuleNameFilter (optional) 
     * @param leaseItemItemFilter (optional) 
     * @param billingEventPurposeFilter (optional) 
     * @return Success
     */
    getBillingEventDetailsToExcel(filter: string | null | undefined, ruleExecutedSuccessfullyFilter: number | null | undefined, exceptionFilter: string | null | undefined, billingRuleNameFilter: string | null | undefined, leaseItemItemFilter: string | null | undefined, billingEventPurposeFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/BillingEventDetails/GetBillingEventDetailsToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (ruleExecutedSuccessfullyFilter !== undefined)
            url_ += "RuleExecutedSuccessfullyFilter=" + encodeURIComponent("" + ruleExecutedSuccessfullyFilter) + "&"; 
        if (exceptionFilter !== undefined)
            url_ += "ExceptionFilter=" + encodeURIComponent("" + exceptionFilter) + "&"; 
        if (billingRuleNameFilter !== undefined)
            url_ += "BillingRuleNameFilter=" + encodeURIComponent("" + billingRuleNameFilter) + "&"; 
        if (leaseItemItemFilter !== undefined)
            url_ += "LeaseItemItemFilter=" + encodeURIComponent("" + leaseItemItemFilter) + "&"; 
        if (billingEventPurposeFilter !== undefined)
            url_ += "BillingEventPurposeFilter=" + encodeURIComponent("" + billingEventPurposeFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBillingEventDetailsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBillingEventDetailsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBillingEventDetailsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllBillingRuleForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfBillingEventDetailBillingRuleLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/BillingEventDetails/GetAllBillingRuleForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBillingRuleForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBillingRuleForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfBillingEventDetailBillingRuleLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfBillingEventDetailBillingRuleLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllBillingRuleForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfBillingEventDetailBillingRuleLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfBillingEventDetailBillingRuleLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfBillingEventDetailBillingRuleLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllLeaseItemForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfBillingEventDetailLeaseItemLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/BillingEventDetails/GetAllLeaseItemForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllLeaseItemForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllLeaseItemForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfBillingEventDetailLeaseItemLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfBillingEventDetailLeaseItemLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllLeaseItemForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfBillingEventDetailLeaseItemLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfBillingEventDetailLeaseItemLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfBillingEventDetailLeaseItemLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllBillingEventForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfBillingEventDetailBillingEventLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/BillingEventDetails/GetAllBillingEventForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBillingEventForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBillingEventForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfBillingEventDetailBillingEventLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfBillingEventDetailBillingEventLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllBillingEventForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfBillingEventDetailBillingEventLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfBillingEventDetailBillingEventLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfBillingEventDetailBillingEventLookupTableDto>(<any>null);
    }
}

@Injectable()
export class BillingEventsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param maxBillingEventDateFilter (optional) 
     * @param minBillingEventDateFilter (optional) 
     * @param triggeredByFilter (optional) 
     * @param purposeFilter (optional) 
     * @param wasInvoiceGeneratedFilter (optional) 
     * @param leaseAgreementTitleFilter (optional) 
     * @param vendorChargeReferenceFilter (optional) 
     * @param billingEventTypeTypeFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, maxBillingEventDateFilter: moment.Moment | null | undefined, minBillingEventDateFilter: moment.Moment | null | undefined, triggeredByFilter: string | null | undefined, purposeFilter: string | null | undefined, wasInvoiceGeneratedFilter: number | null | undefined, leaseAgreementTitleFilter: string | null | undefined, vendorChargeReferenceFilter: string | null | undefined, billingEventTypeTypeFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetBillingEventForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/BillingEvents/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxBillingEventDateFilter !== undefined)
            url_ += "MaxBillingEventDateFilter=" + encodeURIComponent(maxBillingEventDateFilter ? "" + maxBillingEventDateFilter.toJSON() : "") + "&"; 
        if (minBillingEventDateFilter !== undefined)
            url_ += "MinBillingEventDateFilter=" + encodeURIComponent(minBillingEventDateFilter ? "" + minBillingEventDateFilter.toJSON() : "") + "&"; 
        if (triggeredByFilter !== undefined)
            url_ += "TriggeredByFilter=" + encodeURIComponent("" + triggeredByFilter) + "&"; 
        if (purposeFilter !== undefined)
            url_ += "PurposeFilter=" + encodeURIComponent("" + purposeFilter) + "&"; 
        if (wasInvoiceGeneratedFilter !== undefined)
            url_ += "WasInvoiceGeneratedFilter=" + encodeURIComponent("" + wasInvoiceGeneratedFilter) + "&"; 
        if (leaseAgreementTitleFilter !== undefined)
            url_ += "LeaseAgreementTitleFilter=" + encodeURIComponent("" + leaseAgreementTitleFilter) + "&"; 
        if (vendorChargeReferenceFilter !== undefined)
            url_ += "VendorChargeReferenceFilter=" + encodeURIComponent("" + vendorChargeReferenceFilter) + "&"; 
        if (billingEventTypeTypeFilter !== undefined)
            url_ += "BillingEventTypeTypeFilter=" + encodeURIComponent("" + billingEventTypeTypeFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetBillingEventForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetBillingEventForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetBillingEventForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetBillingEventForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetBillingEventForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getBillingEventForView(id: number | null | undefined): Observable<GetBillingEventForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/BillingEvents/GetBillingEventForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBillingEventForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBillingEventForView(<any>response_);
                } catch (e) {
                    return <Observable<GetBillingEventForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetBillingEventForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBillingEventForView(response: HttpResponseBase): Observable<GetBillingEventForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetBillingEventForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetBillingEventForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getBillingEventForEdit(id: number | null | undefined): Observable<GetBillingEventForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/BillingEvents/GetBillingEventForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBillingEventForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBillingEventForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetBillingEventForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetBillingEventForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetBillingEventForEdit(response: HttpResponseBase): Observable<GetBillingEventForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetBillingEventForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetBillingEventForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditBillingEventDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BillingEvents/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BillingEvents/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param maxBillingEventDateFilter (optional) 
     * @param minBillingEventDateFilter (optional) 
     * @param triggeredByFilter (optional) 
     * @param purposeFilter (optional) 
     * @param wasInvoiceGeneratedFilter (optional) 
     * @param leaseAgreementTitleFilter (optional) 
     * @param vendorChargeReferenceFilter (optional) 
     * @param billingEventTypeTypeFilter (optional) 
     * @return Success
     */
    getBillingEventsToExcel(filter: string | null | undefined, maxBillingEventDateFilter: moment.Moment | null | undefined, minBillingEventDateFilter: moment.Moment | null | undefined, triggeredByFilter: string | null | undefined, purposeFilter: string | null | undefined, wasInvoiceGeneratedFilter: number | null | undefined, leaseAgreementTitleFilter: string | null | undefined, vendorChargeReferenceFilter: string | null | undefined, billingEventTypeTypeFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/BillingEvents/GetBillingEventsToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxBillingEventDateFilter !== undefined)
            url_ += "MaxBillingEventDateFilter=" + encodeURIComponent(maxBillingEventDateFilter ? "" + maxBillingEventDateFilter.toJSON() : "") + "&"; 
        if (minBillingEventDateFilter !== undefined)
            url_ += "MinBillingEventDateFilter=" + encodeURIComponent(minBillingEventDateFilter ? "" + minBillingEventDateFilter.toJSON() : "") + "&"; 
        if (triggeredByFilter !== undefined)
            url_ += "TriggeredByFilter=" + encodeURIComponent("" + triggeredByFilter) + "&"; 
        if (purposeFilter !== undefined)
            url_ += "PurposeFilter=" + encodeURIComponent("" + purposeFilter) + "&"; 
        if (wasInvoiceGeneratedFilter !== undefined)
            url_ += "WasInvoiceGeneratedFilter=" + encodeURIComponent("" + wasInvoiceGeneratedFilter) + "&"; 
        if (leaseAgreementTitleFilter !== undefined)
            url_ += "LeaseAgreementTitleFilter=" + encodeURIComponent("" + leaseAgreementTitleFilter) + "&"; 
        if (vendorChargeReferenceFilter !== undefined)
            url_ += "VendorChargeReferenceFilter=" + encodeURIComponent("" + vendorChargeReferenceFilter) + "&"; 
        if (billingEventTypeTypeFilter !== undefined)
            url_ += "BillingEventTypeTypeFilter=" + encodeURIComponent("" + billingEventTypeTypeFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBillingEventsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBillingEventsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBillingEventsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllLeaseAgreementForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfBillingEventLeaseAgreementLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/BillingEvents/GetAllLeaseAgreementForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllLeaseAgreementForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllLeaseAgreementForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfBillingEventLeaseAgreementLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfBillingEventLeaseAgreementLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllLeaseAgreementForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfBillingEventLeaseAgreementLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfBillingEventLeaseAgreementLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfBillingEventLeaseAgreementLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllVendorChargeForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfBillingEventVendorChargeLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/BillingEvents/GetAllVendorChargeForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllVendorChargeForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllVendorChargeForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfBillingEventVendorChargeLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfBillingEventVendorChargeLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllVendorChargeForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfBillingEventVendorChargeLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfBillingEventVendorChargeLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfBillingEventVendorChargeLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllBillingEventTypeForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfBillingEventBillingEventTypeLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/BillingEvents/GetAllBillingEventTypeForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBillingEventTypeForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBillingEventTypeForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfBillingEventBillingEventTypeLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfBillingEventBillingEventTypeLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllBillingEventTypeForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfBillingEventBillingEventTypeLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfBillingEventBillingEventTypeLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfBillingEventBillingEventTypeLookupTableDto>(<any>null);
    }
}

@Injectable()
export class BillingEventTypesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetBillingEventTypeForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/BillingEventTypes/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetBillingEventTypeForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetBillingEventTypeForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetBillingEventTypeForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetBillingEventTypeForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetBillingEventTypeForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getBillingEventTypeForView(id: number | null | undefined): Observable<GetBillingEventTypeForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/BillingEventTypes/GetBillingEventTypeForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBillingEventTypeForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBillingEventTypeForView(<any>response_);
                } catch (e) {
                    return <Observable<GetBillingEventTypeForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetBillingEventTypeForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBillingEventTypeForView(response: HttpResponseBase): Observable<GetBillingEventTypeForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetBillingEventTypeForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetBillingEventTypeForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getBillingEventTypeForEdit(id: number | null | undefined): Observable<GetBillingEventTypeForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/BillingEventTypes/GetBillingEventTypeForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBillingEventTypeForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBillingEventTypeForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetBillingEventTypeForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetBillingEventTypeForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetBillingEventTypeForEdit(response: HttpResponseBase): Observable<GetBillingEventTypeForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetBillingEventTypeForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetBillingEventTypeForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditBillingEventTypeDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BillingEventTypes/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BillingEventTypes/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class BillingRulesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param isParentFilter (optional) 
     * @param maxParentBillingRuleRefIdFilter (optional) 
     * @param minParentBillingRuleRefIdFilter (optional) 
     * @param maxChargePerUnitFilter (optional) 
     * @param minChargePerUnitFilter (optional) 
     * @param billingRuleTypeTypeFilter (optional) 
     * @param usageMetricMetricFilter (optional) 
     * @param leaseAgreementTitleFilter (optional) 
     * @param vendorNameFilter (optional) 
     * @param leaseItemItemFilter (optional) 
     * @param currencyCodeFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, nameFilter: string | null | undefined, isParentFilter: number | null | undefined, maxParentBillingRuleRefIdFilter: number | null | undefined, minParentBillingRuleRefIdFilter: number | null | undefined, maxChargePerUnitFilter: number | null | undefined, minChargePerUnitFilter: number | null | undefined, billingRuleTypeTypeFilter: string | null | undefined, usageMetricMetricFilter: string | null | undefined, leaseAgreementTitleFilter: string | null | undefined, vendorNameFilter: string | null | undefined, leaseItemItemFilter: string | null | undefined, currencyCodeFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetBillingRuleForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/BillingRules/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&"; 
        if (isParentFilter !== undefined)
            url_ += "IsParentFilter=" + encodeURIComponent("" + isParentFilter) + "&"; 
        if (maxParentBillingRuleRefIdFilter !== undefined)
            url_ += "MaxParentBillingRuleRefIdFilter=" + encodeURIComponent("" + maxParentBillingRuleRefIdFilter) + "&"; 
        if (minParentBillingRuleRefIdFilter !== undefined)
            url_ += "MinParentBillingRuleRefIdFilter=" + encodeURIComponent("" + minParentBillingRuleRefIdFilter) + "&"; 
        if (maxChargePerUnitFilter !== undefined)
            url_ += "MaxChargePerUnitFilter=" + encodeURIComponent("" + maxChargePerUnitFilter) + "&"; 
        if (minChargePerUnitFilter !== undefined)
            url_ += "MinChargePerUnitFilter=" + encodeURIComponent("" + minChargePerUnitFilter) + "&"; 
        if (billingRuleTypeTypeFilter !== undefined)
            url_ += "BillingRuleTypeTypeFilter=" + encodeURIComponent("" + billingRuleTypeTypeFilter) + "&"; 
        if (usageMetricMetricFilter !== undefined)
            url_ += "UsageMetricMetricFilter=" + encodeURIComponent("" + usageMetricMetricFilter) + "&"; 
        if (leaseAgreementTitleFilter !== undefined)
            url_ += "LeaseAgreementTitleFilter=" + encodeURIComponent("" + leaseAgreementTitleFilter) + "&"; 
        if (vendorNameFilter !== undefined)
            url_ += "VendorNameFilter=" + encodeURIComponent("" + vendorNameFilter) + "&"; 
        if (leaseItemItemFilter !== undefined)
            url_ += "LeaseItemItemFilter=" + encodeURIComponent("" + leaseItemItemFilter) + "&"; 
        if (currencyCodeFilter !== undefined)
            url_ += "CurrencyCodeFilter=" + encodeURIComponent("" + currencyCodeFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetBillingRuleForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetBillingRuleForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetBillingRuleForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetBillingRuleForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetBillingRuleForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getBillingRuleForView(id: number | null | undefined): Observable<GetBillingRuleForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/BillingRules/GetBillingRuleForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBillingRuleForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBillingRuleForView(<any>response_);
                } catch (e) {
                    return <Observable<GetBillingRuleForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetBillingRuleForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBillingRuleForView(response: HttpResponseBase): Observable<GetBillingRuleForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetBillingRuleForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetBillingRuleForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getBillingRuleForEdit(id: number | null | undefined): Observable<GetBillingRuleForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/BillingRules/GetBillingRuleForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBillingRuleForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBillingRuleForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetBillingRuleForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetBillingRuleForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetBillingRuleForEdit(response: HttpResponseBase): Observable<GetBillingRuleForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetBillingRuleForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetBillingRuleForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditBillingRuleDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BillingRules/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BillingRules/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param isParentFilter (optional) 
     * @param maxParentBillingRuleRefIdFilter (optional) 
     * @param minParentBillingRuleRefIdFilter (optional) 
     * @param maxChargePerUnitFilter (optional) 
     * @param minChargePerUnitFilter (optional) 
     * @param billingRuleTypeTypeFilter (optional) 
     * @param usageMetricMetricFilter (optional) 
     * @param leaseAgreementTitleFilter (optional) 
     * @param vendorNameFilter (optional) 
     * @param leaseItemItemFilter (optional) 
     * @param currencyCodeFilter (optional) 
     * @return Success
     */
    getBillingRulesToExcel(filter: string | null | undefined, nameFilter: string | null | undefined, isParentFilter: number | null | undefined, maxParentBillingRuleRefIdFilter: number | null | undefined, minParentBillingRuleRefIdFilter: number | null | undefined, maxChargePerUnitFilter: number | null | undefined, minChargePerUnitFilter: number | null | undefined, billingRuleTypeTypeFilter: string | null | undefined, usageMetricMetricFilter: string | null | undefined, leaseAgreementTitleFilter: string | null | undefined, vendorNameFilter: string | null | undefined, leaseItemItemFilter: string | null | undefined, currencyCodeFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/BillingRules/GetBillingRulesToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&"; 
        if (isParentFilter !== undefined)
            url_ += "IsParentFilter=" + encodeURIComponent("" + isParentFilter) + "&"; 
        if (maxParentBillingRuleRefIdFilter !== undefined)
            url_ += "MaxParentBillingRuleRefIdFilter=" + encodeURIComponent("" + maxParentBillingRuleRefIdFilter) + "&"; 
        if (minParentBillingRuleRefIdFilter !== undefined)
            url_ += "MinParentBillingRuleRefIdFilter=" + encodeURIComponent("" + minParentBillingRuleRefIdFilter) + "&"; 
        if (maxChargePerUnitFilter !== undefined)
            url_ += "MaxChargePerUnitFilter=" + encodeURIComponent("" + maxChargePerUnitFilter) + "&"; 
        if (minChargePerUnitFilter !== undefined)
            url_ += "MinChargePerUnitFilter=" + encodeURIComponent("" + minChargePerUnitFilter) + "&"; 
        if (billingRuleTypeTypeFilter !== undefined)
            url_ += "BillingRuleTypeTypeFilter=" + encodeURIComponent("" + billingRuleTypeTypeFilter) + "&"; 
        if (usageMetricMetricFilter !== undefined)
            url_ += "UsageMetricMetricFilter=" + encodeURIComponent("" + usageMetricMetricFilter) + "&"; 
        if (leaseAgreementTitleFilter !== undefined)
            url_ += "LeaseAgreementTitleFilter=" + encodeURIComponent("" + leaseAgreementTitleFilter) + "&"; 
        if (vendorNameFilter !== undefined)
            url_ += "VendorNameFilter=" + encodeURIComponent("" + vendorNameFilter) + "&"; 
        if (leaseItemItemFilter !== undefined)
            url_ += "LeaseItemItemFilter=" + encodeURIComponent("" + leaseItemItemFilter) + "&"; 
        if (currencyCodeFilter !== undefined)
            url_ += "CurrencyCodeFilter=" + encodeURIComponent("" + currencyCodeFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBillingRulesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBillingRulesToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBillingRulesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllBillingRuleTypeForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfBillingRuleBillingRuleTypeLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/BillingRules/GetAllBillingRuleTypeForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBillingRuleTypeForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBillingRuleTypeForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfBillingRuleBillingRuleTypeLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfBillingRuleBillingRuleTypeLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllBillingRuleTypeForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfBillingRuleBillingRuleTypeLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfBillingRuleBillingRuleTypeLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfBillingRuleBillingRuleTypeLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllUsageMetricForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfBillingRuleUsageMetricLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/BillingRules/GetAllUsageMetricForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUsageMetricForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUsageMetricForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfBillingRuleUsageMetricLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfBillingRuleUsageMetricLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUsageMetricForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfBillingRuleUsageMetricLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfBillingRuleUsageMetricLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfBillingRuleUsageMetricLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllLeaseAgreementForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfBillingRuleLeaseAgreementLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/BillingRules/GetAllLeaseAgreementForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllLeaseAgreementForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllLeaseAgreementForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfBillingRuleLeaseAgreementLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfBillingRuleLeaseAgreementLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllLeaseAgreementForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfBillingRuleLeaseAgreementLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfBillingRuleLeaseAgreementLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfBillingRuleLeaseAgreementLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllVendorForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfBillingRuleVendorLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/BillingRules/GetAllVendorForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllVendorForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllVendorForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfBillingRuleVendorLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfBillingRuleVendorLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllVendorForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfBillingRuleVendorLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfBillingRuleVendorLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfBillingRuleVendorLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllLeaseItemForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfBillingRuleLeaseItemLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/BillingRules/GetAllLeaseItemForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllLeaseItemForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllLeaseItemForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfBillingRuleLeaseItemLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfBillingRuleLeaseItemLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllLeaseItemForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfBillingRuleLeaseItemLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfBillingRuleLeaseItemLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfBillingRuleLeaseItemLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllCurrencyForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfBillingRuleCurrencyLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/BillingRules/GetAllCurrencyForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCurrencyForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCurrencyForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfBillingRuleCurrencyLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfBillingRuleCurrencyLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCurrencyForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfBillingRuleCurrencyLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfBillingRuleCurrencyLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfBillingRuleCurrencyLookupTableDto>(<any>null);
    }
}

@Injectable()
export class BillingRuleTypesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetBillingRuleTypeForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/BillingRuleTypes/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetBillingRuleTypeForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetBillingRuleTypeForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetBillingRuleTypeForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetBillingRuleTypeForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetBillingRuleTypeForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getBillingRuleTypeForView(id: number | null | undefined): Observable<GetBillingRuleTypeForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/BillingRuleTypes/GetBillingRuleTypeForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBillingRuleTypeForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBillingRuleTypeForView(<any>response_);
                } catch (e) {
                    return <Observable<GetBillingRuleTypeForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetBillingRuleTypeForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetBillingRuleTypeForView(response: HttpResponseBase): Observable<GetBillingRuleTypeForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetBillingRuleTypeForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetBillingRuleTypeForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getBillingRuleTypeForEdit(id: number | null | undefined): Observable<GetBillingRuleTypeForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/BillingRuleTypes/GetBillingRuleTypeForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBillingRuleTypeForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBillingRuleTypeForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetBillingRuleTypeForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetBillingRuleTypeForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetBillingRuleTypeForEdit(response: HttpResponseBase): Observable<GetBillingRuleTypeForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetBillingRuleTypeForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetBillingRuleTypeForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditBillingRuleTypeDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BillingRuleTypes/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/BillingRuleTypes/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class CachingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllCaches(): Observable<ListResultDtoOfCacheDto> {
        let url_ = this.baseUrl + "/api/services/app/Caching/GetAllCaches";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCaches(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCaches(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfCacheDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfCacheDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCaches(response: HttpResponseBase): Observable<ListResultDtoOfCacheDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfCacheDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfCacheDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    clearCache(input: EntityDtoOfString | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Caching/ClearCache";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearCache(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearCache(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearCache(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    clearAllCaches(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Caching/ClearAllCaches";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearAllCaches(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearAllCaches(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearAllCaches(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ChatServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getUserChatFriendsWithSettings(): Observable<GetUserChatFriendsWithSettingsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Chat/GetUserChatFriendsWithSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserChatFriendsWithSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserChatFriendsWithSettings(<any>response_);
                } catch (e) {
                    return <Observable<GetUserChatFriendsWithSettingsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserChatFriendsWithSettingsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserChatFriendsWithSettings(response: HttpResponseBase): Observable<GetUserChatFriendsWithSettingsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUserChatFriendsWithSettingsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserChatFriendsWithSettingsOutput>(<any>null);
    }

    /**
     * @param tenantId (optional) 
     * @param userId (optional) 
     * @param minMessageId (optional) 
     * @return Success
     */
    getUserChatMessages(tenantId: number | null | undefined, userId: number | null | undefined, minMessageId: number | null | undefined): Observable<ListResultDtoOfChatMessageDto> {
        let url_ = this.baseUrl + "/api/services/app/Chat/GetUserChatMessages?";
        if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&"; 
        if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&"; 
        if (minMessageId !== undefined)
            url_ += "MinMessageId=" + encodeURIComponent("" + minMessageId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserChatMessages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserChatMessages(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfChatMessageDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfChatMessageDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserChatMessages(response: HttpResponseBase): Observable<ListResultDtoOfChatMessageDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfChatMessageDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfChatMessageDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    markAllUnreadMessagesOfUserAsRead(input: MarkAllUnreadMessagesOfUserAsReadInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Chat/MarkAllUnreadMessagesOfUserAsRead";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMarkAllUnreadMessagesOfUserAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarkAllUnreadMessagesOfUserAsRead(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMarkAllUnreadMessagesOfUserAsRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class CommonLookupServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param onlyFreeItems (optional) 
     * @return Success
     */
    getEditionsForCombobox(onlyFreeItems: boolean | null | undefined): Observable<ListResultDtoOfSubscribableEditionComboboxItemDto> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/GetEditionsForCombobox?";
        if (onlyFreeItems !== undefined)
            url_ += "onlyFreeItems=" + encodeURIComponent("" + onlyFreeItems) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionsForCombobox(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionsForCombobox(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfSubscribableEditionComboboxItemDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfSubscribableEditionComboboxItemDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionsForCombobox(response: HttpResponseBase): Observable<ListResultDtoOfSubscribableEditionComboboxItemDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfSubscribableEditionComboboxItemDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfSubscribableEditionComboboxItemDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    findUsers(input: FindUsersInput | null | undefined): Observable<PagedResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/FindUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processFindUsers(response: HttpResponseBase): Observable<PagedResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfNameValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfNameValueDto>(<any>null);
    }

    /**
     * @return Success
     */
    getDefaultEditionName(): Observable<GetDefaultEditionNameOutput> {
        let url_ = this.baseUrl + "/api/services/app/CommonLookup/GetDefaultEditionName";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDefaultEditionName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDefaultEditionName(<any>response_);
                } catch (e) {
                    return <Observable<GetDefaultEditionNameOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDefaultEditionNameOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDefaultEditionName(response: HttpResponseBase): Observable<GetDefaultEditionNameOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetDefaultEditionNameOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDefaultEditionNameOutput>(<any>null);
    }
}

@Injectable()
export class ConsumableTypesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetConsumableTypeForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ConsumableTypes/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetConsumableTypeForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetConsumableTypeForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetConsumableTypeForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetConsumableTypeForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetConsumableTypeForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getConsumableTypeForView(id: number | null | undefined): Observable<GetConsumableTypeForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ConsumableTypes/GetConsumableTypeForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConsumableTypeForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConsumableTypeForView(<any>response_);
                } catch (e) {
                    return <Observable<GetConsumableTypeForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetConsumableTypeForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetConsumableTypeForView(response: HttpResponseBase): Observable<GetConsumableTypeForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetConsumableTypeForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetConsumableTypeForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getConsumableTypeForEdit(id: number | null | undefined): Observable<GetConsumableTypeForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/ConsumableTypes/GetConsumableTypeForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConsumableTypeForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConsumableTypeForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetConsumableTypeForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetConsumableTypeForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetConsumableTypeForEdit(response: HttpResponseBase): Observable<GetConsumableTypeForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetConsumableTypeForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetConsumableTypeForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditConsumableTypeDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ConsumableTypes/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ConsumableTypes/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ContactsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param headOfficeContactFilter (optional) 
     * @param contactNameFilter (optional) 
     * @param phoneOfficeFilter (optional) 
     * @param phoneMobileFilter (optional) 
     * @param faxFilter (optional) 
     * @param addressFilter (optional) 
     * @param emailAddressFilter (optional) 
     * @param positionFilter (optional) 
     * @param departmentFilter (optional) 
     * @param contactLoc8GUIDFilter (optional) 
     * @param userNameFilter (optional) 
     * @param vendorNameFilter (optional) 
     * @param assetOwnerNameFilter (optional) 
     * @param customerNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, headOfficeContactFilter: number | null | undefined, contactNameFilter: string | null | undefined, phoneOfficeFilter: string | null | undefined, phoneMobileFilter: string | null | undefined, faxFilter: string | null | undefined, addressFilter: string | null | undefined, emailAddressFilter: string | null | undefined, positionFilter: string | null | undefined, departmentFilter: string | null | undefined, contactLoc8GUIDFilter: string | null | undefined, userNameFilter: string | null | undefined, vendorNameFilter: string | null | undefined, assetOwnerNameFilter: string | null | undefined, customerNameFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetContactForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Contacts/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (headOfficeContactFilter !== undefined)
            url_ += "HeadOfficeContactFilter=" + encodeURIComponent("" + headOfficeContactFilter) + "&"; 
        if (contactNameFilter !== undefined)
            url_ += "ContactNameFilter=" + encodeURIComponent("" + contactNameFilter) + "&"; 
        if (phoneOfficeFilter !== undefined)
            url_ += "PhoneOfficeFilter=" + encodeURIComponent("" + phoneOfficeFilter) + "&"; 
        if (phoneMobileFilter !== undefined)
            url_ += "PhoneMobileFilter=" + encodeURIComponent("" + phoneMobileFilter) + "&"; 
        if (faxFilter !== undefined)
            url_ += "FaxFilter=" + encodeURIComponent("" + faxFilter) + "&"; 
        if (addressFilter !== undefined)
            url_ += "AddressFilter=" + encodeURIComponent("" + addressFilter) + "&"; 
        if (emailAddressFilter !== undefined)
            url_ += "EmailAddressFilter=" + encodeURIComponent("" + emailAddressFilter) + "&"; 
        if (positionFilter !== undefined)
            url_ += "PositionFilter=" + encodeURIComponent("" + positionFilter) + "&"; 
        if (departmentFilter !== undefined)
            url_ += "DepartmentFilter=" + encodeURIComponent("" + departmentFilter) + "&"; 
        if (contactLoc8GUIDFilter !== undefined)
            url_ += "ContactLoc8GUIDFilter=" + encodeURIComponent("" + contactLoc8GUIDFilter) + "&"; 
        if (userNameFilter !== undefined)
            url_ += "UserNameFilter=" + encodeURIComponent("" + userNameFilter) + "&"; 
        if (vendorNameFilter !== undefined)
            url_ += "VendorNameFilter=" + encodeURIComponent("" + vendorNameFilter) + "&"; 
        if (assetOwnerNameFilter !== undefined)
            url_ += "AssetOwnerNameFilter=" + encodeURIComponent("" + assetOwnerNameFilter) + "&"; 
        if (customerNameFilter !== undefined)
            url_ += "CustomerNameFilter=" + encodeURIComponent("" + customerNameFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetContactForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetContactForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetContactForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetContactForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetContactForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getContactForView(id: number | null | undefined): Observable<GetContactForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Contacts/GetContactForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactForView(<any>response_);
                } catch (e) {
                    return <Observable<GetContactForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetContactForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetContactForView(response: HttpResponseBase): Observable<GetContactForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetContactForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetContactForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getContactForEdit(id: number | null | undefined): Observable<GetContactForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Contacts/GetContactForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetContactForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetContactForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetContactForEdit(response: HttpResponseBase): Observable<GetContactForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetContactForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetContactForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditContactDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Contacts/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Contacts/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param headOfficeContactFilter (optional) 
     * @param contactNameFilter (optional) 
     * @param phoneOfficeFilter (optional) 
     * @param phoneMobileFilter (optional) 
     * @param faxFilter (optional) 
     * @param addressFilter (optional) 
     * @param emailAddressFilter (optional) 
     * @param positionFilter (optional) 
     * @param departmentFilter (optional) 
     * @param contactLoc8GUIDFilter (optional) 
     * @param userNameFilter (optional) 
     * @param vendorNameFilter (optional) 
     * @param assetOwnerNameFilter (optional) 
     * @param customerNameFilter (optional) 
     * @return Success
     */
    getContactsToExcel(filter: string | null | undefined, headOfficeContactFilter: number | null | undefined, contactNameFilter: string | null | undefined, phoneOfficeFilter: string | null | undefined, phoneMobileFilter: string | null | undefined, faxFilter: string | null | undefined, addressFilter: string | null | undefined, emailAddressFilter: string | null | undefined, positionFilter: string | null | undefined, departmentFilter: string | null | undefined, contactLoc8GUIDFilter: string | null | undefined, userNameFilter: string | null | undefined, vendorNameFilter: string | null | undefined, assetOwnerNameFilter: string | null | undefined, customerNameFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Contacts/GetContactsToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (headOfficeContactFilter !== undefined)
            url_ += "HeadOfficeContactFilter=" + encodeURIComponent("" + headOfficeContactFilter) + "&"; 
        if (contactNameFilter !== undefined)
            url_ += "ContactNameFilter=" + encodeURIComponent("" + contactNameFilter) + "&"; 
        if (phoneOfficeFilter !== undefined)
            url_ += "PhoneOfficeFilter=" + encodeURIComponent("" + phoneOfficeFilter) + "&"; 
        if (phoneMobileFilter !== undefined)
            url_ += "PhoneMobileFilter=" + encodeURIComponent("" + phoneMobileFilter) + "&"; 
        if (faxFilter !== undefined)
            url_ += "FaxFilter=" + encodeURIComponent("" + faxFilter) + "&"; 
        if (addressFilter !== undefined)
            url_ += "AddressFilter=" + encodeURIComponent("" + addressFilter) + "&"; 
        if (emailAddressFilter !== undefined)
            url_ += "EmailAddressFilter=" + encodeURIComponent("" + emailAddressFilter) + "&"; 
        if (positionFilter !== undefined)
            url_ += "PositionFilter=" + encodeURIComponent("" + positionFilter) + "&"; 
        if (departmentFilter !== undefined)
            url_ += "DepartmentFilter=" + encodeURIComponent("" + departmentFilter) + "&"; 
        if (contactLoc8GUIDFilter !== undefined)
            url_ += "ContactLoc8GUIDFilter=" + encodeURIComponent("" + contactLoc8GUIDFilter) + "&"; 
        if (userNameFilter !== undefined)
            url_ += "UserNameFilter=" + encodeURIComponent("" + userNameFilter) + "&"; 
        if (vendorNameFilter !== undefined)
            url_ += "VendorNameFilter=" + encodeURIComponent("" + vendorNameFilter) + "&"; 
        if (assetOwnerNameFilter !== undefined)
            url_ += "AssetOwnerNameFilter=" + encodeURIComponent("" + assetOwnerNameFilter) + "&"; 
        if (customerNameFilter !== undefined)
            url_ += "CustomerNameFilter=" + encodeURIComponent("" + customerNameFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetContactsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetContactsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetContactsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllUserForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfContactUserLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Contacts/GetAllUserForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfContactUserLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfContactUserLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUserForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfContactUserLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfContactUserLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfContactUserLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllVendorForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfContactVendorLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Contacts/GetAllVendorForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllVendorForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllVendorForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfContactVendorLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfContactVendorLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllVendorForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfContactVendorLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfContactVendorLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfContactVendorLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllAssetOwnerForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfContactAssetOwnerLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Contacts/GetAllAssetOwnerForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAssetOwnerForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAssetOwnerForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfContactAssetOwnerLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfContactAssetOwnerLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAssetOwnerForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfContactAssetOwnerLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfContactAssetOwnerLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfContactAssetOwnerLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllCustomerForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfContactCustomerLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Contacts/GetAllCustomerForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCustomerForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCustomerForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfContactCustomerLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfContactCustomerLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCustomerForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfContactCustomerLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfContactCustomerLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfContactCustomerLookupTableDto>(<any>null);
    }
}

@Injectable()
export class CrossTenantPermissionsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param maxTenantRefIdFilter (optional) 
     * @param minTenantRefIdFilter (optional) 
     * @param entityTypeFilter (optional) 
     * @param tenantsFilter (optional) 
     * @param tenantTypeFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, maxTenantRefIdFilter: number | null | undefined, minTenantRefIdFilter: number | null | undefined, entityTypeFilter: string | null | undefined, tenantsFilter: string | null | undefined, tenantTypeFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetCrossTenantPermissionForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/CrossTenantPermissions/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxTenantRefIdFilter !== undefined)
            url_ += "MaxTenantRefIdFilter=" + encodeURIComponent("" + maxTenantRefIdFilter) + "&"; 
        if (minTenantRefIdFilter !== undefined)
            url_ += "MinTenantRefIdFilter=" + encodeURIComponent("" + minTenantRefIdFilter) + "&"; 
        if (entityTypeFilter !== undefined)
            url_ += "EntityTypeFilter=" + encodeURIComponent("" + entityTypeFilter) + "&"; 
        if (tenantsFilter !== undefined)
            url_ += "TenantsFilter=" + encodeURIComponent("" + tenantsFilter) + "&"; 
        if (tenantTypeFilter !== undefined)
            url_ += "TenantTypeFilter=" + encodeURIComponent("" + tenantTypeFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetCrossTenantPermissionForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetCrossTenantPermissionForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetCrossTenantPermissionForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetCrossTenantPermissionForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetCrossTenantPermissionForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getCrossTenantPermissionForView(id: number | null | undefined): Observable<GetCrossTenantPermissionForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/CrossTenantPermissions/GetCrossTenantPermissionForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCrossTenantPermissionForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCrossTenantPermissionForView(<any>response_);
                } catch (e) {
                    return <Observable<GetCrossTenantPermissionForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCrossTenantPermissionForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCrossTenantPermissionForView(response: HttpResponseBase): Observable<GetCrossTenantPermissionForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCrossTenantPermissionForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCrossTenantPermissionForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getCrossTenantPermissionForEdit(id: number | null | undefined): Observable<GetCrossTenantPermissionForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/CrossTenantPermissions/GetCrossTenantPermissionForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCrossTenantPermissionForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCrossTenantPermissionForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetCrossTenantPermissionForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCrossTenantPermissionForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetCrossTenantPermissionForEdit(response: HttpResponseBase): Observable<GetCrossTenantPermissionForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCrossTenantPermissionForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCrossTenantPermissionForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditCrossTenantPermissionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CrossTenantPermissions/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CrossTenantPermissions/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param maxTenantRefIdFilter (optional) 
     * @param minTenantRefIdFilter (optional) 
     * @param entityTypeFilter (optional) 
     * @param tenantsFilter (optional) 
     * @param tenantTypeFilter (optional) 
     * @return Success
     */
    getCrossTenantPermissionsToExcel(filter: string | null | undefined, maxTenantRefIdFilter: number | null | undefined, minTenantRefIdFilter: number | null | undefined, entityTypeFilter: string | null | undefined, tenantsFilter: string | null | undefined, tenantTypeFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/CrossTenantPermissions/GetCrossTenantPermissionsToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxTenantRefIdFilter !== undefined)
            url_ += "MaxTenantRefIdFilter=" + encodeURIComponent("" + maxTenantRefIdFilter) + "&"; 
        if (minTenantRefIdFilter !== undefined)
            url_ += "MinTenantRefIdFilter=" + encodeURIComponent("" + minTenantRefIdFilter) + "&"; 
        if (entityTypeFilter !== undefined)
            url_ += "EntityTypeFilter=" + encodeURIComponent("" + entityTypeFilter) + "&"; 
        if (tenantsFilter !== undefined)
            url_ += "TenantsFilter=" + encodeURIComponent("" + tenantsFilter) + "&"; 
        if (tenantTypeFilter !== undefined)
            url_ += "TenantTypeFilter=" + encodeURIComponent("" + tenantTypeFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCrossTenantPermissionsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCrossTenantPermissionsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCrossTenantPermissionsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class CurrenciesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param codeFilter (optional) 
     * @param nameFilter (optional) 
     * @param symbolFilter (optional) 
     * @param countryFilter (optional) 
     * @param baseCountryFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, codeFilter: string | null | undefined, nameFilter: string | null | undefined, symbolFilter: string | null | undefined, countryFilter: string | null | undefined, baseCountryFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetCurrencyForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Currencies/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (codeFilter !== undefined)
            url_ += "CodeFilter=" + encodeURIComponent("" + codeFilter) + "&"; 
        if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&"; 
        if (symbolFilter !== undefined)
            url_ += "SymbolFilter=" + encodeURIComponent("" + symbolFilter) + "&"; 
        if (countryFilter !== undefined)
            url_ += "CountryFilter=" + encodeURIComponent("" + countryFilter) + "&"; 
        if (baseCountryFilter !== undefined)
            url_ += "BaseCountryFilter=" + encodeURIComponent("" + baseCountryFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetCurrencyForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetCurrencyForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetCurrencyForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetCurrencyForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetCurrencyForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getCurrencyForView(id: number | null | undefined): Observable<GetCurrencyForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Currencies/GetCurrencyForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrencyForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrencyForView(<any>response_);
                } catch (e) {
                    return <Observable<GetCurrencyForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCurrencyForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrencyForView(response: HttpResponseBase): Observable<GetCurrencyForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCurrencyForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCurrencyForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getCurrencyForEdit(id: number | null | undefined): Observable<GetCurrencyForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Currencies/GetCurrencyForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrencyForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrencyForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetCurrencyForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCurrencyForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrencyForEdit(response: HttpResponseBase): Observable<GetCurrencyForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCurrencyForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCurrencyForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditCurrencyDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Currencies/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Currencies/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param codeFilter (optional) 
     * @param nameFilter (optional) 
     * @param symbolFilter (optional) 
     * @param countryFilter (optional) 
     * @param baseCountryFilter (optional) 
     * @return Success
     */
    getCurrenciesToExcel(filter: string | null | undefined, codeFilter: string | null | undefined, nameFilter: string | null | undefined, symbolFilter: string | null | undefined, countryFilter: string | null | undefined, baseCountryFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Currencies/GetCurrenciesToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (codeFilter !== undefined)
            url_ += "CodeFilter=" + encodeURIComponent("" + codeFilter) + "&"; 
        if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&"; 
        if (symbolFilter !== undefined)
            url_ += "SymbolFilter=" + encodeURIComponent("" + symbolFilter) + "&"; 
        if (countryFilter !== undefined)
            url_ += "CountryFilter=" + encodeURIComponent("" + countryFilter) + "&"; 
        if (baseCountryFilter !== undefined)
            url_ += "BaseCountryFilter=" + encodeURIComponent("" + baseCountryFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrenciesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrenciesToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrenciesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @return Success
     */
    getDefaultCurrency(): Observable<GetCurrencyForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Currencies/GetDefaultCurrency";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDefaultCurrency(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDefaultCurrency(<any>response_);
                } catch (e) {
                    return <Observable<GetCurrencyForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCurrencyForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDefaultCurrency(response: HttpResponseBase): Observable<GetCurrencyForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCurrencyForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCurrencyForEditOutput>(<any>null);
    }
}

@Injectable()
export class CustomerGroupMembershipsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param maxDateJoinedFilter (optional) 
     * @param minDateJoinedFilter (optional) 
     * @param maxDateLeftFilter (optional) 
     * @param minDateLeftFilter (optional) 
     * @param customerGroupNameFilter (optional) 
     * @param customerNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, maxDateJoinedFilter: moment.Moment | null | undefined, minDateJoinedFilter: moment.Moment | null | undefined, maxDateLeftFilter: moment.Moment | null | undefined, minDateLeftFilter: moment.Moment | null | undefined, customerGroupNameFilter: string | null | undefined, customerNameFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetCustomerGroupMembershipForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/CustomerGroupMemberships/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxDateJoinedFilter !== undefined)
            url_ += "MaxDateJoinedFilter=" + encodeURIComponent(maxDateJoinedFilter ? "" + maxDateJoinedFilter.toJSON() : "") + "&"; 
        if (minDateJoinedFilter !== undefined)
            url_ += "MinDateJoinedFilter=" + encodeURIComponent(minDateJoinedFilter ? "" + minDateJoinedFilter.toJSON() : "") + "&"; 
        if (maxDateLeftFilter !== undefined)
            url_ += "MaxDateLeftFilter=" + encodeURIComponent(maxDateLeftFilter ? "" + maxDateLeftFilter.toJSON() : "") + "&"; 
        if (minDateLeftFilter !== undefined)
            url_ += "MinDateLeftFilter=" + encodeURIComponent(minDateLeftFilter ? "" + minDateLeftFilter.toJSON() : "") + "&"; 
        if (customerGroupNameFilter !== undefined)
            url_ += "CustomerGroupNameFilter=" + encodeURIComponent("" + customerGroupNameFilter) + "&"; 
        if (customerNameFilter !== undefined)
            url_ += "CustomerNameFilter=" + encodeURIComponent("" + customerNameFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetCustomerGroupMembershipForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetCustomerGroupMembershipForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetCustomerGroupMembershipForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetCustomerGroupMembershipForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetCustomerGroupMembershipForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getCustomerGroupMembershipForView(id: number | null | undefined): Observable<GetCustomerGroupMembershipForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/CustomerGroupMemberships/GetCustomerGroupMembershipForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerGroupMembershipForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerGroupMembershipForView(<any>response_);
                } catch (e) {
                    return <Observable<GetCustomerGroupMembershipForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCustomerGroupMembershipForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCustomerGroupMembershipForView(response: HttpResponseBase): Observable<GetCustomerGroupMembershipForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCustomerGroupMembershipForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCustomerGroupMembershipForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getCustomerGroupMembershipForEdit(id: number | null | undefined): Observable<GetCustomerGroupMembershipForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/CustomerGroupMemberships/GetCustomerGroupMembershipForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerGroupMembershipForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerGroupMembershipForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetCustomerGroupMembershipForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCustomerGroupMembershipForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetCustomerGroupMembershipForEdit(response: HttpResponseBase): Observable<GetCustomerGroupMembershipForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCustomerGroupMembershipForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCustomerGroupMembershipForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditCustomerGroupMembershipDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CustomerGroupMemberships/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CustomerGroupMemberships/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param maxDateJoinedFilter (optional) 
     * @param minDateJoinedFilter (optional) 
     * @param maxDateLeftFilter (optional) 
     * @param minDateLeftFilter (optional) 
     * @param customerGroupNameFilter (optional) 
     * @param customerNameFilter (optional) 
     * @return Success
     */
    getCustomerGroupMembershipsToExcel(filter: string | null | undefined, maxDateJoinedFilter: moment.Moment | null | undefined, minDateJoinedFilter: moment.Moment | null | undefined, maxDateLeftFilter: moment.Moment | null | undefined, minDateLeftFilter: moment.Moment | null | undefined, customerGroupNameFilter: string | null | undefined, customerNameFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/CustomerGroupMemberships/GetCustomerGroupMembershipsToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxDateJoinedFilter !== undefined)
            url_ += "MaxDateJoinedFilter=" + encodeURIComponent(maxDateJoinedFilter ? "" + maxDateJoinedFilter.toJSON() : "") + "&"; 
        if (minDateJoinedFilter !== undefined)
            url_ += "MinDateJoinedFilter=" + encodeURIComponent(minDateJoinedFilter ? "" + minDateJoinedFilter.toJSON() : "") + "&"; 
        if (maxDateLeftFilter !== undefined)
            url_ += "MaxDateLeftFilter=" + encodeURIComponent(maxDateLeftFilter ? "" + maxDateLeftFilter.toJSON() : "") + "&"; 
        if (minDateLeftFilter !== undefined)
            url_ += "MinDateLeftFilter=" + encodeURIComponent(minDateLeftFilter ? "" + minDateLeftFilter.toJSON() : "") + "&"; 
        if (customerGroupNameFilter !== undefined)
            url_ += "CustomerGroupNameFilter=" + encodeURIComponent("" + customerGroupNameFilter) + "&"; 
        if (customerNameFilter !== undefined)
            url_ += "CustomerNameFilter=" + encodeURIComponent("" + customerNameFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerGroupMembershipsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerGroupMembershipsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCustomerGroupMembershipsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllCustomerGroupForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfCustomerGroupMembershipCustomerGroupLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/CustomerGroupMemberships/GetAllCustomerGroupForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCustomerGroupForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCustomerGroupForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCustomerGroupMembershipCustomerGroupLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCustomerGroupMembershipCustomerGroupLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCustomerGroupForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfCustomerGroupMembershipCustomerGroupLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfCustomerGroupMembershipCustomerGroupLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCustomerGroupMembershipCustomerGroupLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllCustomerForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfCustomerGroupMembershipCustomerLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/CustomerGroupMemberships/GetAllCustomerForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCustomerForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCustomerForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCustomerGroupMembershipCustomerLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCustomerGroupMembershipCustomerLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCustomerForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfCustomerGroupMembershipCustomerLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfCustomerGroupMembershipCustomerLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCustomerGroupMembershipCustomerLookupTableDto>(<any>null);
    }
}

@Injectable()
export class CustomerGroupsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetCustomerGroupForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/CustomerGroups/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetCustomerGroupForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetCustomerGroupForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetCustomerGroupForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetCustomerGroupForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetCustomerGroupForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getCustomerGroupForView(id: number | null | undefined): Observable<GetCustomerGroupForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/CustomerGroups/GetCustomerGroupForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerGroupForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerGroupForView(<any>response_);
                } catch (e) {
                    return <Observable<GetCustomerGroupForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCustomerGroupForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCustomerGroupForView(response: HttpResponseBase): Observable<GetCustomerGroupForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCustomerGroupForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCustomerGroupForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getCustomerGroupForEdit(id: number | null | undefined): Observable<GetCustomerGroupForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/CustomerGroups/GetCustomerGroupForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerGroupForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerGroupForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetCustomerGroupForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCustomerGroupForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetCustomerGroupForEdit(response: HttpResponseBase): Observable<GetCustomerGroupForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCustomerGroupForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCustomerGroupForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditCustomerGroupDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CustomerGroups/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CustomerGroups/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class CustomerInvoiceDetailsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param descriptionFilter (optional) 
     * @param maxQuantityFilter (optional) 
     * @param minQuantityFilter (optional) 
     * @param maxUnitPriceFilter (optional) 
     * @param minUnitPriceFilter (optional) 
     * @param maxGrossFilter (optional) 
     * @param minGrossFilter (optional) 
     * @param maxTaxFilter (optional) 
     * @param minTaxFilter (optional) 
     * @param maxNetFilter (optional) 
     * @param minNetFilter (optional) 
     * @param maxDiscountFilter (optional) 
     * @param minDiscountFilter (optional) 
     * @param maxChargeFilter (optional) 
     * @param minChargeFilter (optional) 
     * @param maxBillingRuleRefIdFilter (optional) 
     * @param minBillingRuleRefIdFilter (optional) 
     * @param leaseItemItemFilter (optional) 
     * @param customerInvoiceDescriptionFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, descriptionFilter: string | null | undefined, maxQuantityFilter: number | null | undefined, minQuantityFilter: number | null | undefined, maxUnitPriceFilter: number | null | undefined, minUnitPriceFilter: number | null | undefined, maxGrossFilter: number | null | undefined, minGrossFilter: number | null | undefined, maxTaxFilter: number | null | undefined, minTaxFilter: number | null | undefined, maxNetFilter: number | null | undefined, minNetFilter: number | null | undefined, maxDiscountFilter: number | null | undefined, minDiscountFilter: number | null | undefined, maxChargeFilter: number | null | undefined, minChargeFilter: number | null | undefined, maxBillingRuleRefIdFilter: number | null | undefined, minBillingRuleRefIdFilter: number | null | undefined, leaseItemItemFilter: string | null | undefined, customerInvoiceDescriptionFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetCustomerInvoiceDetailForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/CustomerInvoiceDetails/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (maxQuantityFilter !== undefined)
            url_ += "MaxQuantityFilter=" + encodeURIComponent("" + maxQuantityFilter) + "&"; 
        if (minQuantityFilter !== undefined)
            url_ += "MinQuantityFilter=" + encodeURIComponent("" + minQuantityFilter) + "&"; 
        if (maxUnitPriceFilter !== undefined)
            url_ += "MaxUnitPriceFilter=" + encodeURIComponent("" + maxUnitPriceFilter) + "&"; 
        if (minUnitPriceFilter !== undefined)
            url_ += "MinUnitPriceFilter=" + encodeURIComponent("" + minUnitPriceFilter) + "&"; 
        if (maxGrossFilter !== undefined)
            url_ += "MaxGrossFilter=" + encodeURIComponent("" + maxGrossFilter) + "&"; 
        if (minGrossFilter !== undefined)
            url_ += "MinGrossFilter=" + encodeURIComponent("" + minGrossFilter) + "&"; 
        if (maxTaxFilter !== undefined)
            url_ += "MaxTaxFilter=" + encodeURIComponent("" + maxTaxFilter) + "&"; 
        if (minTaxFilter !== undefined)
            url_ += "MinTaxFilter=" + encodeURIComponent("" + minTaxFilter) + "&"; 
        if (maxNetFilter !== undefined)
            url_ += "MaxNetFilter=" + encodeURIComponent("" + maxNetFilter) + "&"; 
        if (minNetFilter !== undefined)
            url_ += "MinNetFilter=" + encodeURIComponent("" + minNetFilter) + "&"; 
        if (maxDiscountFilter !== undefined)
            url_ += "MaxDiscountFilter=" + encodeURIComponent("" + maxDiscountFilter) + "&"; 
        if (minDiscountFilter !== undefined)
            url_ += "MinDiscountFilter=" + encodeURIComponent("" + minDiscountFilter) + "&"; 
        if (maxChargeFilter !== undefined)
            url_ += "MaxChargeFilter=" + encodeURIComponent("" + maxChargeFilter) + "&"; 
        if (minChargeFilter !== undefined)
            url_ += "MinChargeFilter=" + encodeURIComponent("" + minChargeFilter) + "&"; 
        if (maxBillingRuleRefIdFilter !== undefined)
            url_ += "MaxBillingRuleRefIdFilter=" + encodeURIComponent("" + maxBillingRuleRefIdFilter) + "&"; 
        if (minBillingRuleRefIdFilter !== undefined)
            url_ += "MinBillingRuleRefIdFilter=" + encodeURIComponent("" + minBillingRuleRefIdFilter) + "&"; 
        if (leaseItemItemFilter !== undefined)
            url_ += "LeaseItemItemFilter=" + encodeURIComponent("" + leaseItemItemFilter) + "&"; 
        if (customerInvoiceDescriptionFilter !== undefined)
            url_ += "CustomerInvoiceDescriptionFilter=" + encodeURIComponent("" + customerInvoiceDescriptionFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetCustomerInvoiceDetailForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetCustomerInvoiceDetailForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetCustomerInvoiceDetailForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetCustomerInvoiceDetailForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetCustomerInvoiceDetailForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getCustomerInvoiceDetailForView(id: number | null | undefined): Observable<GetCustomerInvoiceDetailForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/CustomerInvoiceDetails/GetCustomerInvoiceDetailForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerInvoiceDetailForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerInvoiceDetailForView(<any>response_);
                } catch (e) {
                    return <Observable<GetCustomerInvoiceDetailForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCustomerInvoiceDetailForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCustomerInvoiceDetailForView(response: HttpResponseBase): Observable<GetCustomerInvoiceDetailForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCustomerInvoiceDetailForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCustomerInvoiceDetailForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getCustomerInvoiceDetailForEdit(id: number | null | undefined): Observable<GetCustomerInvoiceDetailForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/CustomerInvoiceDetails/GetCustomerInvoiceDetailForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerInvoiceDetailForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerInvoiceDetailForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetCustomerInvoiceDetailForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCustomerInvoiceDetailForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetCustomerInvoiceDetailForEdit(response: HttpResponseBase): Observable<GetCustomerInvoiceDetailForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCustomerInvoiceDetailForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCustomerInvoiceDetailForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditCustomerInvoiceDetailDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CustomerInvoiceDetails/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CustomerInvoiceDetails/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllCustomerInvoiceForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfCustomerInvoiceDetailCustomerInvoiceLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/CustomerInvoiceDetails/GetAllCustomerInvoiceForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCustomerInvoiceForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCustomerInvoiceForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCustomerInvoiceDetailCustomerInvoiceLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCustomerInvoiceDetailCustomerInvoiceLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCustomerInvoiceForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfCustomerInvoiceDetailCustomerInvoiceLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfCustomerInvoiceDetailCustomerInvoiceLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCustomerInvoiceDetailCustomerInvoiceLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllLeaseItemForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfCustomerInvoiceLeaseItemLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/CustomerInvoiceDetails/GetAllLeaseItemForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllLeaseItemForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllLeaseItemForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCustomerInvoiceLeaseItemLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCustomerInvoiceLeaseItemLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllLeaseItemForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfCustomerInvoiceLeaseItemLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfCustomerInvoiceLeaseItemLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCustomerInvoiceLeaseItemLookupTableDto>(<any>null);
    }
}

@Injectable()
export class CustomerInvoicesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param customerReferenceFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param maxDateIssuedFilter (optional) 
     * @param minDateIssuedFilter (optional) 
     * @param maxDateDueFilter (optional) 
     * @param minDateDueFilter (optional) 
     * @param maxTotalTaxFilter (optional) 
     * @param minTotalTaxFilter (optional) 
     * @param maxTotalPriceFilter (optional) 
     * @param minTotalPriceFilter (optional) 
     * @param maxTotalNetFilter (optional) 
     * @param minTotalNetFilter (optional) 
     * @param maxTotalDiscountFilter (optional) 
     * @param minTotalDiscountFilter (optional) 
     * @param maxTotalChargeFilter (optional) 
     * @param minTotalChargeFilter (optional) 
     * @param invoiceRecipientFilter (optional) 
     * @param remarksFilter (optional) 
     * @param customerNameFilter (optional) 
     * @param workOrderSubjectFilter (optional) 
     * @param estimateTitleFilter (optional) 
     * @param currencyCodeFilter (optional) 
     * @param billingRuleNameFilter (optional) 
     * @param billingEventPurposeFilter (optional) 
     * @param invoiceStatusStatusFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, customerReferenceFilter: string | null | undefined, descriptionFilter: string | null | undefined, maxDateIssuedFilter: moment.Moment | null | undefined, minDateIssuedFilter: moment.Moment | null | undefined, maxDateDueFilter: moment.Moment | null | undefined, minDateDueFilter: moment.Moment | null | undefined, maxTotalTaxFilter: number | null | undefined, minTotalTaxFilter: number | null | undefined, maxTotalPriceFilter: number | null | undefined, minTotalPriceFilter: number | null | undefined, maxTotalNetFilter: number | null | undefined, minTotalNetFilter: number | null | undefined, maxTotalDiscountFilter: number | null | undefined, minTotalDiscountFilter: number | null | undefined, maxTotalChargeFilter: number | null | undefined, minTotalChargeFilter: number | null | undefined, invoiceRecipientFilter: string | null | undefined, remarksFilter: string | null | undefined, customerNameFilter: string | null | undefined, workOrderSubjectFilter: string | null | undefined, estimateTitleFilter: string | null | undefined, currencyCodeFilter: string | null | undefined, billingRuleNameFilter: string | null | undefined, billingEventPurposeFilter: string | null | undefined, invoiceStatusStatusFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetCustomerInvoiceForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/CustomerInvoices/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (customerReferenceFilter !== undefined)
            url_ += "CustomerReferenceFilter=" + encodeURIComponent("" + customerReferenceFilter) + "&"; 
        if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (maxDateIssuedFilter !== undefined)
            url_ += "MaxDateIssuedFilter=" + encodeURIComponent(maxDateIssuedFilter ? "" + maxDateIssuedFilter.toJSON() : "") + "&"; 
        if (minDateIssuedFilter !== undefined)
            url_ += "MinDateIssuedFilter=" + encodeURIComponent(minDateIssuedFilter ? "" + minDateIssuedFilter.toJSON() : "") + "&"; 
        if (maxDateDueFilter !== undefined)
            url_ += "MaxDateDueFilter=" + encodeURIComponent(maxDateDueFilter ? "" + maxDateDueFilter.toJSON() : "") + "&"; 
        if (minDateDueFilter !== undefined)
            url_ += "MinDateDueFilter=" + encodeURIComponent(minDateDueFilter ? "" + minDateDueFilter.toJSON() : "") + "&"; 
        if (maxTotalTaxFilter !== undefined)
            url_ += "MaxTotalTaxFilter=" + encodeURIComponent("" + maxTotalTaxFilter) + "&"; 
        if (minTotalTaxFilter !== undefined)
            url_ += "MinTotalTaxFilter=" + encodeURIComponent("" + minTotalTaxFilter) + "&"; 
        if (maxTotalPriceFilter !== undefined)
            url_ += "MaxTotalPriceFilter=" + encodeURIComponent("" + maxTotalPriceFilter) + "&"; 
        if (minTotalPriceFilter !== undefined)
            url_ += "MinTotalPriceFilter=" + encodeURIComponent("" + minTotalPriceFilter) + "&"; 
        if (maxTotalNetFilter !== undefined)
            url_ += "MaxTotalNetFilter=" + encodeURIComponent("" + maxTotalNetFilter) + "&"; 
        if (minTotalNetFilter !== undefined)
            url_ += "MinTotalNetFilter=" + encodeURIComponent("" + minTotalNetFilter) + "&"; 
        if (maxTotalDiscountFilter !== undefined)
            url_ += "MaxTotalDiscountFilter=" + encodeURIComponent("" + maxTotalDiscountFilter) + "&"; 
        if (minTotalDiscountFilter !== undefined)
            url_ += "MinTotalDiscountFilter=" + encodeURIComponent("" + minTotalDiscountFilter) + "&"; 
        if (maxTotalChargeFilter !== undefined)
            url_ += "MaxTotalChargeFilter=" + encodeURIComponent("" + maxTotalChargeFilter) + "&"; 
        if (minTotalChargeFilter !== undefined)
            url_ += "MinTotalChargeFilter=" + encodeURIComponent("" + minTotalChargeFilter) + "&"; 
        if (invoiceRecipientFilter !== undefined)
            url_ += "InvoiceRecipientFilter=" + encodeURIComponent("" + invoiceRecipientFilter) + "&"; 
        if (remarksFilter !== undefined)
            url_ += "RemarksFilter=" + encodeURIComponent("" + remarksFilter) + "&"; 
        if (customerNameFilter !== undefined)
            url_ += "CustomerNameFilter=" + encodeURIComponent("" + customerNameFilter) + "&"; 
        if (workOrderSubjectFilter !== undefined)
            url_ += "WorkOrderSubjectFilter=" + encodeURIComponent("" + workOrderSubjectFilter) + "&"; 
        if (estimateTitleFilter !== undefined)
            url_ += "EstimateTitleFilter=" + encodeURIComponent("" + estimateTitleFilter) + "&"; 
        if (currencyCodeFilter !== undefined)
            url_ += "CurrencyCodeFilter=" + encodeURIComponent("" + currencyCodeFilter) + "&"; 
        if (billingRuleNameFilter !== undefined)
            url_ += "BillingRuleNameFilter=" + encodeURIComponent("" + billingRuleNameFilter) + "&"; 
        if (billingEventPurposeFilter !== undefined)
            url_ += "BillingEventPurposeFilter=" + encodeURIComponent("" + billingEventPurposeFilter) + "&"; 
        if (invoiceStatusStatusFilter !== undefined)
            url_ += "InvoiceStatusStatusFilter=" + encodeURIComponent("" + invoiceStatusStatusFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetCustomerInvoiceForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetCustomerInvoiceForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetCustomerInvoiceForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetCustomerInvoiceForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetCustomerInvoiceForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @param sorting (optional) 
     * @return Success
     */
    getCustomerInvoiceForView(id: number | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined, sorting: string | null | undefined): Observable<GetCustomerInvoiceForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/CustomerInvoices/GetCustomerInvoiceForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerInvoiceForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerInvoiceForView(<any>response_);
                } catch (e) {
                    return <Observable<GetCustomerInvoiceForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCustomerInvoiceForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCustomerInvoiceForView(response: HttpResponseBase): Observable<GetCustomerInvoiceForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCustomerInvoiceForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCustomerInvoiceForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getCustomerInvoiceForEdit(id: number | null | undefined): Observable<GetCustomerInvoiceForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/CustomerInvoices/GetCustomerInvoiceForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerInvoiceForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerInvoiceForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetCustomerInvoiceForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCustomerInvoiceForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetCustomerInvoiceForEdit(response: HttpResponseBase): Observable<GetCustomerInvoiceForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCustomerInvoiceForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCustomerInvoiceForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditCustomerInvoiceDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CustomerInvoices/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CustomerInvoices/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param customerReferenceFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param maxDateIssuedFilter (optional) 
     * @param minDateIssuedFilter (optional) 
     * @param maxDateDueFilter (optional) 
     * @param minDateDueFilter (optional) 
     * @param maxTotalTaxFilter (optional) 
     * @param minTotalTaxFilter (optional) 
     * @param maxTotalPriceFilter (optional) 
     * @param minTotalPriceFilter (optional) 
     * @param maxTotalNetFilter (optional) 
     * @param minTotalNetFilter (optional) 
     * @param maxTotalDiscountFilter (optional) 
     * @param minTotalDiscountFilter (optional) 
     * @param maxTotalChargeFilter (optional) 
     * @param minTotalChargeFilter (optional) 
     * @param invoiceRecipientFilter (optional) 
     * @param remarksFilter (optional) 
     * @param customerNameFilter (optional) 
     * @param workOrderSubjectFilter (optional) 
     * @param estimateTitleFilter (optional) 
     * @param currencyCodeFilter (optional) 
     * @param billingRuleNameFilter (optional) 
     * @param billingEventPurposeFilter (optional) 
     * @param invoiceStatusStatusFilter (optional) 
     * @return Success
     */
    getCustomerInvoicesToExcel(filter: string | null | undefined, customerReferenceFilter: string | null | undefined, descriptionFilter: string | null | undefined, maxDateIssuedFilter: moment.Moment | null | undefined, minDateIssuedFilter: moment.Moment | null | undefined, maxDateDueFilter: moment.Moment | null | undefined, minDateDueFilter: moment.Moment | null | undefined, maxTotalTaxFilter: number | null | undefined, minTotalTaxFilter: number | null | undefined, maxTotalPriceFilter: number | null | undefined, minTotalPriceFilter: number | null | undefined, maxTotalNetFilter: number | null | undefined, minTotalNetFilter: number | null | undefined, maxTotalDiscountFilter: number | null | undefined, minTotalDiscountFilter: number | null | undefined, maxTotalChargeFilter: number | null | undefined, minTotalChargeFilter: number | null | undefined, invoiceRecipientFilter: string | null | undefined, remarksFilter: string | null | undefined, customerNameFilter: string | null | undefined, workOrderSubjectFilter: string | null | undefined, estimateTitleFilter: string | null | undefined, currencyCodeFilter: string | null | undefined, billingRuleNameFilter: string | null | undefined, billingEventPurposeFilter: string | null | undefined, invoiceStatusStatusFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/CustomerInvoices/GetCustomerInvoicesToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (customerReferenceFilter !== undefined)
            url_ += "CustomerReferenceFilter=" + encodeURIComponent("" + customerReferenceFilter) + "&"; 
        if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (maxDateIssuedFilter !== undefined)
            url_ += "MaxDateIssuedFilter=" + encodeURIComponent(maxDateIssuedFilter ? "" + maxDateIssuedFilter.toJSON() : "") + "&"; 
        if (minDateIssuedFilter !== undefined)
            url_ += "MinDateIssuedFilter=" + encodeURIComponent(minDateIssuedFilter ? "" + minDateIssuedFilter.toJSON() : "") + "&"; 
        if (maxDateDueFilter !== undefined)
            url_ += "MaxDateDueFilter=" + encodeURIComponent(maxDateDueFilter ? "" + maxDateDueFilter.toJSON() : "") + "&"; 
        if (minDateDueFilter !== undefined)
            url_ += "MinDateDueFilter=" + encodeURIComponent(minDateDueFilter ? "" + minDateDueFilter.toJSON() : "") + "&"; 
        if (maxTotalTaxFilter !== undefined)
            url_ += "MaxTotalTaxFilter=" + encodeURIComponent("" + maxTotalTaxFilter) + "&"; 
        if (minTotalTaxFilter !== undefined)
            url_ += "MinTotalTaxFilter=" + encodeURIComponent("" + minTotalTaxFilter) + "&"; 
        if (maxTotalPriceFilter !== undefined)
            url_ += "MaxTotalPriceFilter=" + encodeURIComponent("" + maxTotalPriceFilter) + "&"; 
        if (minTotalPriceFilter !== undefined)
            url_ += "MinTotalPriceFilter=" + encodeURIComponent("" + minTotalPriceFilter) + "&"; 
        if (maxTotalNetFilter !== undefined)
            url_ += "MaxTotalNetFilter=" + encodeURIComponent("" + maxTotalNetFilter) + "&"; 
        if (minTotalNetFilter !== undefined)
            url_ += "MinTotalNetFilter=" + encodeURIComponent("" + minTotalNetFilter) + "&"; 
        if (maxTotalDiscountFilter !== undefined)
            url_ += "MaxTotalDiscountFilter=" + encodeURIComponent("" + maxTotalDiscountFilter) + "&"; 
        if (minTotalDiscountFilter !== undefined)
            url_ += "MinTotalDiscountFilter=" + encodeURIComponent("" + minTotalDiscountFilter) + "&"; 
        if (maxTotalChargeFilter !== undefined)
            url_ += "MaxTotalChargeFilter=" + encodeURIComponent("" + maxTotalChargeFilter) + "&"; 
        if (minTotalChargeFilter !== undefined)
            url_ += "MinTotalChargeFilter=" + encodeURIComponent("" + minTotalChargeFilter) + "&"; 
        if (invoiceRecipientFilter !== undefined)
            url_ += "InvoiceRecipientFilter=" + encodeURIComponent("" + invoiceRecipientFilter) + "&"; 
        if (remarksFilter !== undefined)
            url_ += "RemarksFilter=" + encodeURIComponent("" + remarksFilter) + "&"; 
        if (customerNameFilter !== undefined)
            url_ += "CustomerNameFilter=" + encodeURIComponent("" + customerNameFilter) + "&"; 
        if (workOrderSubjectFilter !== undefined)
            url_ += "WorkOrderSubjectFilter=" + encodeURIComponent("" + workOrderSubjectFilter) + "&"; 
        if (estimateTitleFilter !== undefined)
            url_ += "EstimateTitleFilter=" + encodeURIComponent("" + estimateTitleFilter) + "&"; 
        if (currencyCodeFilter !== undefined)
            url_ += "CurrencyCodeFilter=" + encodeURIComponent("" + currencyCodeFilter) + "&"; 
        if (billingRuleNameFilter !== undefined)
            url_ += "BillingRuleNameFilter=" + encodeURIComponent("" + billingRuleNameFilter) + "&"; 
        if (billingEventPurposeFilter !== undefined)
            url_ += "BillingEventPurposeFilter=" + encodeURIComponent("" + billingEventPurposeFilter) + "&"; 
        if (invoiceStatusStatusFilter !== undefined)
            url_ += "InvoiceStatusStatusFilter=" + encodeURIComponent("" + invoiceStatusStatusFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerInvoicesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerInvoicesToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCustomerInvoicesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param customerInvoiceId (optional) 
     * @return Success
     */
    updateCustomerInvoicePrices(customerInvoiceId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CustomerInvoices/UpdateCustomerInvoicePrices?";
        if (customerInvoiceId !== undefined)
            url_ += "customerInvoiceId=" + encodeURIComponent("" + customerInvoiceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCustomerInvoicePrices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCustomerInvoicePrices(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCustomerInvoicePrices(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getCustomerInvoiceForPDF(id: number | null | undefined): Observable<GetCustomerInvoiceForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/CustomerInvoices/GetCustomerInvoiceForPDF?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerInvoiceForPDF(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerInvoiceForPDF(<any>response_);
                } catch (e) {
                    return <Observable<GetCustomerInvoiceForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCustomerInvoiceForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCustomerInvoiceForPDF(response: HttpResponseBase): Observable<GetCustomerInvoiceForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCustomerInvoiceForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCustomerInvoiceForViewDto>(<any>null);
    }

    /**
     * @param code (optional) 
     * @param state (optional) 
     * @return Success
     */
    getCallback(code: string | null | undefined, state: string | null | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/services/app/CustomerInvoices/GetCallback?";
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        if (state !== undefined)
            url_ += "state=" + encodeURIComponent("" + state) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCallback(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCallback(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processGetCallback(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * @return Success
     */
    checkIfUserXeroLoggedIn(): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/CustomerInvoices/CheckIfUserXeroLoggedIn";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckIfUserXeroLoggedIn(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckIfUserXeroLoggedIn(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processCheckIfUserXeroLoggedIn(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param flag (optional) 
     * @return Success
     */
    xeroCommunication(id: number | null | undefined, flag: string | null | undefined): Observable<XeroResponse> {
        let url_ = this.baseUrl + "/api/services/app/CustomerInvoices/XeroCommunication?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (flag !== undefined)
            url_ += "flag=" + encodeURIComponent("" + flag) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processXeroCommunication(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processXeroCommunication(<any>response_);
                } catch (e) {
                    return <Observable<XeroResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<XeroResponse>><any>_observableThrow(response_);
        }));
    }

    protected processXeroCommunication(response: HttpResponseBase): Observable<XeroResponse> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = XeroResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<XeroResponse>(<any>null);
    }

    /**
     * @return Success
     */
    refereshXeroInvoices(): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/CustomerInvoices/RefereshXeroInvoices";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefereshXeroInvoices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefereshXeroInvoices(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processRefereshXeroInvoices(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param estimateId (optional) 
     * @param workOrderId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllCustomerForLookupTable(filter: string | null | undefined, estimateId: number | null | undefined, workOrderId: number | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfCustomerInvoiceCustomerLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/CustomerInvoices/GetAllCustomerForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (estimateId !== undefined)
            url_ += "EstimateId=" + encodeURIComponent("" + estimateId) + "&"; 
        if (workOrderId !== undefined)
            url_ += "WorkOrderId=" + encodeURIComponent("" + workOrderId) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCustomerForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCustomerForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCustomerInvoiceCustomerLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCustomerInvoiceCustomerLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCustomerForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfCustomerInvoiceCustomerLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfCustomerInvoiceCustomerLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCustomerInvoiceCustomerLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllCurrencyForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfCustomerInvoiceCurrencyLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/CustomerInvoices/GetAllCurrencyForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCurrencyForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCurrencyForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCustomerInvoiceCurrencyLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCustomerInvoiceCurrencyLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCurrencyForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfCustomerInvoiceCurrencyLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfCustomerInvoiceCurrencyLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCustomerInvoiceCurrencyLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllBillingRuleForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfCustomerInvoiceBillingRuleLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/CustomerInvoices/GetAllBillingRuleForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBillingRuleForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBillingRuleForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCustomerInvoiceBillingRuleLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCustomerInvoiceBillingRuleLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllBillingRuleForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfCustomerInvoiceBillingRuleLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfCustomerInvoiceBillingRuleLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCustomerInvoiceBillingRuleLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllBillingEventForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfCustomerInvoiceBillingEventLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/CustomerInvoices/GetAllBillingEventForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllBillingEventForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllBillingEventForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCustomerInvoiceBillingEventLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCustomerInvoiceBillingEventLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllBillingEventForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfCustomerInvoiceBillingEventLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfCustomerInvoiceBillingEventLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCustomerInvoiceBillingEventLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllInvoiceStatusForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfCustomerInvoiceInvoiceStatusLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/CustomerInvoices/GetAllInvoiceStatusForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllInvoiceStatusForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllInvoiceStatusForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCustomerInvoiceInvoiceStatusLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCustomerInvoiceInvoiceStatusLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllInvoiceStatusForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfCustomerInvoiceInvoiceStatusLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfCustomerInvoiceInvoiceStatusLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCustomerInvoiceInvoiceStatusLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllWorkOrderForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfCustomerInvoiceWorkOrderLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/CustomerInvoices/GetAllWorkOrderForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWorkOrderForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWorkOrderForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCustomerInvoiceWorkOrderLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCustomerInvoiceWorkOrderLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllWorkOrderForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfCustomerInvoiceWorkOrderLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfCustomerInvoiceWorkOrderLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCustomerInvoiceWorkOrderLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param filterId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllEstimateForLookupTable(filter: string | null | undefined, filterId: number | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfCustomerInvoiceEstimateLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/CustomerInvoices/GetAllEstimateForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (filterId !== undefined)
            url_ += "FilterId=" + encodeURIComponent("" + filterId) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllEstimateForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllEstimateForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCustomerInvoiceEstimateLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCustomerInvoiceEstimateLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllEstimateForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfCustomerInvoiceEstimateLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfCustomerInvoiceEstimateLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCustomerInvoiceEstimateLookupTableDto>(<any>null);
    }

    /**
     * @param workOrderId (optional) 
     * @return Success
     */
    getWorkOrderFkData(workOrderId: number | null | undefined): Observable<CustomerInvoiceWorkOrderFkListDto> {
        let url_ = this.baseUrl + "/api/services/app/CustomerInvoices/GetWorkOrderFkData?";
        if (workOrderId !== undefined)
            url_ += "workOrderId=" + encodeURIComponent("" + workOrderId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWorkOrderFkData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWorkOrderFkData(<any>response_);
                } catch (e) {
                    return <Observable<CustomerInvoiceWorkOrderFkListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CustomerInvoiceWorkOrderFkListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWorkOrderFkData(response: HttpResponseBase): Observable<CustomerInvoiceWorkOrderFkListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerInvoiceWorkOrderFkListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustomerInvoiceWorkOrderFkListDto>(<any>null);
    }

    /**
     * @param estimateId (optional) 
     * @return Success
     */
    getEstimateFkData(estimateId: number | null | undefined): Observable<CustomerInvoiceEstimateFkListDto> {
        let url_ = this.baseUrl + "/api/services/app/CustomerInvoices/GetEstimateFkData?";
        if (estimateId !== undefined)
            url_ += "estimateId=" + encodeURIComponent("" + estimateId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEstimateFkData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEstimateFkData(<any>response_);
                } catch (e) {
                    return <Observable<CustomerInvoiceEstimateFkListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CustomerInvoiceEstimateFkListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEstimateFkData(response: HttpResponseBase): Observable<CustomerInvoiceEstimateFkListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerInvoiceEstimateFkListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustomerInvoiceEstimateFkListDto>(<any>null);
    }

    /**
     * @param customerInvoiceId (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @param sorting (optional) 
     * @return Success
     */
    getCustomerInvoiceEstimateForView(customerInvoiceId: number | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined, sorting: string | null | undefined): Observable<GetCustomerInvoiceEstimateForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/CustomerInvoices/GetCustomerInvoiceEstimateForView?";
        if (customerInvoiceId !== undefined)
            url_ += "customerInvoiceId=" + encodeURIComponent("" + customerInvoiceId) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerInvoiceEstimateForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerInvoiceEstimateForView(<any>response_);
                } catch (e) {
                    return <Observable<GetCustomerInvoiceEstimateForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCustomerInvoiceEstimateForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCustomerInvoiceEstimateForView(response: HttpResponseBase): Observable<GetCustomerInvoiceEstimateForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCustomerInvoiceEstimateForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCustomerInvoiceEstimateForViewDto>(<any>null);
    }

    /**
     * @param customerInvoiceId (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @param sorting (optional) 
     * @return Success
     */
    getCustomerInvoiceWorkOrderForView(customerInvoiceId: number | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined, sorting: string | null | undefined): Observable<GetCustomerInvoiceWorkOrderForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/CustomerInvoices/GetCustomerInvoiceWorkOrderForView?";
        if (customerInvoiceId !== undefined)
            url_ += "customerInvoiceId=" + encodeURIComponent("" + customerInvoiceId) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerInvoiceWorkOrderForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerInvoiceWorkOrderForView(<any>response_);
                } catch (e) {
                    return <Observable<GetCustomerInvoiceWorkOrderForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCustomerInvoiceWorkOrderForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCustomerInvoiceWorkOrderForView(response: HttpResponseBase): Observable<GetCustomerInvoiceWorkOrderForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCustomerInvoiceWorkOrderForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCustomerInvoiceWorkOrderForViewDto>(<any>null);
    }

    /**
     * @param customerInvoiceId (optional) 
     * @return Success
     */
    getCustomerInvoiceWorkOrderForClone(customerInvoiceId: number | null | undefined): Observable<GetCustomerInvoiceWorkOrderForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/CustomerInvoices/GetCustomerInvoiceWorkOrderForClone?";
        if (customerInvoiceId !== undefined)
            url_ += "customerInvoiceId=" + encodeURIComponent("" + customerInvoiceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerInvoiceWorkOrderForClone(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerInvoiceWorkOrderForClone(<any>response_);
                } catch (e) {
                    return <Observable<GetCustomerInvoiceWorkOrderForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCustomerInvoiceWorkOrderForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCustomerInvoiceWorkOrderForClone(response: HttpResponseBase): Observable<GetCustomerInvoiceWorkOrderForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCustomerInvoiceWorkOrderForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCustomerInvoiceWorkOrderForViewDto>(<any>null);
    }
}

@Injectable()
export class CustomerInvoiceStatusesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param statusFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, statusFilter: string | null | undefined, descriptionFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetCustomerInvoiceStatusForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/CustomerInvoiceStatuses/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (statusFilter !== undefined)
            url_ += "StatusFilter=" + encodeURIComponent("" + statusFilter) + "&"; 
        if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetCustomerInvoiceStatusForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetCustomerInvoiceStatusForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetCustomerInvoiceStatusForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetCustomerInvoiceStatusForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetCustomerInvoiceStatusForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getCustomerInvoiceStatusForView(id: number | null | undefined): Observable<GetCustomerInvoiceStatusForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/CustomerInvoiceStatuses/GetCustomerInvoiceStatusForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerInvoiceStatusForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerInvoiceStatusForView(<any>response_);
                } catch (e) {
                    return <Observable<GetCustomerInvoiceStatusForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCustomerInvoiceStatusForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCustomerInvoiceStatusForView(response: HttpResponseBase): Observable<GetCustomerInvoiceStatusForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCustomerInvoiceStatusForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCustomerInvoiceStatusForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getCustomerInvoiceStatusForEdit(id: number | null | undefined): Observable<GetCustomerInvoiceStatusForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/CustomerInvoiceStatuses/GetCustomerInvoiceStatusForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerInvoiceStatusForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerInvoiceStatusForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetCustomerInvoiceStatusForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCustomerInvoiceStatusForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetCustomerInvoiceStatusForEdit(response: HttpResponseBase): Observable<GetCustomerInvoiceStatusForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCustomerInvoiceStatusForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCustomerInvoiceStatusForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditCustomerInvoiceStatusDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CustomerInvoiceStatuses/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CustomerInvoiceStatuses/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class CustomersServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param referenceFilter (optional) 
     * @param nameFilter (optional) 
     * @param identifierFilter (optional) 
     * @param paymentTermTypeFilter (optional) 
     * @param paymentTermNumberFilter (optional) 
     * @param customerLoc8UUIDFilter (optional) 
     * @param customerTypeTypeFilter (optional) 
     * @param currencyCodeFilter (optional) 
     * @param xeroCustomerFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, referenceFilter: string | null | undefined, nameFilter: string | null | undefined, identifierFilter: string | null | undefined, paymentTermTypeFilter: string | null | undefined, paymentTermNumberFilter: number | null | undefined, customerLoc8UUIDFilter: string | null | undefined, customerTypeTypeFilter: string | null | undefined, currencyCodeFilter: string | null | undefined, xeroCustomerFilter: number | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetCustomerForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Customers/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (referenceFilter !== undefined)
            url_ += "ReferenceFilter=" + encodeURIComponent("" + referenceFilter) + "&"; 
        if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&"; 
        if (identifierFilter !== undefined)
            url_ += "IdentifierFilter=" + encodeURIComponent("" + identifierFilter) + "&"; 
        if (paymentTermTypeFilter !== undefined)
            url_ += "PaymentTermTypeFilter=" + encodeURIComponent("" + paymentTermTypeFilter) + "&"; 
        if (paymentTermNumberFilter !== undefined)
            url_ += "PaymentTermNumberFilter=" + encodeURIComponent("" + paymentTermNumberFilter) + "&"; 
        if (customerLoc8UUIDFilter !== undefined)
            url_ += "CustomerLoc8UUIDFilter=" + encodeURIComponent("" + customerLoc8UUIDFilter) + "&"; 
        if (customerTypeTypeFilter !== undefined)
            url_ += "CustomerTypeTypeFilter=" + encodeURIComponent("" + customerTypeTypeFilter) + "&"; 
        if (currencyCodeFilter !== undefined)
            url_ += "CurrencyCodeFilter=" + encodeURIComponent("" + currencyCodeFilter) + "&"; 
        if (xeroCustomerFilter !== undefined)
            url_ += "XeroCustomerFilter=" + encodeURIComponent("" + xeroCustomerFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetCustomerForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetCustomerForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetCustomerForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetCustomerForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetCustomerForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getCustomerForView(id: number | null | undefined): Observable<GetCustomerForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Customers/GetCustomerForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerForView(<any>response_);
                } catch (e) {
                    return <Observable<GetCustomerForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCustomerForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCustomerForView(response: HttpResponseBase): Observable<GetCustomerForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCustomerForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCustomerForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getCustomerForEdit(id: number | null | undefined): Observable<GetCustomerForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Customers/GetCustomerForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetCustomerForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCustomerForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetCustomerForEdit(response: HttpResponseBase): Observable<GetCustomerForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCustomerForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCustomerForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditCustomerDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Customers/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Customers/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param referenceFilter (optional) 
     * @param nameFilter (optional) 
     * @param identifierFilter (optional) 
     * @param customerLoc8UUIDFilter (optional) 
     * @param paymentTermTypeFilter (optional) 
     * @param paymentTermNumberFilter (optional) 
     * @param customerTypeTypeFilter (optional) 
     * @param currencyCodeFilter (optional) 
     * @param xeroCustomerFilter (optional) 
     * @return Success
     */
    getCustomersToExcel(filter: string | null | undefined, referenceFilter: string | null | undefined, nameFilter: string | null | undefined, identifierFilter: string | null | undefined, customerLoc8UUIDFilter: string | null | undefined, paymentTermTypeFilter: string | null | undefined, paymentTermNumberFilter: number | null | undefined, customerTypeTypeFilter: string | null | undefined, currencyCodeFilter: string | null | undefined, xeroCustomerFilter: number | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Customers/GetCustomersToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (referenceFilter !== undefined)
            url_ += "ReferenceFilter=" + encodeURIComponent("" + referenceFilter) + "&"; 
        if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&"; 
        if (identifierFilter !== undefined)
            url_ += "IdentifierFilter=" + encodeURIComponent("" + identifierFilter) + "&"; 
        if (customerLoc8UUIDFilter !== undefined)
            url_ += "CustomerLoc8UUIDFilter=" + encodeURIComponent("" + customerLoc8UUIDFilter) + "&"; 
        if (paymentTermTypeFilter !== undefined)
            url_ += "PaymentTermTypeFilter=" + encodeURIComponent("" + paymentTermTypeFilter) + "&"; 
        if (paymentTermNumberFilter !== undefined)
            url_ += "PaymentTermNumberFilter=" + encodeURIComponent("" + paymentTermNumberFilter) + "&"; 
        if (customerTypeTypeFilter !== undefined)
            url_ += "CustomerTypeTypeFilter=" + encodeURIComponent("" + customerTypeTypeFilter) + "&"; 
        if (currencyCodeFilter !== undefined)
            url_ += "CurrencyCodeFilter=" + encodeURIComponent("" + currencyCodeFilter) + "&"; 
        if (xeroCustomerFilter !== undefined)
            url_ += "XeroCustomerFilter=" + encodeURIComponent("" + xeroCustomerFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomersToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomersToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCustomersToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @return Success
     */
    getDefaultCurrency(): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Customers/GetDefaultCurrency";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDefaultCurrency(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDefaultCurrency(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetDefaultCurrency(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllCustomerTypeForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfCustomerCustomerTypeLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Customers/GetAllCustomerTypeForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCustomerTypeForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCustomerTypeForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCustomerCustomerTypeLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCustomerCustomerTypeLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCustomerTypeForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfCustomerCustomerTypeLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfCustomerCustomerTypeLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCustomerCustomerTypeLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllCurrencyForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfCustomerCurrencyLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Customers/GetAllCurrencyForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCurrencyForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCurrencyForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCustomerCurrencyLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCustomerCurrencyLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCurrencyForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfCustomerCurrencyLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfCustomerCurrencyLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCustomerCurrencyLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllPaymentTermsTypeForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfCustomerPaymentTermsTypeLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Customers/GetAllPaymentTermsTypeForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPaymentTermsTypeForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPaymentTermsTypeForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfCustomerPaymentTermsTypeLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfCustomerPaymentTermsTypeLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPaymentTermsTypeForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfCustomerPaymentTermsTypeLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfCustomerPaymentTermsTypeLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfCustomerPaymentTermsTypeLookupTableDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getCustomerPaymentDue(id: number | null | undefined): Observable<CustomerForCustomerInvoiceEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Customers/GetCustomerPaymentDue?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerPaymentDue(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerPaymentDue(<any>response_);
                } catch (e) {
                    return <Observable<CustomerForCustomerInvoiceEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CustomerForCustomerInvoiceEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCustomerPaymentDue(response: HttpResponseBase): Observable<CustomerForCustomerInvoiceEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CustomerForCustomerInvoiceEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CustomerForCustomerInvoiceEditDto>(<any>null);
    }

    /**
     * @return Success
     */
    checkIfUserXeroLoggedIn(): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Customers/CheckIfUserXeroLoggedIn";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckIfUserXeroLoggedIn(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckIfUserXeroLoggedIn(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processCheckIfUserXeroLoggedIn(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @return Success
     */
    syncXeroCustomers(): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Customers/SyncXeroCustomers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSyncXeroCustomers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSyncXeroCustomers(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processSyncXeroCustomers(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

@Injectable()
export class CustomerTypesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetCustomerTypeForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/CustomerTypes/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetCustomerTypeForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetCustomerTypeForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetCustomerTypeForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetCustomerTypeForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetCustomerTypeForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getCustomerTypeForView(id: number | null | undefined): Observable<GetCustomerTypeForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/CustomerTypes/GetCustomerTypeForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerTypeForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerTypeForView(<any>response_);
                } catch (e) {
                    return <Observable<GetCustomerTypeForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCustomerTypeForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCustomerTypeForView(response: HttpResponseBase): Observable<GetCustomerTypeForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCustomerTypeForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCustomerTypeForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getCustomerTypeForEdit(id: number | null | undefined): Observable<GetCustomerTypeForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/CustomerTypes/GetCustomerTypeForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerTypeForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerTypeForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetCustomerTypeForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCustomerTypeForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetCustomerTypeForEdit(response: HttpResponseBase): Observable<GetCustomerTypeForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCustomerTypeForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCustomerTypeForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditCustomerTypeDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CustomerTypes/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/CustomerTypes/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class DemoUiComponentsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param date (optional) 
     * @return Success
     */
    sendAndGetDate(date: moment.Moment | null | undefined): Observable<DateToStringOutput> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetDate?";
        if (date !== undefined)
            url_ += "date=" + encodeURIComponent(date ? "" + date.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetDate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetDate(<any>response_);
                } catch (e) {
                    return <Observable<DateToStringOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<DateToStringOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSendAndGetDate(response: HttpResponseBase): Observable<DateToStringOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DateToStringOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DateToStringOutput>(<any>null);
    }

    /**
     * @param date (optional) 
     * @return Success
     */
    sendAndGetDateTime(date: moment.Moment | null | undefined): Observable<DateToStringOutput> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetDateTime?";
        if (date !== undefined)
            url_ += "date=" + encodeURIComponent(date ? "" + date.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetDateTime(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetDateTime(<any>response_);
                } catch (e) {
                    return <Observable<DateToStringOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<DateToStringOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSendAndGetDateTime(response: HttpResponseBase): Observable<DateToStringOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DateToStringOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DateToStringOutput>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    sendAndGetDateRange(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined): Observable<DateToStringOutput> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetDateRange?";
        if (startDate !== undefined)
            url_ += "startDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "endDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetDateRange(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetDateRange(<any>response_);
                } catch (e) {
                    return <Observable<DateToStringOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<DateToStringOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSendAndGetDateRange(response: HttpResponseBase): Observable<DateToStringOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DateToStringOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DateToStringOutput>(<any>null);
    }

    /**
     * @param searchTerm (optional) 
     * @return Success
     */
    getCountries(searchTerm: string | null | undefined): Observable<NameValueOfString[]> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/GetCountries?";
        if (searchTerm !== undefined)
            url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCountries(<any>response_);
                } catch (e) {
                    return <Observable<NameValueOfString[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueOfString[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCountries(response: HttpResponseBase): Observable<NameValueOfString[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameValueOfString.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueOfString[]>(<any>null);
    }

    /**
     * @param selectedCountries (optional) 
     * @return Success
     */
    sendAndGetSelectedCountries(selectedCountries: NameValueOfString[] | null | undefined): Observable<NameValueOfString[]> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetSelectedCountries";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(selectedCountries);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetSelectedCountries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetSelectedCountries(<any>response_);
                } catch (e) {
                    return <Observable<NameValueOfString[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NameValueOfString[]>><any>_observableThrow(response_);
        }));
    }

    protected processSendAndGetSelectedCountries(response: HttpResponseBase): Observable<NameValueOfString[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NameValueOfString.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NameValueOfString[]>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    sendAndGetValue(input: string | null | undefined): Observable<StringOutput> {
        let url_ = this.baseUrl + "/api/services/app/DemoUiComponents/SendAndGetValue?";
        if (input !== undefined)
            url_ += "input=" + encodeURIComponent("" + input) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendAndGetValue(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendAndGetValue(<any>response_);
                } catch (e) {
                    return <Observable<StringOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<StringOutput>><any>_observableThrow(response_);
        }));
    }

    protected processSendAndGetValue(response: HttpResponseBase): Observable<StringOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StringOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StringOutput>(<any>null);
    }
}

@Injectable()
export class EditionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getEditions(): Observable<ListResultDtoOfEditionListDto> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetEditions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditions(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfEditionListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfEditionListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditions(response: HttpResponseBase): Observable<ListResultDtoOfEditionListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfEditionListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfEditionListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getEditionForEdit(id: number | null | undefined): Observable<GetEditionEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetEditionForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetEditionEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetEditionEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionForEdit(response: HttpResponseBase): Observable<GetEditionEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetEditionEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetEditionEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createEdition(input: CreateEditionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Edition/CreateEdition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateEdition(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateEdition(input: UpdateEditionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Edition/UpdateEdition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateEdition(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteEdition(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Edition/DeleteEdition?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteEdition(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    moveTenantsToAnotherEdition(input: MoveTenantsToAnotherEditionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Edition/MoveTenantsToAnotherEdition";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMoveTenantsToAnotherEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMoveTenantsToAnotherEdition(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMoveTenantsToAnotherEdition(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param selectedEditionId (optional) 
     * @param addAllItem (optional) 
     * @param onlyFreeItems (optional) 
     * @return Success
     */
    getEditionComboboxItems(selectedEditionId: number | null | undefined, addAllItem: boolean | null | undefined, onlyFreeItems: boolean | null | undefined): Observable<SubscribableEditionComboboxItemDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetEditionComboboxItems?";
        if (selectedEditionId !== undefined)
            url_ += "selectedEditionId=" + encodeURIComponent("" + selectedEditionId) + "&"; 
        if (addAllItem !== undefined)
            url_ += "addAllItem=" + encodeURIComponent("" + addAllItem) + "&"; 
        if (onlyFreeItems !== undefined)
            url_ += "onlyFreeItems=" + encodeURIComponent("" + onlyFreeItems) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionComboboxItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionComboboxItems(<any>response_);
                } catch (e) {
                    return <Observable<SubscribableEditionComboboxItemDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubscribableEditionComboboxItemDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionComboboxItems(response: HttpResponseBase): Observable<SubscribableEditionComboboxItemDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(SubscribableEditionComboboxItemDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubscribableEditionComboboxItemDto[]>(<any>null);
    }

    /**
     * @param editionId (optional) 
     * @return Success
     */
    getTenantCount(editionId: number | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Edition/GetTenantCount?";
        if (editionId !== undefined)
            url_ += "editionId=" + encodeURIComponent("" + editionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantCount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantCount(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenantCount(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }
}

@Injectable()
export class EstimateDetailsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param estimateId (optional) 
     * @param filter (optional) 
     * @param itemTypeTypeFilter (optional) 
     * @param estimateTitleFilter (optional) 
     * @param uomUnitOfMeasurementFilter (optional) 
     * @param actionWorkOrderActionFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(estimateId: number | null | undefined, filter: string | null | undefined, itemTypeTypeFilter: string | null | undefined, estimateTitleFilter: string | null | undefined, uomUnitOfMeasurementFilter: string | null | undefined, actionWorkOrderActionFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetEstimateDetailForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/EstimateDetails/GetAll?";
        if (estimateId !== undefined)
            url_ += "EstimateId=" + encodeURIComponent("" + estimateId) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (itemTypeTypeFilter !== undefined)
            url_ += "ItemTypeTypeFilter=" + encodeURIComponent("" + itemTypeTypeFilter) + "&"; 
        if (estimateTitleFilter !== undefined)
            url_ += "EstimateTitleFilter=" + encodeURIComponent("" + estimateTitleFilter) + "&"; 
        if (uomUnitOfMeasurementFilter !== undefined)
            url_ += "UomUnitOfMeasurementFilter=" + encodeURIComponent("" + uomUnitOfMeasurementFilter) + "&"; 
        if (actionWorkOrderActionFilter !== undefined)
            url_ += "ActionWorkOrderActionFilter=" + encodeURIComponent("" + actionWorkOrderActionFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetEstimateDetailForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetEstimateDetailForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetEstimateDetailForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetEstimateDetailForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetEstimateDetailForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getEstimateDetailForView(id: number | null | undefined): Observable<GetEstimateDetailForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/EstimateDetails/GetEstimateDetailForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEstimateDetailForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEstimateDetailForView(<any>response_);
                } catch (e) {
                    return <Observable<GetEstimateDetailForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetEstimateDetailForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEstimateDetailForView(response: HttpResponseBase): Observable<GetEstimateDetailForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetEstimateDetailForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetEstimateDetailForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getEstimateDetailForEdit(id: number | null | undefined): Observable<GetEstimateDetailForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/EstimateDetails/GetEstimateDetailForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEstimateDetailForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEstimateDetailForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetEstimateDetailForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetEstimateDetailForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetEstimateDetailForEdit(response: HttpResponseBase): Observable<GetEstimateDetailForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetEstimateDetailForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetEstimateDetailForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditEstimateDetailDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/EstimateDetails/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/EstimateDetails/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class EstimatesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param referenceFilter (optional) 
     * @param titleFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param maxStartDateFilter (optional) 
     * @param minStartDateFilter (optional) 
     * @param maxEndDateFilter (optional) 
     * @param minEndDateFilter (optional) 
     * @param maxTotalTaxFilter (optional) 
     * @param minTotalTaxFilter (optional) 
     * @param maxTotalPriceFilter (optional) 
     * @param minTotalPriceFilter (optional) 
     * @param maxTotalDiscountFilter (optional) 
     * @param minTotalDiscountFilter (optional) 
     * @param maxTotalChargeFilter (optional) 
     * @param minTotalChargeFilter (optional) 
     * @param maxVersionFilter (optional) 
     * @param minVersionFilter (optional) 
     * @param remarkFilter (optional) 
     * @param maxRequoteRefIdFilter (optional) 
     * @param minRequoteRefIdFilter (optional) 
     * @param quotationLoc8GUIDFilter (optional) 
     * @param maxAcknowledgedByFilter (optional) 
     * @param minAcknowledgedByFilter (optional) 
     * @param maxAcknowledgedAtFilter (optional) 
     * @param minAcknowledgedAtFilter (optional) 
     * @param customerNameFilter (optional) 
     * @param workOrderSubjectFilter (optional) 
     * @param quotationTitleFilter (optional) 
     * @param estimateStatusStatusFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, referenceFilter: string | null | undefined, titleFilter: string | null | undefined, descriptionFilter: string | null | undefined, maxStartDateFilter: moment.Moment | null | undefined, minStartDateFilter: moment.Moment | null | undefined, maxEndDateFilter: moment.Moment | null | undefined, minEndDateFilter: moment.Moment | null | undefined, maxTotalTaxFilter: number | null | undefined, minTotalTaxFilter: number | null | undefined, maxTotalPriceFilter: number | null | undefined, minTotalPriceFilter: number | null | undefined, maxTotalDiscountFilter: number | null | undefined, minTotalDiscountFilter: number | null | undefined, maxTotalChargeFilter: number | null | undefined, minTotalChargeFilter: number | null | undefined, maxVersionFilter: number | null | undefined, minVersionFilter: number | null | undefined, remarkFilter: string | null | undefined, maxRequoteRefIdFilter: number | null | undefined, minRequoteRefIdFilter: number | null | undefined, quotationLoc8GUIDFilter: string | null | undefined, maxAcknowledgedByFilter: number | null | undefined, minAcknowledgedByFilter: number | null | undefined, maxAcknowledgedAtFilter: moment.Moment | null | undefined, minAcknowledgedAtFilter: moment.Moment | null | undefined, customerNameFilter: string | null | undefined, workOrderSubjectFilter: string | null | undefined, quotationTitleFilter: string | null | undefined, estimateStatusStatusFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetEstimateForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Estimates/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (referenceFilter !== undefined)
            url_ += "ReferenceFilter=" + encodeURIComponent("" + referenceFilter) + "&"; 
        if (titleFilter !== undefined)
            url_ += "TitleFilter=" + encodeURIComponent("" + titleFilter) + "&"; 
        if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (maxStartDateFilter !== undefined)
            url_ += "MaxStartDateFilter=" + encodeURIComponent(maxStartDateFilter ? "" + maxStartDateFilter.toJSON() : "") + "&"; 
        if (minStartDateFilter !== undefined)
            url_ += "MinStartDateFilter=" + encodeURIComponent(minStartDateFilter ? "" + minStartDateFilter.toJSON() : "") + "&"; 
        if (maxEndDateFilter !== undefined)
            url_ += "MaxEndDateFilter=" + encodeURIComponent(maxEndDateFilter ? "" + maxEndDateFilter.toJSON() : "") + "&"; 
        if (minEndDateFilter !== undefined)
            url_ += "MinEndDateFilter=" + encodeURIComponent(minEndDateFilter ? "" + minEndDateFilter.toJSON() : "") + "&"; 
        if (maxTotalTaxFilter !== undefined)
            url_ += "MaxTotalTaxFilter=" + encodeURIComponent("" + maxTotalTaxFilter) + "&"; 
        if (minTotalTaxFilter !== undefined)
            url_ += "MinTotalTaxFilter=" + encodeURIComponent("" + minTotalTaxFilter) + "&"; 
        if (maxTotalPriceFilter !== undefined)
            url_ += "MaxTotalPriceFilter=" + encodeURIComponent("" + maxTotalPriceFilter) + "&"; 
        if (minTotalPriceFilter !== undefined)
            url_ += "MinTotalPriceFilter=" + encodeURIComponent("" + minTotalPriceFilter) + "&"; 
        if (maxTotalDiscountFilter !== undefined)
            url_ += "MaxTotalDiscountFilter=" + encodeURIComponent("" + maxTotalDiscountFilter) + "&"; 
        if (minTotalDiscountFilter !== undefined)
            url_ += "MinTotalDiscountFilter=" + encodeURIComponent("" + minTotalDiscountFilter) + "&"; 
        if (maxTotalChargeFilter !== undefined)
            url_ += "MaxTotalChargeFilter=" + encodeURIComponent("" + maxTotalChargeFilter) + "&"; 
        if (minTotalChargeFilter !== undefined)
            url_ += "MinTotalChargeFilter=" + encodeURIComponent("" + minTotalChargeFilter) + "&"; 
        if (maxVersionFilter !== undefined)
            url_ += "MaxVersionFilter=" + encodeURIComponent("" + maxVersionFilter) + "&"; 
        if (minVersionFilter !== undefined)
            url_ += "MinVersionFilter=" + encodeURIComponent("" + minVersionFilter) + "&"; 
        if (remarkFilter !== undefined)
            url_ += "RemarkFilter=" + encodeURIComponent("" + remarkFilter) + "&"; 
        if (maxRequoteRefIdFilter !== undefined)
            url_ += "MaxRequoteRefIdFilter=" + encodeURIComponent("" + maxRequoteRefIdFilter) + "&"; 
        if (minRequoteRefIdFilter !== undefined)
            url_ += "MinRequoteRefIdFilter=" + encodeURIComponent("" + minRequoteRefIdFilter) + "&"; 
        if (quotationLoc8GUIDFilter !== undefined)
            url_ += "QuotationLoc8GUIDFilter=" + encodeURIComponent("" + quotationLoc8GUIDFilter) + "&"; 
        if (maxAcknowledgedByFilter !== undefined)
            url_ += "MaxAcknowledgedByFilter=" + encodeURIComponent("" + maxAcknowledgedByFilter) + "&"; 
        if (minAcknowledgedByFilter !== undefined)
            url_ += "MinAcknowledgedByFilter=" + encodeURIComponent("" + minAcknowledgedByFilter) + "&"; 
        if (maxAcknowledgedAtFilter !== undefined)
            url_ += "MaxAcknowledgedAtFilter=" + encodeURIComponent(maxAcknowledgedAtFilter ? "" + maxAcknowledgedAtFilter.toJSON() : "") + "&"; 
        if (minAcknowledgedAtFilter !== undefined)
            url_ += "MinAcknowledgedAtFilter=" + encodeURIComponent(minAcknowledgedAtFilter ? "" + minAcknowledgedAtFilter.toJSON() : "") + "&"; 
        if (customerNameFilter !== undefined)
            url_ += "CustomerNameFilter=" + encodeURIComponent("" + customerNameFilter) + "&"; 
        if (workOrderSubjectFilter !== undefined)
            url_ += "WorkOrderSubjectFilter=" + encodeURIComponent("" + workOrderSubjectFilter) + "&"; 
        if (quotationTitleFilter !== undefined)
            url_ += "QuotationTitleFilter=" + encodeURIComponent("" + quotationTitleFilter) + "&"; 
        if (estimateStatusStatusFilter !== undefined)
            url_ += "EstimateStatusStatusFilter=" + encodeURIComponent("" + estimateStatusStatusFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetEstimateForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetEstimateForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetEstimateForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetEstimateForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetEstimateForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getEstimateForView(id: number | null | undefined): Observable<GetEstimateForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Estimates/GetEstimateForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEstimateForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEstimateForView(<any>response_);
                } catch (e) {
                    return <Observable<GetEstimateForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetEstimateForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEstimateForView(response: HttpResponseBase): Observable<GetEstimateForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetEstimateForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetEstimateForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getEstimateForEdit(id: number | null | undefined): Observable<GetEstimateForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Estimates/GetEstimateForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEstimateForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEstimateForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetEstimateForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetEstimateForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetEstimateForEdit(response: HttpResponseBase): Observable<GetEstimateForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetEstimateForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetEstimateForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditEstimateDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Estimates/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Estimates/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param referenceFilter (optional) 
     * @param titleFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param maxStartDateFilter (optional) 
     * @param minStartDateFilter (optional) 
     * @param maxEndDateFilter (optional) 
     * @param minEndDateFilter (optional) 
     * @param maxTotalTaxFilter (optional) 
     * @param minTotalTaxFilter (optional) 
     * @param maxTotalPriceFilter (optional) 
     * @param minTotalPriceFilter (optional) 
     * @param maxTotalDiscountFilter (optional) 
     * @param minTotalDiscountFilter (optional) 
     * @param maxTotalChargeFilter (optional) 
     * @param minTotalChargeFilter (optional) 
     * @param maxVersionFilter (optional) 
     * @param minVersionFilter (optional) 
     * @param remarkFilter (optional) 
     * @param maxRequoteRefIdFilter (optional) 
     * @param minRequoteRefIdFilter (optional) 
     * @param quotationLoc8GUIDFilter (optional) 
     * @param maxAcknowledgedByFilter (optional) 
     * @param minAcknowledgedByFilter (optional) 
     * @param maxAcknowledgedAtFilter (optional) 
     * @param minAcknowledgedAtFilter (optional) 
     * @param customerNameFilter (optional) 
     * @param workOrderSubjectFilter (optional) 
     * @param quotationTitleFilter (optional) 
     * @param estimateStatusStatusFilter (optional) 
     * @return Success
     */
    getEstimatesToExcel(filter: string | null | undefined, referenceFilter: string | null | undefined, titleFilter: string | null | undefined, descriptionFilter: string | null | undefined, maxStartDateFilter: moment.Moment | null | undefined, minStartDateFilter: moment.Moment | null | undefined, maxEndDateFilter: moment.Moment | null | undefined, minEndDateFilter: moment.Moment | null | undefined, maxTotalTaxFilter: number | null | undefined, minTotalTaxFilter: number | null | undefined, maxTotalPriceFilter: number | null | undefined, minTotalPriceFilter: number | null | undefined, maxTotalDiscountFilter: number | null | undefined, minTotalDiscountFilter: number | null | undefined, maxTotalChargeFilter: number | null | undefined, minTotalChargeFilter: number | null | undefined, maxVersionFilter: number | null | undefined, minVersionFilter: number | null | undefined, remarkFilter: string | null | undefined, maxRequoteRefIdFilter: number | null | undefined, minRequoteRefIdFilter: number | null | undefined, quotationLoc8GUIDFilter: string | null | undefined, maxAcknowledgedByFilter: number | null | undefined, minAcknowledgedByFilter: number | null | undefined, maxAcknowledgedAtFilter: moment.Moment | null | undefined, minAcknowledgedAtFilter: moment.Moment | null | undefined, customerNameFilter: string | null | undefined, workOrderSubjectFilter: string | null | undefined, quotationTitleFilter: string | null | undefined, estimateStatusStatusFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Estimates/GetEstimatesToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (referenceFilter !== undefined)
            url_ += "ReferenceFilter=" + encodeURIComponent("" + referenceFilter) + "&"; 
        if (titleFilter !== undefined)
            url_ += "TitleFilter=" + encodeURIComponent("" + titleFilter) + "&"; 
        if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (maxStartDateFilter !== undefined)
            url_ += "MaxStartDateFilter=" + encodeURIComponent(maxStartDateFilter ? "" + maxStartDateFilter.toJSON() : "") + "&"; 
        if (minStartDateFilter !== undefined)
            url_ += "MinStartDateFilter=" + encodeURIComponent(minStartDateFilter ? "" + minStartDateFilter.toJSON() : "") + "&"; 
        if (maxEndDateFilter !== undefined)
            url_ += "MaxEndDateFilter=" + encodeURIComponent(maxEndDateFilter ? "" + maxEndDateFilter.toJSON() : "") + "&"; 
        if (minEndDateFilter !== undefined)
            url_ += "MinEndDateFilter=" + encodeURIComponent(minEndDateFilter ? "" + minEndDateFilter.toJSON() : "") + "&"; 
        if (maxTotalTaxFilter !== undefined)
            url_ += "MaxTotalTaxFilter=" + encodeURIComponent("" + maxTotalTaxFilter) + "&"; 
        if (minTotalTaxFilter !== undefined)
            url_ += "MinTotalTaxFilter=" + encodeURIComponent("" + minTotalTaxFilter) + "&"; 
        if (maxTotalPriceFilter !== undefined)
            url_ += "MaxTotalPriceFilter=" + encodeURIComponent("" + maxTotalPriceFilter) + "&"; 
        if (minTotalPriceFilter !== undefined)
            url_ += "MinTotalPriceFilter=" + encodeURIComponent("" + minTotalPriceFilter) + "&"; 
        if (maxTotalDiscountFilter !== undefined)
            url_ += "MaxTotalDiscountFilter=" + encodeURIComponent("" + maxTotalDiscountFilter) + "&"; 
        if (minTotalDiscountFilter !== undefined)
            url_ += "MinTotalDiscountFilter=" + encodeURIComponent("" + minTotalDiscountFilter) + "&"; 
        if (maxTotalChargeFilter !== undefined)
            url_ += "MaxTotalChargeFilter=" + encodeURIComponent("" + maxTotalChargeFilter) + "&"; 
        if (minTotalChargeFilter !== undefined)
            url_ += "MinTotalChargeFilter=" + encodeURIComponent("" + minTotalChargeFilter) + "&"; 
        if (maxVersionFilter !== undefined)
            url_ += "MaxVersionFilter=" + encodeURIComponent("" + maxVersionFilter) + "&"; 
        if (minVersionFilter !== undefined)
            url_ += "MinVersionFilter=" + encodeURIComponent("" + minVersionFilter) + "&"; 
        if (remarkFilter !== undefined)
            url_ += "RemarkFilter=" + encodeURIComponent("" + remarkFilter) + "&"; 
        if (maxRequoteRefIdFilter !== undefined)
            url_ += "MaxRequoteRefIdFilter=" + encodeURIComponent("" + maxRequoteRefIdFilter) + "&"; 
        if (minRequoteRefIdFilter !== undefined)
            url_ += "MinRequoteRefIdFilter=" + encodeURIComponent("" + minRequoteRefIdFilter) + "&"; 
        if (quotationLoc8GUIDFilter !== undefined)
            url_ += "QuotationLoc8GUIDFilter=" + encodeURIComponent("" + quotationLoc8GUIDFilter) + "&"; 
        if (maxAcknowledgedByFilter !== undefined)
            url_ += "MaxAcknowledgedByFilter=" + encodeURIComponent("" + maxAcknowledgedByFilter) + "&"; 
        if (minAcknowledgedByFilter !== undefined)
            url_ += "MinAcknowledgedByFilter=" + encodeURIComponent("" + minAcknowledgedByFilter) + "&"; 
        if (maxAcknowledgedAtFilter !== undefined)
            url_ += "MaxAcknowledgedAtFilter=" + encodeURIComponent(maxAcknowledgedAtFilter ? "" + maxAcknowledgedAtFilter.toJSON() : "") + "&"; 
        if (minAcknowledgedAtFilter !== undefined)
            url_ += "MinAcknowledgedAtFilter=" + encodeURIComponent(minAcknowledgedAtFilter ? "" + minAcknowledgedAtFilter.toJSON() : "") + "&"; 
        if (customerNameFilter !== undefined)
            url_ += "CustomerNameFilter=" + encodeURIComponent("" + customerNameFilter) + "&"; 
        if (workOrderSubjectFilter !== undefined)
            url_ += "WorkOrderSubjectFilter=" + encodeURIComponent("" + workOrderSubjectFilter) + "&"; 
        if (quotationTitleFilter !== undefined)
            url_ += "QuotationTitleFilter=" + encodeURIComponent("" + quotationTitleFilter) + "&"; 
        if (estimateStatusStatusFilter !== undefined)
            url_ += "EstimateStatusStatusFilter=" + encodeURIComponent("" + estimateStatusStatusFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEstimatesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEstimatesToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEstimatesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param estimateId (optional) 
     * @return Success
     */
    updateEstimatePrices(estimateId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Estimates/UpdateEstimatePrices?";
        if (estimateId !== undefined)
            url_ += "estimateId=" + encodeURIComponent("" + estimateId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateEstimatePrices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateEstimatePrices(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateEstimatePrices(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllWorkOrderForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfEstimateWorkOrderLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Estimates/GetAllWorkOrderForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWorkOrderForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWorkOrderForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfEstimateWorkOrderLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfEstimateWorkOrderLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllWorkOrderForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfEstimateWorkOrderLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfEstimateWorkOrderLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfEstimateWorkOrderLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param filterId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllQuotationForLookupTable(filter: string | null | undefined, filterId: number | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfEstimateQuotationLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Estimates/GetAllQuotationForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (filterId !== undefined)
            url_ += "FilterId=" + encodeURIComponent("" + filterId) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllQuotationForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllQuotationForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfEstimateQuotationLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfEstimateQuotationLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllQuotationForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfEstimateQuotationLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfEstimateQuotationLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfEstimateQuotationLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllEstimateStatusForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfEstimateEstimateStatusLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Estimates/GetAllEstimateStatusForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllEstimateStatusForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllEstimateStatusForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfEstimateEstimateStatusLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfEstimateEstimateStatusLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllEstimateStatusForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfEstimateEstimateStatusLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfEstimateEstimateStatusLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfEstimateEstimateStatusLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param workOrderId (optional) 
     * @param quotationId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllCustomerForLookupTable(filter: string | null | undefined, workOrderId: number | null | undefined, quotationId: number | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfEstimateCustomerLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Estimates/GetAllCustomerForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (workOrderId !== undefined)
            url_ += "WorkOrderId=" + encodeURIComponent("" + workOrderId) + "&"; 
        if (quotationId !== undefined)
            url_ += "QuotationId=" + encodeURIComponent("" + quotationId) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCustomerForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCustomerForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfEstimateCustomerLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfEstimateCustomerLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCustomerForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfEstimateCustomerLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfEstimateCustomerLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfEstimateCustomerLookupTableDto>(<any>null);
    }

    /**
     * @param workOrderId (optional) 
     * @return Success
     */
    getWorkOrderFkData(workOrderId: number | null | undefined): Observable<EstimateWorkOrderFkListDto> {
        let url_ = this.baseUrl + "/api/services/app/Estimates/GetWorkOrderFkData?";
        if (workOrderId !== undefined)
            url_ += "workOrderId=" + encodeURIComponent("" + workOrderId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWorkOrderFkData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWorkOrderFkData(<any>response_);
                } catch (e) {
                    return <Observable<EstimateWorkOrderFkListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<EstimateWorkOrderFkListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWorkOrderFkData(response: HttpResponseBase): Observable<EstimateWorkOrderFkListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EstimateWorkOrderFkListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EstimateWorkOrderFkListDto>(<any>null);
    }

    /**
     * @param quotationId (optional) 
     * @return Success
     */
    getQuotationFkData(quotationId: number | null | undefined): Observable<EstimateQuotationFkListDto> {
        let url_ = this.baseUrl + "/api/services/app/Estimates/GetQuotationFkData?";
        if (quotationId !== undefined)
            url_ += "quotationId=" + encodeURIComponent("" + quotationId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQuotationFkData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQuotationFkData(<any>response_);
                } catch (e) {
                    return <Observable<EstimateQuotationFkListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<EstimateQuotationFkListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetQuotationFkData(response: HttpResponseBase): Observable<EstimateQuotationFkListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EstimateQuotationFkListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EstimateQuotationFkListDto>(<any>null);
    }

    /**
     * @param estimateId (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @param sorting (optional) 
     * @return Success
     */
    getEstimateQuotationForView(estimateId: number | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined, sorting: string | null | undefined): Observable<GetEstimateQuotationForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Estimates/GetEstimateQuotationForView?";
        if (estimateId !== undefined)
            url_ += "estimateId=" + encodeURIComponent("" + estimateId) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEstimateQuotationForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEstimateQuotationForView(<any>response_);
                } catch (e) {
                    return <Observable<GetEstimateQuotationForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetEstimateQuotationForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEstimateQuotationForView(response: HttpResponseBase): Observable<GetEstimateQuotationForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetEstimateQuotationForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetEstimateQuotationForViewDto>(<any>null);
    }

    /**
     * @param estimateId (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @param sorting (optional) 
     * @return Success
     */
    getEstimateWorkOrderForView(estimateId: number | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined, sorting: string | null | undefined): Observable<GetEstimateWorkOrderForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Estimates/GetEstimateWorkOrderForView?";
        if (estimateId !== undefined)
            url_ += "estimateId=" + encodeURIComponent("" + estimateId) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEstimateWorkOrderForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEstimateWorkOrderForView(<any>response_);
                } catch (e) {
                    return <Observable<GetEstimateWorkOrderForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetEstimateWorkOrderForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEstimateWorkOrderForView(response: HttpResponseBase): Observable<GetEstimateWorkOrderForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetEstimateWorkOrderForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetEstimateWorkOrderForViewDto>(<any>null);
    }

    /**
     * @param estimateId (optional) 
     * @return Success
     */
    getEstimatePDFInfo(estimateId: number | null | undefined): Observable<EstimatePdfDto> {
        let url_ = this.baseUrl + "/api/services/app/Estimates/GetEstimatePDFInfo?";
        if (estimateId !== undefined)
            url_ += "estimateId=" + encodeURIComponent("" + estimateId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEstimatePDFInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEstimatePDFInfo(<any>response_);
                } catch (e) {
                    return <Observable<EstimatePdfDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<EstimatePdfDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEstimatePDFInfo(response: HttpResponseBase): Observable<EstimatePdfDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EstimatePdfDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EstimatePdfDto>(<any>null);
    }
}

@Injectable()
export class EstimateStatusesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param statusFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, statusFilter: string | null | undefined, descriptionFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetEstimateStatusForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/EstimateStatuses/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (statusFilter !== undefined)
            url_ += "StatusFilter=" + encodeURIComponent("" + statusFilter) + "&"; 
        if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetEstimateStatusForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetEstimateStatusForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetEstimateStatusForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetEstimateStatusForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetEstimateStatusForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getEstimateStatusForView(id: number | null | undefined): Observable<GetEstimateStatusForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/EstimateStatuses/GetEstimateStatusForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEstimateStatusForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEstimateStatusForView(<any>response_);
                } catch (e) {
                    return <Observable<GetEstimateStatusForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetEstimateStatusForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEstimateStatusForView(response: HttpResponseBase): Observable<GetEstimateStatusForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetEstimateStatusForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetEstimateStatusForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getEstimateStatusForEdit(id: number | null | undefined): Observable<GetEstimateStatusForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/EstimateStatuses/GetEstimateStatusForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEstimateStatusForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEstimateStatusForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetEstimateStatusForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetEstimateStatusForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetEstimateStatusForEdit(response: HttpResponseBase): Observable<GetEstimateStatusForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetEstimateStatusForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetEstimateStatusForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditEstimateStatusDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/EstimateStatuses/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/EstimateStatuses/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param statusFilter (optional) 
     * @param descriptionFilter (optional) 
     * @return Success
     */
    getEstimateStatusesToExcel(filter: string | null | undefined, statusFilter: string | null | undefined, descriptionFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/EstimateStatuses/GetEstimateStatusesToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (statusFilter !== undefined)
            url_ += "StatusFilter=" + encodeURIComponent("" + statusFilter) + "&"; 
        if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEstimateStatusesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEstimateStatusesToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEstimateStatusesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class FriendshipServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createFriendshipRequest(input: CreateFriendshipRequestInput | null | undefined): Observable<FriendDto> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/CreateFriendshipRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateFriendshipRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateFriendshipRequest(<any>response_);
                } catch (e) {
                    return <Observable<FriendDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FriendDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateFriendshipRequest(response: HttpResponseBase): Observable<FriendDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FriendDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FriendDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createFriendshipRequestByUserName(input: CreateFriendshipRequestByUserNameInput | null | undefined): Observable<FriendDto> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/CreateFriendshipRequestByUserName";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateFriendshipRequestByUserName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateFriendshipRequestByUserName(<any>response_);
                } catch (e) {
                    return <Observable<FriendDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FriendDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateFriendshipRequestByUserName(response: HttpResponseBase): Observable<FriendDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FriendDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FriendDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    blockUser(input: BlockUserInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/BlockUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBlockUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBlockUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBlockUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    unblockUser(input: UnblockUserInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/UnblockUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnblockUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnblockUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnblockUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    acceptFriendshipRequest(input: AcceptFriendshipRequestInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Friendship/AcceptFriendshipRequest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAcceptFriendshipRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAcceptFriendshipRequest(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAcceptFriendshipRequest(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class HostDashboardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    getDashboardStatisticsData(incomeStatisticsDateInterval: ChartDateInterval, startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined): Observable<HostDashboardData> {
        let url_ = this.baseUrl + "/api/services/app/HostDashboard/GetDashboardStatisticsData?";
        if (incomeStatisticsDateInterval === undefined || incomeStatisticsDateInterval === null)
            throw new Error("The parameter 'incomeStatisticsDateInterval' must be defined and cannot be null.");
        else
            url_ += "IncomeStatisticsDateInterval=" + encodeURIComponent("" + incomeStatisticsDateInterval) + "&"; 
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDashboardStatisticsData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDashboardStatisticsData(<any>response_);
                } catch (e) {
                    return <Observable<HostDashboardData>><any>_observableThrow(e);
                }
            } else
                return <Observable<HostDashboardData>><any>_observableThrow(response_);
        }));
    }

    protected processGetDashboardStatisticsData(response: HttpResponseBase): Observable<HostDashboardData> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HostDashboardData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HostDashboardData>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    getIncomeStatistics(incomeStatisticsDateInterval: ChartDateInterval, startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined): Observable<GetIncomeStatisticsDataOutput> {
        let url_ = this.baseUrl + "/api/services/app/HostDashboard/GetIncomeStatistics?";
        if (incomeStatisticsDateInterval === undefined || incomeStatisticsDateInterval === null)
            throw new Error("The parameter 'incomeStatisticsDateInterval' must be defined and cannot be null.");
        else
            url_ += "IncomeStatisticsDateInterval=" + encodeURIComponent("" + incomeStatisticsDateInterval) + "&"; 
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIncomeStatistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIncomeStatistics(<any>response_);
                } catch (e) {
                    return <Observable<GetIncomeStatisticsDataOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetIncomeStatisticsDataOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetIncomeStatistics(response: HttpResponseBase): Observable<GetIncomeStatisticsDataOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetIncomeStatisticsDataOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetIncomeStatisticsDataOutput>(<any>null);
    }

    /**
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    getEditionTenantStatistics(startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined): Observable<GetEditionTenantStatisticsOutput> {
        let url_ = this.baseUrl + "/api/services/app/HostDashboard/GetEditionTenantStatistics?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionTenantStatistics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionTenantStatistics(<any>response_);
                } catch (e) {
                    return <Observable<GetEditionTenantStatisticsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetEditionTenantStatisticsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionTenantStatistics(response: HttpResponseBase): Observable<GetEditionTenantStatisticsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetEditionTenantStatisticsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetEditionTenantStatisticsOutput>(<any>null);
    }
}

@Injectable()
export class HostSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllSettings(): Observable<HostSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/GetAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSettings(<any>response_);
                } catch (e) {
                    return <Observable<HostSettingsEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<HostSettingsEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSettings(response: HttpResponseBase): Observable<HostSettingsEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = HostSettingsEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<HostSettingsEditDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateAllSettings(input: HostSettingsEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/UpdateAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAllSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAllSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    sendTestEmail(input: SendTestEmailInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/HostSettings/SendTestEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTestEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTestEmail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendTestEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class IncidentPrioritiesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetIncidentPriorityForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/IncidentPriorities/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetIncidentPriorityForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetIncidentPriorityForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetIncidentPriorityForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetIncidentPriorityForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetIncidentPriorityForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getIncidentPriorityForView(id: number | null | undefined): Observable<GetIncidentPriorityForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/IncidentPriorities/GetIncidentPriorityForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIncidentPriorityForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIncidentPriorityForView(<any>response_);
                } catch (e) {
                    return <Observable<GetIncidentPriorityForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetIncidentPriorityForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetIncidentPriorityForView(response: HttpResponseBase): Observable<GetIncidentPriorityForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetIncidentPriorityForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetIncidentPriorityForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getIncidentPriorityForEdit(id: number | null | undefined): Observable<GetIncidentPriorityForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/IncidentPriorities/GetIncidentPriorityForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIncidentPriorityForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIncidentPriorityForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetIncidentPriorityForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetIncidentPriorityForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetIncidentPriorityForEdit(response: HttpResponseBase): Observable<GetIncidentPriorityForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetIncidentPriorityForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetIncidentPriorityForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditIncidentPriorityDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/IncidentPriorities/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/IncidentPriorities/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @return Success
     */
    getIncidentPrioritiesToExcel(filter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/IncidentPriorities/GetIncidentPrioritiesToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIncidentPrioritiesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIncidentPrioritiesToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetIncidentPrioritiesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class IncidentsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param descriptionFilter (optional) 
     * @param maxIncidentDateFilter (optional) 
     * @param minIncidentDateFilter (optional) 
     * @param locationFilter (optional) 
     * @param remarksFilter (optional) 
     * @param maxResolvedAtFilter (optional) 
     * @param minResolvedAtFilter (optional) 
     * @param incidentPriorityPriorityFilter (optional) 
     * @param incidentStatusStatusFilter (optional) 
     * @param customerNameFilter (optional) 
     * @param assetReferenceFilter (optional) 
     * @param supportItemDescriptionFilter (optional) 
     * @param incidentTypeTypeFilter (optional) 
     * @param userNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, descriptionFilter: string | null | undefined, maxIncidentDateFilter: moment.Moment | null | undefined, minIncidentDateFilter: moment.Moment | null | undefined, locationFilter: string | null | undefined, remarksFilter: string | null | undefined, maxResolvedAtFilter: moment.Moment | null | undefined, minResolvedAtFilter: moment.Moment | null | undefined, incidentPriorityPriorityFilter: string | null | undefined, incidentStatusStatusFilter: string | null | undefined, customerNameFilter: string | null | undefined, assetReferenceFilter: string | null | undefined, supportItemDescriptionFilter: string | null | undefined, incidentTypeTypeFilter: string | null | undefined, userNameFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetIncidentForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Incidents/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (maxIncidentDateFilter !== undefined)
            url_ += "MaxIncidentDateFilter=" + encodeURIComponent(maxIncidentDateFilter ? "" + maxIncidentDateFilter.toJSON() : "") + "&"; 
        if (minIncidentDateFilter !== undefined)
            url_ += "MinIncidentDateFilter=" + encodeURIComponent(minIncidentDateFilter ? "" + minIncidentDateFilter.toJSON() : "") + "&"; 
        if (locationFilter !== undefined)
            url_ += "LocationFilter=" + encodeURIComponent("" + locationFilter) + "&"; 
        if (remarksFilter !== undefined)
            url_ += "RemarksFilter=" + encodeURIComponent("" + remarksFilter) + "&"; 
        if (maxResolvedAtFilter !== undefined)
            url_ += "MaxResolvedAtFilter=" + encodeURIComponent(maxResolvedAtFilter ? "" + maxResolvedAtFilter.toJSON() : "") + "&"; 
        if (minResolvedAtFilter !== undefined)
            url_ += "MinResolvedAtFilter=" + encodeURIComponent(minResolvedAtFilter ? "" + minResolvedAtFilter.toJSON() : "") + "&"; 
        if (incidentPriorityPriorityFilter !== undefined)
            url_ += "IncidentPriorityPriorityFilter=" + encodeURIComponent("" + incidentPriorityPriorityFilter) + "&"; 
        if (incidentStatusStatusFilter !== undefined)
            url_ += "IncidentStatusStatusFilter=" + encodeURIComponent("" + incidentStatusStatusFilter) + "&"; 
        if (customerNameFilter !== undefined)
            url_ += "CustomerNameFilter=" + encodeURIComponent("" + customerNameFilter) + "&"; 
        if (assetReferenceFilter !== undefined)
            url_ += "AssetReferenceFilter=" + encodeURIComponent("" + assetReferenceFilter) + "&"; 
        if (supportItemDescriptionFilter !== undefined)
            url_ += "SupportItemDescriptionFilter=" + encodeURIComponent("" + supportItemDescriptionFilter) + "&"; 
        if (incidentTypeTypeFilter !== undefined)
            url_ += "IncidentTypeTypeFilter=" + encodeURIComponent("" + incidentTypeTypeFilter) + "&"; 
        if (userNameFilter !== undefined)
            url_ += "UserNameFilter=" + encodeURIComponent("" + userNameFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetIncidentForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetIncidentForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetIncidentForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetIncidentForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetIncidentForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @param sorting (optional) 
     * @return Success
     */
    getIncidentForView(id: number | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined, sorting: string | null | undefined): Observable<GetIncidentForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Incidents/GetIncidentForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIncidentForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIncidentForView(<any>response_);
                } catch (e) {
                    return <Observable<GetIncidentForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetIncidentForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetIncidentForView(response: HttpResponseBase): Observable<GetIncidentForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetIncidentForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetIncidentForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getIncidentForEdit(id: number | null | undefined): Observable<GetIncidentForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Incidents/GetIncidentForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIncidentForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIncidentForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetIncidentForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetIncidentForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetIncidentForEdit(response: HttpResponseBase): Observable<GetIncidentForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetIncidentForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetIncidentForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditIncidentDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Incidents/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Incidents/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param descriptionFilter (optional) 
     * @param maxIncidentDateFilter (optional) 
     * @param minIncidentDateFilter (optional) 
     * @param locationFilter (optional) 
     * @param remarksFilter (optional) 
     * @param maxResolvedAtFilter (optional) 
     * @param minResolvedAtFilter (optional) 
     * @param incidentPriorityPriorityFilter (optional) 
     * @param incidentStatusStatusFilter (optional) 
     * @param customerNameFilter (optional) 
     * @param assetReferenceFilter (optional) 
     * @param supportItemDescriptionFilter (optional) 
     * @param incidentTypeTypeFilter (optional) 
     * @param userNameFilter (optional) 
     * @return Success
     */
    getIncidentsToExcel(filter: string | null | undefined, descriptionFilter: string | null | undefined, maxIncidentDateFilter: moment.Moment | null | undefined, minIncidentDateFilter: moment.Moment | null | undefined, locationFilter: string | null | undefined, remarksFilter: string | null | undefined, maxResolvedAtFilter: moment.Moment | null | undefined, minResolvedAtFilter: moment.Moment | null | undefined, incidentPriorityPriorityFilter: string | null | undefined, incidentStatusStatusFilter: string | null | undefined, customerNameFilter: string | null | undefined, assetReferenceFilter: string | null | undefined, supportItemDescriptionFilter: string | null | undefined, incidentTypeTypeFilter: string | null | undefined, userNameFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Incidents/GetIncidentsToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (maxIncidentDateFilter !== undefined)
            url_ += "MaxIncidentDateFilter=" + encodeURIComponent(maxIncidentDateFilter ? "" + maxIncidentDateFilter.toJSON() : "") + "&"; 
        if (minIncidentDateFilter !== undefined)
            url_ += "MinIncidentDateFilter=" + encodeURIComponent(minIncidentDateFilter ? "" + minIncidentDateFilter.toJSON() : "") + "&"; 
        if (locationFilter !== undefined)
            url_ += "LocationFilter=" + encodeURIComponent("" + locationFilter) + "&"; 
        if (remarksFilter !== undefined)
            url_ += "RemarksFilter=" + encodeURIComponent("" + remarksFilter) + "&"; 
        if (maxResolvedAtFilter !== undefined)
            url_ += "MaxResolvedAtFilter=" + encodeURIComponent(maxResolvedAtFilter ? "" + maxResolvedAtFilter.toJSON() : "") + "&"; 
        if (minResolvedAtFilter !== undefined)
            url_ += "MinResolvedAtFilter=" + encodeURIComponent(minResolvedAtFilter ? "" + minResolvedAtFilter.toJSON() : "") + "&"; 
        if (incidentPriorityPriorityFilter !== undefined)
            url_ += "IncidentPriorityPriorityFilter=" + encodeURIComponent("" + incidentPriorityPriorityFilter) + "&"; 
        if (incidentStatusStatusFilter !== undefined)
            url_ += "IncidentStatusStatusFilter=" + encodeURIComponent("" + incidentStatusStatusFilter) + "&"; 
        if (customerNameFilter !== undefined)
            url_ += "CustomerNameFilter=" + encodeURIComponent("" + customerNameFilter) + "&"; 
        if (assetReferenceFilter !== undefined)
            url_ += "AssetReferenceFilter=" + encodeURIComponent("" + assetReferenceFilter) + "&"; 
        if (supportItemDescriptionFilter !== undefined)
            url_ += "SupportItemDescriptionFilter=" + encodeURIComponent("" + supportItemDescriptionFilter) + "&"; 
        if (incidentTypeTypeFilter !== undefined)
            url_ += "IncidentTypeTypeFilter=" + encodeURIComponent("" + incidentTypeTypeFilter) + "&"; 
        if (userNameFilter !== undefined)
            url_ += "UserNameFilter=" + encodeURIComponent("" + userNameFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIncidentsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIncidentsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetIncidentsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllIncidentPriorityForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfIncidentIncidentPriorityLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Incidents/GetAllIncidentPriorityForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllIncidentPriorityForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllIncidentPriorityForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfIncidentIncidentPriorityLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfIncidentIncidentPriorityLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllIncidentPriorityForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfIncidentIncidentPriorityLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfIncidentIncidentPriorityLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfIncidentIncidentPriorityLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllIncidentStatusForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfIncidentIncidentStatusLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Incidents/GetAllIncidentStatusForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllIncidentStatusForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllIncidentStatusForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfIncidentIncidentStatusLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfIncidentIncidentStatusLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllIncidentStatusForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfIncidentIncidentStatusLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfIncidentIncidentStatusLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfIncidentIncidentStatusLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param assetId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllCustomerForLookupTable(filter: string | null | undefined, assetId: number | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfIncidentCustomerLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Incidents/GetAllCustomerForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (assetId !== undefined)
            url_ += "AssetId=" + encodeURIComponent("" + assetId) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCustomerForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCustomerForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfIncidentCustomerLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfIncidentCustomerLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCustomerForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfIncidentCustomerLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfIncidentCustomerLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfIncidentCustomerLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllAssetForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfIncidentAssetLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Incidents/GetAllAssetForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAssetForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAssetForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfIncidentAssetLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfIncidentAssetLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAssetForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfIncidentAssetLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfIncidentAssetLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfIncidentAssetLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param assetId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllSupportItemForLookupTable(filter: string | null | undefined, assetId: number | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfIncidentSupportItemLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Incidents/GetAllSupportItemForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (assetId !== undefined)
            url_ += "AssetId=" + encodeURIComponent("" + assetId) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSupportItemForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSupportItemForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfIncidentSupportItemLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfIncidentSupportItemLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSupportItemForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfIncidentSupportItemLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfIncidentSupportItemLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfIncidentSupportItemLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllIncidentTypeForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfIncidentIncidentTypeLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Incidents/GetAllIncidentTypeForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllIncidentTypeForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllIncidentTypeForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfIncidentIncidentTypeLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfIncidentIncidentTypeLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllIncidentTypeForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfIncidentIncidentTypeLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfIncidentIncidentTypeLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfIncidentIncidentTypeLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllUserForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfIncidentUserLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Incidents/GetAllUserForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfIncidentUserLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfIncidentUserLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUserForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfIncidentUserLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfIncidentUserLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfIncidentUserLookupTableDto>(<any>null);
    }

    /**
     * @param assetId (optional) 
     * @return Success
     */
    getSupportItemAndCustomerList(assetId: number | null | undefined): Observable<IncidentSupportItemAndCustomerListDto> {
        let url_ = this.baseUrl + "/api/services/app/Incidents/GetSupportItemAndCustomerList?";
        if (assetId !== undefined)
            url_ += "assetId=" + encodeURIComponent("" + assetId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSupportItemAndCustomerList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSupportItemAndCustomerList(<any>response_);
                } catch (e) {
                    return <Observable<IncidentSupportItemAndCustomerListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<IncidentSupportItemAndCustomerListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSupportItemAndCustomerList(response: HttpResponseBase): Observable<IncidentSupportItemAndCustomerListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IncidentSupportItemAndCustomerListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IncidentSupportItemAndCustomerListDto>(<any>null);
    }

    /**
     * @return Success
     */
    getDefaultCreator(): Observable<IncidentUserLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Incidents/GetDefaultCreator";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDefaultCreator(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDefaultCreator(<any>response_);
                } catch (e) {
                    return <Observable<IncidentUserLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<IncidentUserLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDefaultCreator(response: HttpResponseBase): Observable<IncidentUserLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = IncidentUserLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IncidentUserLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllLocationForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfLocationLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Incidents/GetAllLocationForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllLocationForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllLocationForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfLocationLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfLocationLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllLocationForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfLocationLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfLocationLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfLocationLookupTableDto>(<any>null);
    }
}

@Injectable()
export class IncidentStatusesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetIncidentStatusForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/IncidentStatuses/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetIncidentStatusForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetIncidentStatusForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetIncidentStatusForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetIncidentStatusForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetIncidentStatusForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getIncidentStatusForView(id: number | null | undefined): Observable<GetIncidentStatusForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/IncidentStatuses/GetIncidentStatusForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIncidentStatusForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIncidentStatusForView(<any>response_);
                } catch (e) {
                    return <Observable<GetIncidentStatusForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetIncidentStatusForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetIncidentStatusForView(response: HttpResponseBase): Observable<GetIncidentStatusForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetIncidentStatusForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetIncidentStatusForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getIncidentStatusForEdit(id: number | null | undefined): Observable<GetIncidentStatusForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/IncidentStatuses/GetIncidentStatusForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIncidentStatusForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIncidentStatusForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetIncidentStatusForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetIncidentStatusForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetIncidentStatusForEdit(response: HttpResponseBase): Observable<GetIncidentStatusForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetIncidentStatusForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetIncidentStatusForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditIncidentStatusDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/IncidentStatuses/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/IncidentStatuses/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @return Success
     */
    getIncidentStatusesToExcel(filter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/IncidentStatuses/GetIncidentStatusesToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIncidentStatusesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIncidentStatusesToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetIncidentStatusesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class IncidentTypesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetIncidentTypeForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/IncidentTypes/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetIncidentTypeForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetIncidentTypeForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetIncidentTypeForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetIncidentTypeForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetIncidentTypeForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getIncidentTypeForView(id: number | null | undefined): Observable<GetIncidentTypeForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/IncidentTypes/GetIncidentTypeForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIncidentTypeForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIncidentTypeForView(<any>response_);
                } catch (e) {
                    return <Observable<GetIncidentTypeForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetIncidentTypeForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetIncidentTypeForView(response: HttpResponseBase): Observable<GetIncidentTypeForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetIncidentTypeForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetIncidentTypeForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getIncidentTypeForEdit(id: number | null | undefined): Observable<GetIncidentTypeForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/IncidentTypes/GetIncidentTypeForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIncidentTypeForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIncidentTypeForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetIncidentTypeForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetIncidentTypeForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetIncidentTypeForEdit(response: HttpResponseBase): Observable<GetIncidentTypeForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetIncidentTypeForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetIncidentTypeForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditIncidentTypeDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/IncidentTypes/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/IncidentTypes/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @return Success
     */
    getIncidentTypesToExcel(filter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/IncidentTypes/GetIncidentTypesToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIncidentTypesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIncidentTypesToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetIncidentTypesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class IncidentUpdatesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param maxUpdatedFilter (optional) 
     * @param minUpdatedFilter (optional) 
     * @param updateFilter (optional) 
     * @param userNameFilter (optional) 
     * @param incidentDescriptionFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, maxUpdatedFilter: moment.Moment | null | undefined, minUpdatedFilter: moment.Moment | null | undefined, updateFilter: string | null | undefined, userNameFilter: string | null | undefined, incidentDescriptionFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetIncidentUpdateForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/IncidentUpdates/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxUpdatedFilter !== undefined)
            url_ += "MaxUpdatedFilter=" + encodeURIComponent(maxUpdatedFilter ? "" + maxUpdatedFilter.toJSON() : "") + "&"; 
        if (minUpdatedFilter !== undefined)
            url_ += "MinUpdatedFilter=" + encodeURIComponent(minUpdatedFilter ? "" + minUpdatedFilter.toJSON() : "") + "&"; 
        if (updateFilter !== undefined)
            url_ += "UpdateFilter=" + encodeURIComponent("" + updateFilter) + "&"; 
        if (userNameFilter !== undefined)
            url_ += "UserNameFilter=" + encodeURIComponent("" + userNameFilter) + "&"; 
        if (incidentDescriptionFilter !== undefined)
            url_ += "IncidentDescriptionFilter=" + encodeURIComponent("" + incidentDescriptionFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetIncidentUpdateForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetIncidentUpdateForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetIncidentUpdateForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetIncidentUpdateForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetIncidentUpdateForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getIncidentUpdateForView(id: number | null | undefined): Observable<GetIncidentUpdateForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/IncidentUpdates/GetIncidentUpdateForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIncidentUpdateForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIncidentUpdateForView(<any>response_);
                } catch (e) {
                    return <Observable<GetIncidentUpdateForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetIncidentUpdateForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetIncidentUpdateForView(response: HttpResponseBase): Observable<GetIncidentUpdateForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetIncidentUpdateForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetIncidentUpdateForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getIncidentUpdateForEdit(id: number | null | undefined): Observable<GetIncidentUpdateForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/IncidentUpdates/GetIncidentUpdateForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIncidentUpdateForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIncidentUpdateForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetIncidentUpdateForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetIncidentUpdateForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetIncidentUpdateForEdit(response: HttpResponseBase): Observable<GetIncidentUpdateForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetIncidentUpdateForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetIncidentUpdateForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditIncidentUpdateDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/IncidentUpdates/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/IncidentUpdates/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param maxUpdatedFilter (optional) 
     * @param minUpdatedFilter (optional) 
     * @param updateFilter (optional) 
     * @param userNameFilter (optional) 
     * @param incidentDescriptionFilter (optional) 
     * @return Success
     */
    getIncidentUpdatesToExcel(filter: string | null | undefined, maxUpdatedFilter: moment.Moment | null | undefined, minUpdatedFilter: moment.Moment | null | undefined, updateFilter: string | null | undefined, userNameFilter: string | null | undefined, incidentDescriptionFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/IncidentUpdates/GetIncidentUpdatesToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxUpdatedFilter !== undefined)
            url_ += "MaxUpdatedFilter=" + encodeURIComponent(maxUpdatedFilter ? "" + maxUpdatedFilter.toJSON() : "") + "&"; 
        if (minUpdatedFilter !== undefined)
            url_ += "MinUpdatedFilter=" + encodeURIComponent(minUpdatedFilter ? "" + minUpdatedFilter.toJSON() : "") + "&"; 
        if (updateFilter !== undefined)
            url_ += "UpdateFilter=" + encodeURIComponent("" + updateFilter) + "&"; 
        if (userNameFilter !== undefined)
            url_ += "UserNameFilter=" + encodeURIComponent("" + userNameFilter) + "&"; 
        if (incidentDescriptionFilter !== undefined)
            url_ += "IncidentDescriptionFilter=" + encodeURIComponent("" + incidentDescriptionFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIncidentUpdatesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIncidentUpdatesToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetIncidentUpdatesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllUserForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfIncidentUpdateUserLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/IncidentUpdates/GetAllUserForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfIncidentUpdateUserLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfIncidentUpdateUserLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUserForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfIncidentUpdateUserLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfIncidentUpdateUserLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfIncidentUpdateUserLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllIncidentForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfIncidentUpdateIncidentLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/IncidentUpdates/GetAllIncidentForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllIncidentForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllIncidentForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfIncidentUpdateIncidentLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfIncidentUpdateIncidentLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllIncidentForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfIncidentUpdateIncidentLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfIncidentUpdateIncidentLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfIncidentUpdateIncidentLookupTableDto>(<any>null);
    }
}

@Injectable()
export class InstallServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    setup(input: InstallDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Install/Setup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetup(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetup(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getAppSettingsJson(): Observable<AppSettingsJsonDto> {
        let url_ = this.baseUrl + "/api/services/app/Install/GetAppSettingsJson";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAppSettingsJson(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAppSettingsJson(<any>response_);
                } catch (e) {
                    return <Observable<AppSettingsJsonDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<AppSettingsJsonDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAppSettingsJson(response: HttpResponseBase): Observable<AppSettingsJsonDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AppSettingsJsonDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AppSettingsJsonDto>(<any>null);
    }

    /**
     * @return Success
     */
    checkDatabase(): Observable<CheckDatabaseOutput> {
        let url_ = this.baseUrl + "/api/services/app/Install/CheckDatabase";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckDatabase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckDatabase(<any>response_);
                } catch (e) {
                    return <Observable<CheckDatabaseOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<CheckDatabaseOutput>><any>_observableThrow(response_);
        }));
    }

    protected processCheckDatabase(response: HttpResponseBase): Observable<CheckDatabaseOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CheckDatabaseOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CheckDatabaseOutput>(<any>null);
    }
}

@Injectable()
export class InventoryItemsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param assetId (optional) 
     * @param warehouseId (optional) 
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param referenceFilter (optional) 
     * @param maxQtyInWarehouseFilter (optional) 
     * @param minQtyInWarehouseFilter (optional) 
     * @param maxRestockLimitFilter (optional) 
     * @param minRestockLimitFilter (optional) 
     * @param maxQtyOnOrderFilter (optional) 
     * @param minQtyOnOrderFilter (optional) 
     * @param itemTypeTypeFilter (optional) 
     * @param assetReferenceFilter (optional) 
     * @param warehouseNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(assetId: number | null | undefined, warehouseId: number | null | undefined, filter: string | null | undefined, nameFilter: string | null | undefined, referenceFilter: string | null | undefined, maxQtyInWarehouseFilter: number | null | undefined, minQtyInWarehouseFilter: number | null | undefined, maxRestockLimitFilter: number | null | undefined, minRestockLimitFilter: number | null | undefined, maxQtyOnOrderFilter: number | null | undefined, minQtyOnOrderFilter: number | null | undefined, itemTypeTypeFilter: string | null | undefined, assetReferenceFilter: string | null | undefined, warehouseNameFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetInventoryItemForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/InventoryItems/GetAll?";
        if (assetId !== undefined)
            url_ += "AssetId=" + encodeURIComponent("" + assetId) + "&"; 
        if (warehouseId !== undefined)
            url_ += "WarehouseId=" + encodeURIComponent("" + warehouseId) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&"; 
        if (referenceFilter !== undefined)
            url_ += "ReferenceFilter=" + encodeURIComponent("" + referenceFilter) + "&"; 
        if (maxQtyInWarehouseFilter !== undefined)
            url_ += "MaxQtyInWarehouseFilter=" + encodeURIComponent("" + maxQtyInWarehouseFilter) + "&"; 
        if (minQtyInWarehouseFilter !== undefined)
            url_ += "MinQtyInWarehouseFilter=" + encodeURIComponent("" + minQtyInWarehouseFilter) + "&"; 
        if (maxRestockLimitFilter !== undefined)
            url_ += "MaxRestockLimitFilter=" + encodeURIComponent("" + maxRestockLimitFilter) + "&"; 
        if (minRestockLimitFilter !== undefined)
            url_ += "MinRestockLimitFilter=" + encodeURIComponent("" + minRestockLimitFilter) + "&"; 
        if (maxQtyOnOrderFilter !== undefined)
            url_ += "MaxQtyOnOrderFilter=" + encodeURIComponent("" + maxQtyOnOrderFilter) + "&"; 
        if (minQtyOnOrderFilter !== undefined)
            url_ += "MinQtyOnOrderFilter=" + encodeURIComponent("" + minQtyOnOrderFilter) + "&"; 
        if (itemTypeTypeFilter !== undefined)
            url_ += "ItemTypeTypeFilter=" + encodeURIComponent("" + itemTypeTypeFilter) + "&"; 
        if (assetReferenceFilter !== undefined)
            url_ += "AssetReferenceFilter=" + encodeURIComponent("" + assetReferenceFilter) + "&"; 
        if (warehouseNameFilter !== undefined)
            url_ += "WarehouseNameFilter=" + encodeURIComponent("" + warehouseNameFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetInventoryItemForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetInventoryItemForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetInventoryItemForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetInventoryItemForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetInventoryItemForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getInventoryItemForView(id: number | null | undefined): Observable<GetInventoryItemForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/InventoryItems/GetInventoryItemForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInventoryItemForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInventoryItemForView(<any>response_);
                } catch (e) {
                    return <Observable<GetInventoryItemForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetInventoryItemForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetInventoryItemForView(response: HttpResponseBase): Observable<GetInventoryItemForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetInventoryItemForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetInventoryItemForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getInventoryItemForEdit(id: number | null | undefined): Observable<GetInventoryItemForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/InventoryItems/GetInventoryItemForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInventoryItemForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInventoryItemForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetInventoryItemForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetInventoryItemForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetInventoryItemForEdit(response: HttpResponseBase): Observable<GetInventoryItemForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetInventoryItemForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetInventoryItemForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditInventoryItemDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/InventoryItems/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/InventoryItems/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param referenceFilter (optional) 
     * @param maxQtyInWarehouseFilter (optional) 
     * @param minQtyInWarehouseFilter (optional) 
     * @param maxRestockLimitFilter (optional) 
     * @param minRestockLimitFilter (optional) 
     * @param maxQtyOnOrderFilter (optional) 
     * @param minQtyOnOrderFilter (optional) 
     * @param itemTypeTypeFilter (optional) 
     * @param assetReferenceFilter (optional) 
     * @param warehouseNameFilter (optional) 
     * @return Success
     */
    getInventoryItemsToExcel(filter: string | null | undefined, nameFilter: string | null | undefined, referenceFilter: string | null | undefined, maxQtyInWarehouseFilter: number | null | undefined, minQtyInWarehouseFilter: number | null | undefined, maxRestockLimitFilter: number | null | undefined, minRestockLimitFilter: number | null | undefined, maxQtyOnOrderFilter: number | null | undefined, minQtyOnOrderFilter: number | null | undefined, itemTypeTypeFilter: string | null | undefined, assetReferenceFilter: string | null | undefined, warehouseNameFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/InventoryItems/GetInventoryItemsToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&"; 
        if (referenceFilter !== undefined)
            url_ += "ReferenceFilter=" + encodeURIComponent("" + referenceFilter) + "&"; 
        if (maxQtyInWarehouseFilter !== undefined)
            url_ += "MaxQtyInWarehouseFilter=" + encodeURIComponent("" + maxQtyInWarehouseFilter) + "&"; 
        if (minQtyInWarehouseFilter !== undefined)
            url_ += "MinQtyInWarehouseFilter=" + encodeURIComponent("" + minQtyInWarehouseFilter) + "&"; 
        if (maxRestockLimitFilter !== undefined)
            url_ += "MaxRestockLimitFilter=" + encodeURIComponent("" + maxRestockLimitFilter) + "&"; 
        if (minRestockLimitFilter !== undefined)
            url_ += "MinRestockLimitFilter=" + encodeURIComponent("" + minRestockLimitFilter) + "&"; 
        if (maxQtyOnOrderFilter !== undefined)
            url_ += "MaxQtyOnOrderFilter=" + encodeURIComponent("" + maxQtyOnOrderFilter) + "&"; 
        if (minQtyOnOrderFilter !== undefined)
            url_ += "MinQtyOnOrderFilter=" + encodeURIComponent("" + minQtyOnOrderFilter) + "&"; 
        if (itemTypeTypeFilter !== undefined)
            url_ += "ItemTypeTypeFilter=" + encodeURIComponent("" + itemTypeTypeFilter) + "&"; 
        if (assetReferenceFilter !== undefined)
            url_ += "AssetReferenceFilter=" + encodeURIComponent("" + assetReferenceFilter) + "&"; 
        if (warehouseNameFilter !== undefined)
            url_ += "WarehouseNameFilter=" + encodeURIComponent("" + warehouseNameFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInventoryItemsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInventoryItemsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetInventoryItemsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllItemTypeForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfInventoryItemItemTypeLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/InventoryItems/GetAllItemTypeForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllItemTypeForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllItemTypeForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfInventoryItemItemTypeLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfInventoryItemItemTypeLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllItemTypeForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfInventoryItemItemTypeLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfInventoryItemItemTypeLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfInventoryItemItemTypeLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllAssetForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfInventoryItemAssetLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/InventoryItems/GetAllAssetForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAssetForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAssetForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfInventoryItemAssetLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfInventoryItemAssetLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAssetForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfInventoryItemAssetLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfInventoryItemAssetLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfInventoryItemAssetLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllWarehouseForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfInventoryItemWarehouseLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/InventoryItems/GetAllWarehouseForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWarehouseForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWarehouseForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfInventoryItemWarehouseLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfInventoryItemWarehouseLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllWarehouseForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfInventoryItemWarehouseLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfInventoryItemWarehouseLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfInventoryItemWarehouseLookupTableDto>(<any>null);
    }
}

@Injectable()
export class InvoiceServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getInvoiceInfo(id: number | null | undefined): Observable<InvoiceDto> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/GetInvoiceInfo?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoiceInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoiceInfo(<any>response_);
                } catch (e) {
                    return <Observable<InvoiceDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<InvoiceDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetInvoiceInfo(response: HttpResponseBase): Observable<InvoiceDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvoiceDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvoiceDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createInvoice(input: CreateInvoiceDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Invoice/CreateInvoice";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateInvoice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateInvoice(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateInvoice(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class ItemTypesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetItemTypeForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ItemTypes/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetItemTypeForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetItemTypeForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetItemTypeForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetItemTypeForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetItemTypeForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getItemTypeForView(id: number | null | undefined): Observable<GetItemTypeForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/ItemTypes/GetItemTypeForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetItemTypeForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetItemTypeForView(<any>response_);
                } catch (e) {
                    return <Observable<GetItemTypeForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetItemTypeForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetItemTypeForView(response: HttpResponseBase): Observable<GetItemTypeForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetItemTypeForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetItemTypeForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getItemTypeForEdit(id: number | null | undefined): Observable<GetItemTypeForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/ItemTypes/GetItemTypeForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetItemTypeForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetItemTypeForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetItemTypeForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetItemTypeForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetItemTypeForEdit(response: HttpResponseBase): Observable<GetItemTypeForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetItemTypeForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetItemTypeForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditItemTypeDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ItemTypes/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/ItemTypes/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllItemTypeForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfItemTypeLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/ItemTypes/GetAllItemTypeForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllItemTypeForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllItemTypeForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfItemTypeLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfItemTypeLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllItemTypeForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfItemTypeLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfItemTypeLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfItemTypeLookupTableDto>(<any>null);
    }
}

@Injectable()
export class LanguageServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getLanguages(): Observable<GetLanguagesOutput> {
        let url_ = this.baseUrl + "/api/services/app/Language/GetLanguages";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguages(<any>response_);
                } catch (e) {
                    return <Observable<GetLanguagesOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLanguagesOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetLanguages(response: HttpResponseBase): Observable<GetLanguagesOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetLanguagesOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLanguagesOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getLanguageForEdit(id: number | null | undefined): Observable<GetLanguageForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Language/GetLanguageForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguageForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguageForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetLanguageForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLanguageForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetLanguageForEdit(response: HttpResponseBase): Observable<GetLanguageForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetLanguageForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLanguageForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrUpdateLanguage(input: CreateOrUpdateLanguageInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/CreateOrUpdateLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteLanguage(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/DeleteLanguage?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    setDefaultLanguage(input: SetDefaultLanguageInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/SetDefaultLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetDefaultLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetDefaultLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetDefaultLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param sorting (optional) 
     * @param baseLanguageName (optional) 
     * @param targetValueFilter (optional) 
     * @param filterText (optional) 
     * @return Success
     */
    getLanguageTexts(maxResultCount: number | null | undefined, skipCount: number | null | undefined, sorting: string | null | undefined, sourceName: string, baseLanguageName: string | null | undefined, targetLanguageName: string, targetValueFilter: string | null | undefined, filterText: string | null | undefined): Observable<PagedResultDtoOfLanguageTextListDto> {
        let url_ = this.baseUrl + "/api/services/app/Language/GetLanguageTexts?";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (sourceName === undefined || sourceName === null)
            throw new Error("The parameter 'sourceName' must be defined and cannot be null.");
        else
            url_ += "SourceName=" + encodeURIComponent("" + sourceName) + "&"; 
        if (baseLanguageName !== undefined)
            url_ += "BaseLanguageName=" + encodeURIComponent("" + baseLanguageName) + "&"; 
        if (targetLanguageName === undefined || targetLanguageName === null)
            throw new Error("The parameter 'targetLanguageName' must be defined and cannot be null.");
        else
            url_ += "TargetLanguageName=" + encodeURIComponent("" + targetLanguageName) + "&"; 
        if (targetValueFilter !== undefined)
            url_ += "TargetValueFilter=" + encodeURIComponent("" + targetValueFilter) + "&"; 
        if (filterText !== undefined)
            url_ += "FilterText=" + encodeURIComponent("" + filterText) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLanguageTexts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLanguageTexts(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfLanguageTextListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfLanguageTextListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLanguageTexts(response: HttpResponseBase): Observable<PagedResultDtoOfLanguageTextListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfLanguageTextListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfLanguageTextListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateLanguageText(input: UpdateLanguageTextInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Language/UpdateLanguageText";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLanguageText(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLanguageText(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateLanguageText(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class LeaseAgreementsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param referenceFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param titleFilter (optional) 
     * @param termsFilter (optional) 
     * @param maxStartDateFilter (optional) 
     * @param minStartDateFilter (optional) 
     * @param maxEndDateFilter (optional) 
     * @param minEndDateFilter (optional) 
     * @param contactContactNameFilter (optional) 
     * @param assetOwnerNameFilter (optional) 
     * @param customerNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, referenceFilter: string | null | undefined, descriptionFilter: string | null | undefined, titleFilter: string | null | undefined, termsFilter: string | null | undefined, maxStartDateFilter: moment.Moment | null | undefined, minStartDateFilter: moment.Moment | null | undefined, maxEndDateFilter: moment.Moment | null | undefined, minEndDateFilter: moment.Moment | null | undefined, contactContactNameFilter: string | null | undefined, assetOwnerNameFilter: string | null | undefined, customerNameFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetLeaseAgreementForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/LeaseAgreements/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (referenceFilter !== undefined)
            url_ += "ReferenceFilter=" + encodeURIComponent("" + referenceFilter) + "&"; 
        if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (titleFilter !== undefined)
            url_ += "TitleFilter=" + encodeURIComponent("" + titleFilter) + "&"; 
        if (termsFilter !== undefined)
            url_ += "TermsFilter=" + encodeURIComponent("" + termsFilter) + "&"; 
        if (maxStartDateFilter !== undefined)
            url_ += "MaxStartDateFilter=" + encodeURIComponent(maxStartDateFilter ? "" + maxStartDateFilter.toJSON() : "") + "&"; 
        if (minStartDateFilter !== undefined)
            url_ += "MinStartDateFilter=" + encodeURIComponent(minStartDateFilter ? "" + minStartDateFilter.toJSON() : "") + "&"; 
        if (maxEndDateFilter !== undefined)
            url_ += "MaxEndDateFilter=" + encodeURIComponent(maxEndDateFilter ? "" + maxEndDateFilter.toJSON() : "") + "&"; 
        if (minEndDateFilter !== undefined)
            url_ += "MinEndDateFilter=" + encodeURIComponent(minEndDateFilter ? "" + minEndDateFilter.toJSON() : "") + "&"; 
        if (contactContactNameFilter !== undefined)
            url_ += "ContactContactNameFilter=" + encodeURIComponent("" + contactContactNameFilter) + "&"; 
        if (assetOwnerNameFilter !== undefined)
            url_ += "AssetOwnerNameFilter=" + encodeURIComponent("" + assetOwnerNameFilter) + "&"; 
        if (customerNameFilter !== undefined)
            url_ += "CustomerNameFilter=" + encodeURIComponent("" + customerNameFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetLeaseAgreementForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetLeaseAgreementForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetLeaseAgreementForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetLeaseAgreementForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetLeaseAgreementForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getLeaseAgreementForView(id: number | null | undefined): Observable<GetLeaseAgreementForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/LeaseAgreements/GetLeaseAgreementForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLeaseAgreementForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLeaseAgreementForView(<any>response_);
                } catch (e) {
                    return <Observable<GetLeaseAgreementForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLeaseAgreementForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLeaseAgreementForView(response: HttpResponseBase): Observable<GetLeaseAgreementForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetLeaseAgreementForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLeaseAgreementForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getLeaseAgreementForEdit(id: number | null | undefined): Observable<GetLeaseAgreementForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/LeaseAgreements/GetLeaseAgreementForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLeaseAgreementForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLeaseAgreementForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetLeaseAgreementForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLeaseAgreementForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetLeaseAgreementForEdit(response: HttpResponseBase): Observable<GetLeaseAgreementForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetLeaseAgreementForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLeaseAgreementForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditLeaseAgreementDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/LeaseAgreements/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/LeaseAgreements/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param referenceFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param titleFilter (optional) 
     * @param termsFilter (optional) 
     * @param maxStartDateFilter (optional) 
     * @param minStartDateFilter (optional) 
     * @param maxEndDateFilter (optional) 
     * @param minEndDateFilter (optional) 
     * @param contactContactNameFilter (optional) 
     * @param assetOwnerNameFilter (optional) 
     * @param customerNameFilter (optional) 
     * @return Success
     */
    getLeaseAgreementsToExcel(filter: string | null | undefined, referenceFilter: string | null | undefined, descriptionFilter: string | null | undefined, titleFilter: string | null | undefined, termsFilter: string | null | undefined, maxStartDateFilter: moment.Moment | null | undefined, minStartDateFilter: moment.Moment | null | undefined, maxEndDateFilter: moment.Moment | null | undefined, minEndDateFilter: moment.Moment | null | undefined, contactContactNameFilter: string | null | undefined, assetOwnerNameFilter: string | null | undefined, customerNameFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/LeaseAgreements/GetLeaseAgreementsToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (referenceFilter !== undefined)
            url_ += "ReferenceFilter=" + encodeURIComponent("" + referenceFilter) + "&"; 
        if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (titleFilter !== undefined)
            url_ += "TitleFilter=" + encodeURIComponent("" + titleFilter) + "&"; 
        if (termsFilter !== undefined)
            url_ += "TermsFilter=" + encodeURIComponent("" + termsFilter) + "&"; 
        if (maxStartDateFilter !== undefined)
            url_ += "MaxStartDateFilter=" + encodeURIComponent(maxStartDateFilter ? "" + maxStartDateFilter.toJSON() : "") + "&"; 
        if (minStartDateFilter !== undefined)
            url_ += "MinStartDateFilter=" + encodeURIComponent(minStartDateFilter ? "" + minStartDateFilter.toJSON() : "") + "&"; 
        if (maxEndDateFilter !== undefined)
            url_ += "MaxEndDateFilter=" + encodeURIComponent(maxEndDateFilter ? "" + maxEndDateFilter.toJSON() : "") + "&"; 
        if (minEndDateFilter !== undefined)
            url_ += "MinEndDateFilter=" + encodeURIComponent(minEndDateFilter ? "" + minEndDateFilter.toJSON() : "") + "&"; 
        if (contactContactNameFilter !== undefined)
            url_ += "ContactContactNameFilter=" + encodeURIComponent("" + contactContactNameFilter) + "&"; 
        if (assetOwnerNameFilter !== undefined)
            url_ += "AssetOwnerNameFilter=" + encodeURIComponent("" + assetOwnerNameFilter) + "&"; 
        if (customerNameFilter !== undefined)
            url_ += "CustomerNameFilter=" + encodeURIComponent("" + customerNameFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLeaseAgreementsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLeaseAgreementsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLeaseAgreementsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllContactForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfLeaseAgreementContactLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/LeaseAgreements/GetAllContactForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllContactForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllContactForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfLeaseAgreementContactLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfLeaseAgreementContactLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllContactForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfLeaseAgreementContactLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfLeaseAgreementContactLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfLeaseAgreementContactLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param filterId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllAssetOwnerForLookupTable(filter: string | null | undefined, filterId: number | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfLeaseAgreementAssetOwnerLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/LeaseAgreements/GetAllAssetOwnerForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (filterId !== undefined)
            url_ += "FilterId=" + encodeURIComponent("" + filterId) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAssetOwnerForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAssetOwnerForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfLeaseAgreementAssetOwnerLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfLeaseAgreementAssetOwnerLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAssetOwnerForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfLeaseAgreementAssetOwnerLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfLeaseAgreementAssetOwnerLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfLeaseAgreementAssetOwnerLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param filterId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllCustomerForLookupTable(filter: string | null | undefined, filterId: number | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfLeaseAgreementCustomerLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/LeaseAgreements/GetAllCustomerForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (filterId !== undefined)
            url_ += "FilterId=" + encodeURIComponent("" + filterId) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCustomerForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCustomerForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfLeaseAgreementCustomerLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfLeaseAgreementCustomerLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCustomerForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfLeaseAgreementCustomerLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfLeaseAgreementCustomerLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfLeaseAgreementCustomerLookupTableDto>(<any>null);
    }

    /**
     * @param contactId (optional) 
     * @return Success
     */
    getCustomerAndAssetOwnerInfo(contactId: number | null | undefined): Observable<LeaseAgreementCustomerAndAssetOwnerDto> {
        let url_ = this.baseUrl + "/api/services/app/LeaseAgreements/GetCustomerAndAssetOwnerInfo?";
        if (contactId !== undefined)
            url_ += "contactId=" + encodeURIComponent("" + contactId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCustomerAndAssetOwnerInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCustomerAndAssetOwnerInfo(<any>response_);
                } catch (e) {
                    return <Observable<LeaseAgreementCustomerAndAssetOwnerDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<LeaseAgreementCustomerAndAssetOwnerDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCustomerAndAssetOwnerInfo(response: HttpResponseBase): Observable<LeaseAgreementCustomerAndAssetOwnerDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LeaseAgreementCustomerAndAssetOwnerDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LeaseAgreementCustomerAndAssetOwnerDto>(<any>null);
    }

    /**
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @return Success
     */
    generateMonthlyInvoices(fromDate: moment.Moment | null | undefined, toDate: moment.Moment | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/LeaseAgreements/GenerateMonthlyInvoices?";
        if (fromDate !== undefined)
            url_ += "fromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toJSON() : "") + "&"; 
        if (toDate !== undefined)
            url_ += "toDate=" + encodeURIComponent(toDate ? "" + toDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateMonthlyInvoices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateMonthlyInvoices(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGenerateMonthlyInvoices(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class LeaseItemsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param leaseAgreementId (optional) 
     * @param filter (optional) 
     * @param maxDateAllocatedFilter (optional) 
     * @param minDateAllocatedFilter (optional) 
     * @param maxAllocationPercentageFilter (optional) 
     * @param minAllocationPercentageFilter (optional) 
     * @param termsFilter (optional) 
     * @param maxUnitRentalRateFilter (optional) 
     * @param minUnitRentalRateFilter (optional) 
     * @param maxUnitDepositRateFilter (optional) 
     * @param minUnitDepositRateFilter (optional) 
     * @param maxStartDateFilter (optional) 
     * @param minStartDateFilter (optional) 
     * @param maxEndDateFilter (optional) 
     * @param minEndDateFilter (optional) 
     * @param maxRentalUomRefIdFilter (optional) 
     * @param minRentalUomRefIdFilter (optional) 
     * @param maxDepositUomRefIdFilter (optional) 
     * @param minDepositUomRefIdFilter (optional) 
     * @param itemFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param assetClassClassFilter (optional) 
     * @param assetReferenceFilter (optional) 
     * @param leaseAgreementTitleFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(leaseAgreementId: number | null | undefined, filter: string | null | undefined, maxDateAllocatedFilter: moment.Moment | null | undefined, minDateAllocatedFilter: moment.Moment | null | undefined, maxAllocationPercentageFilter: number | null | undefined, minAllocationPercentageFilter: number | null | undefined, termsFilter: string | null | undefined, maxUnitRentalRateFilter: number | null | undefined, minUnitRentalRateFilter: number | null | undefined, maxUnitDepositRateFilter: number | null | undefined, minUnitDepositRateFilter: number | null | undefined, maxStartDateFilter: moment.Moment | null | undefined, minStartDateFilter: moment.Moment | null | undefined, maxEndDateFilter: moment.Moment | null | undefined, minEndDateFilter: moment.Moment | null | undefined, maxRentalUomRefIdFilter: number | null | undefined, minRentalUomRefIdFilter: number | null | undefined, maxDepositUomRefIdFilter: number | null | undefined, minDepositUomRefIdFilter: number | null | undefined, itemFilter: string | null | undefined, descriptionFilter: string | null | undefined, assetClassClassFilter: string | null | undefined, assetReferenceFilter: string | null | undefined, leaseAgreementTitleFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetLeaseItemForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/LeaseItems/GetAll?";
        if (leaseAgreementId !== undefined)
            url_ += "LeaseAgreementId=" + encodeURIComponent("" + leaseAgreementId) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxDateAllocatedFilter !== undefined)
            url_ += "MaxDateAllocatedFilter=" + encodeURIComponent(maxDateAllocatedFilter ? "" + maxDateAllocatedFilter.toJSON() : "") + "&"; 
        if (minDateAllocatedFilter !== undefined)
            url_ += "MinDateAllocatedFilter=" + encodeURIComponent(minDateAllocatedFilter ? "" + minDateAllocatedFilter.toJSON() : "") + "&"; 
        if (maxAllocationPercentageFilter !== undefined)
            url_ += "MaxAllocationPercentageFilter=" + encodeURIComponent("" + maxAllocationPercentageFilter) + "&"; 
        if (minAllocationPercentageFilter !== undefined)
            url_ += "MinAllocationPercentageFilter=" + encodeURIComponent("" + minAllocationPercentageFilter) + "&"; 
        if (termsFilter !== undefined)
            url_ += "TermsFilter=" + encodeURIComponent("" + termsFilter) + "&"; 
        if (maxUnitRentalRateFilter !== undefined)
            url_ += "MaxUnitRentalRateFilter=" + encodeURIComponent("" + maxUnitRentalRateFilter) + "&"; 
        if (minUnitRentalRateFilter !== undefined)
            url_ += "MinUnitRentalRateFilter=" + encodeURIComponent("" + minUnitRentalRateFilter) + "&"; 
        if (maxUnitDepositRateFilter !== undefined)
            url_ += "MaxUnitDepositRateFilter=" + encodeURIComponent("" + maxUnitDepositRateFilter) + "&"; 
        if (minUnitDepositRateFilter !== undefined)
            url_ += "MinUnitDepositRateFilter=" + encodeURIComponent("" + minUnitDepositRateFilter) + "&"; 
        if (maxStartDateFilter !== undefined)
            url_ += "MaxStartDateFilter=" + encodeURIComponent(maxStartDateFilter ? "" + maxStartDateFilter.toJSON() : "") + "&"; 
        if (minStartDateFilter !== undefined)
            url_ += "MinStartDateFilter=" + encodeURIComponent(minStartDateFilter ? "" + minStartDateFilter.toJSON() : "") + "&"; 
        if (maxEndDateFilter !== undefined)
            url_ += "MaxEndDateFilter=" + encodeURIComponent(maxEndDateFilter ? "" + maxEndDateFilter.toJSON() : "") + "&"; 
        if (minEndDateFilter !== undefined)
            url_ += "MinEndDateFilter=" + encodeURIComponent(minEndDateFilter ? "" + minEndDateFilter.toJSON() : "") + "&"; 
        if (maxRentalUomRefIdFilter !== undefined)
            url_ += "MaxRentalUomRefIdFilter=" + encodeURIComponent("" + maxRentalUomRefIdFilter) + "&"; 
        if (minRentalUomRefIdFilter !== undefined)
            url_ += "MinRentalUomRefIdFilter=" + encodeURIComponent("" + minRentalUomRefIdFilter) + "&"; 
        if (maxDepositUomRefIdFilter !== undefined)
            url_ += "MaxDepositUomRefIdFilter=" + encodeURIComponent("" + maxDepositUomRefIdFilter) + "&"; 
        if (minDepositUomRefIdFilter !== undefined)
            url_ += "MinDepositUomRefIdFilter=" + encodeURIComponent("" + minDepositUomRefIdFilter) + "&"; 
        if (itemFilter !== undefined)
            url_ += "ItemFilter=" + encodeURIComponent("" + itemFilter) + "&"; 
        if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (assetClassClassFilter !== undefined)
            url_ += "AssetClassClassFilter=" + encodeURIComponent("" + assetClassClassFilter) + "&"; 
        if (assetReferenceFilter !== undefined)
            url_ += "AssetReferenceFilter=" + encodeURIComponent("" + assetReferenceFilter) + "&"; 
        if (leaseAgreementTitleFilter !== undefined)
            url_ += "LeaseAgreementTitleFilter=" + encodeURIComponent("" + leaseAgreementTitleFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetLeaseItemForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetLeaseItemForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetLeaseItemForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetLeaseItemForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetLeaseItemForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getLeaseItemForView(id: number | null | undefined): Observable<GetLeaseItemForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/LeaseItems/GetLeaseItemForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLeaseItemForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLeaseItemForView(<any>response_);
                } catch (e) {
                    return <Observable<GetLeaseItemForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLeaseItemForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLeaseItemForView(response: HttpResponseBase): Observable<GetLeaseItemForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetLeaseItemForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLeaseItemForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getLeaseItemForEdit(id: number | null | undefined): Observable<GetLeaseItemForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/LeaseItems/GetLeaseItemForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLeaseItemForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLeaseItemForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetLeaseItemForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLeaseItemForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetLeaseItemForEdit(response: HttpResponseBase): Observable<GetLeaseItemForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetLeaseItemForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLeaseItemForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditLeaseItemDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/LeaseItems/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/LeaseItems/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param maxDateAllocatedFilter (optional) 
     * @param minDateAllocatedFilter (optional) 
     * @param maxAllocationPercentageFilter (optional) 
     * @param minAllocationPercentageFilter (optional) 
     * @param termsFilter (optional) 
     * @param maxUnitRentalRateFilter (optional) 
     * @param minUnitRentalRateFilter (optional) 
     * @param maxUnitDepositRateFilter (optional) 
     * @param minUnitDepositRateFilter (optional) 
     * @param maxStartDateFilter (optional) 
     * @param minStartDateFilter (optional) 
     * @param maxEndDateFilter (optional) 
     * @param minEndDateFilter (optional) 
     * @param maxRentalUomRefIdFilter (optional) 
     * @param minRentalUomRefIdFilter (optional) 
     * @param maxDepositUomRefIdFilter (optional) 
     * @param minDepositUomRefIdFilter (optional) 
     * @param itemFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param assetClassClassFilter (optional) 
     * @param assetReferenceFilter (optional) 
     * @param leaseAgreementTitleFilter (optional) 
     * @return Success
     */
    getLeaseItemsToExcel(filter: string | null | undefined, maxDateAllocatedFilter: moment.Moment | null | undefined, minDateAllocatedFilter: moment.Moment | null | undefined, maxAllocationPercentageFilter: number | null | undefined, minAllocationPercentageFilter: number | null | undefined, termsFilter: string | null | undefined, maxUnitRentalRateFilter: number | null | undefined, minUnitRentalRateFilter: number | null | undefined, maxUnitDepositRateFilter: number | null | undefined, minUnitDepositRateFilter: number | null | undefined, maxStartDateFilter: moment.Moment | null | undefined, minStartDateFilter: moment.Moment | null | undefined, maxEndDateFilter: moment.Moment | null | undefined, minEndDateFilter: moment.Moment | null | undefined, maxRentalUomRefIdFilter: number | null | undefined, minRentalUomRefIdFilter: number | null | undefined, maxDepositUomRefIdFilter: number | null | undefined, minDepositUomRefIdFilter: number | null | undefined, itemFilter: string | null | undefined, descriptionFilter: string | null | undefined, assetClassClassFilter: string | null | undefined, assetReferenceFilter: string | null | undefined, leaseAgreementTitleFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/LeaseItems/GetLeaseItemsToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (maxDateAllocatedFilter !== undefined)
            url_ += "MaxDateAllocatedFilter=" + encodeURIComponent(maxDateAllocatedFilter ? "" + maxDateAllocatedFilter.toJSON() : "") + "&"; 
        if (minDateAllocatedFilter !== undefined)
            url_ += "MinDateAllocatedFilter=" + encodeURIComponent(minDateAllocatedFilter ? "" + minDateAllocatedFilter.toJSON() : "") + "&"; 
        if (maxAllocationPercentageFilter !== undefined)
            url_ += "MaxAllocationPercentageFilter=" + encodeURIComponent("" + maxAllocationPercentageFilter) + "&"; 
        if (minAllocationPercentageFilter !== undefined)
            url_ += "MinAllocationPercentageFilter=" + encodeURIComponent("" + minAllocationPercentageFilter) + "&"; 
        if (termsFilter !== undefined)
            url_ += "TermsFilter=" + encodeURIComponent("" + termsFilter) + "&"; 
        if (maxUnitRentalRateFilter !== undefined)
            url_ += "MaxUnitRentalRateFilter=" + encodeURIComponent("" + maxUnitRentalRateFilter) + "&"; 
        if (minUnitRentalRateFilter !== undefined)
            url_ += "MinUnitRentalRateFilter=" + encodeURIComponent("" + minUnitRentalRateFilter) + "&"; 
        if (maxUnitDepositRateFilter !== undefined)
            url_ += "MaxUnitDepositRateFilter=" + encodeURIComponent("" + maxUnitDepositRateFilter) + "&"; 
        if (minUnitDepositRateFilter !== undefined)
            url_ += "MinUnitDepositRateFilter=" + encodeURIComponent("" + minUnitDepositRateFilter) + "&"; 
        if (maxStartDateFilter !== undefined)
            url_ += "MaxStartDateFilter=" + encodeURIComponent(maxStartDateFilter ? "" + maxStartDateFilter.toJSON() : "") + "&"; 
        if (minStartDateFilter !== undefined)
            url_ += "MinStartDateFilter=" + encodeURIComponent(minStartDateFilter ? "" + minStartDateFilter.toJSON() : "") + "&"; 
        if (maxEndDateFilter !== undefined)
            url_ += "MaxEndDateFilter=" + encodeURIComponent(maxEndDateFilter ? "" + maxEndDateFilter.toJSON() : "") + "&"; 
        if (minEndDateFilter !== undefined)
            url_ += "MinEndDateFilter=" + encodeURIComponent(minEndDateFilter ? "" + minEndDateFilter.toJSON() : "") + "&"; 
        if (maxRentalUomRefIdFilter !== undefined)
            url_ += "MaxRentalUomRefIdFilter=" + encodeURIComponent("" + maxRentalUomRefIdFilter) + "&"; 
        if (minRentalUomRefIdFilter !== undefined)
            url_ += "MinRentalUomRefIdFilter=" + encodeURIComponent("" + minRentalUomRefIdFilter) + "&"; 
        if (maxDepositUomRefIdFilter !== undefined)
            url_ += "MaxDepositUomRefIdFilter=" + encodeURIComponent("" + maxDepositUomRefIdFilter) + "&"; 
        if (minDepositUomRefIdFilter !== undefined)
            url_ += "MinDepositUomRefIdFilter=" + encodeURIComponent("" + minDepositUomRefIdFilter) + "&"; 
        if (itemFilter !== undefined)
            url_ += "ItemFilter=" + encodeURIComponent("" + itemFilter) + "&"; 
        if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (assetClassClassFilter !== undefined)
            url_ += "AssetClassClassFilter=" + encodeURIComponent("" + assetClassClassFilter) + "&"; 
        if (assetReferenceFilter !== undefined)
            url_ += "AssetReferenceFilter=" + encodeURIComponent("" + assetReferenceFilter) + "&"; 
        if (leaseAgreementTitleFilter !== undefined)
            url_ += "LeaseAgreementTitleFilter=" + encodeURIComponent("" + leaseAgreementTitleFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLeaseItemsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLeaseItemsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLeaseItemsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllAssetClassForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfLeaseItemAssetClassLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/LeaseItems/GetAllAssetClassForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAssetClassForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAssetClassForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfLeaseItemAssetClassLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfLeaseItemAssetClassLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAssetClassForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfLeaseItemAssetClassLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfLeaseItemAssetClassLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfLeaseItemAssetClassLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllAssetForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfLeaseItemAssetLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/LeaseItems/GetAllAssetForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAssetForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAssetForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfLeaseItemAssetLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfLeaseItemAssetLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAssetForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfLeaseItemAssetLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfLeaseItemAssetLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfLeaseItemAssetLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllLeaseAgreementForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfLeaseItemLeaseAgreementLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/LeaseItems/GetAllLeaseAgreementForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllLeaseAgreementForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllLeaseAgreementForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfLeaseItemLeaseAgreementLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfLeaseItemLeaseAgreementLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllLeaseAgreementForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfLeaseItemLeaseAgreementLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfLeaseItemLeaseAgreementLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfLeaseItemLeaseAgreementLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllUomForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfLeaseItemUomLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/LeaseItems/GetAllUomForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUomForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUomForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfLeaseItemUomLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfLeaseItemUomLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUomForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfLeaseItemUomLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfLeaseItemUomLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfLeaseItemUomLookupTableDto>(<any>null);
    }
}

@Injectable()
export class LocationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditLocationDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Location/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Location/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class LocationsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param locationNameFilter (optional) 
     * @param userNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, locationNameFilter: string | null | undefined, userNameFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetLocationForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Locations/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (locationNameFilter !== undefined)
            url_ += "LocationNameFilter=" + encodeURIComponent("" + locationNameFilter) + "&"; 
        if (userNameFilter !== undefined)
            url_ += "UserNameFilter=" + encodeURIComponent("" + userNameFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetLocationForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetLocationForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetLocationForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetLocationForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetLocationForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getLocationForView(id: number | null | undefined): Observable<GetLocationForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Locations/GetLocationForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLocationForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLocationForView(<any>response_);
                } catch (e) {
                    return <Observable<GetLocationForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLocationForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLocationForView(response: HttpResponseBase): Observable<GetLocationForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetLocationForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLocationForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getLocationForEdit(id: number | null | undefined): Observable<GetLocationForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Locations/GetLocationForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLocationForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLocationForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetLocationForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLocationForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetLocationForEdit(response: HttpResponseBase): Observable<GetLocationForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetLocationForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLocationForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditLocationDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Locations/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Locations/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param locationNameFilter (optional) 
     * @param userNameFilter (optional) 
     * @return Success
     */
    getLocationsToExcel(filter: string | null | undefined, locationNameFilter: string | null | undefined, userNameFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Locations/GetLocationsToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (locationNameFilter !== undefined)
            url_ += "LocationNameFilter=" + encodeURIComponent("" + locationNameFilter) + "&"; 
        if (userNameFilter !== undefined)
            url_ += "UserNameFilter=" + encodeURIComponent("" + userNameFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLocationsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLocationsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLocationsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class MaintenancePlansServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param subjectFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param remarksFilter (optional) 
     * @param workOrderPriorityPriorityFilter (optional) 
     * @param workOrderTypeTypeFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, subjectFilter: string | null | undefined, descriptionFilter: string | null | undefined, remarksFilter: string | null | undefined, workOrderPriorityPriorityFilter: string | null | undefined, workOrderTypeTypeFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetMaintenancePlanForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/MaintenancePlans/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (subjectFilter !== undefined)
            url_ += "SubjectFilter=" + encodeURIComponent("" + subjectFilter) + "&"; 
        if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (remarksFilter !== undefined)
            url_ += "RemarksFilter=" + encodeURIComponent("" + remarksFilter) + "&"; 
        if (workOrderPriorityPriorityFilter !== undefined)
            url_ += "WorkOrderPriorityPriorityFilter=" + encodeURIComponent("" + workOrderPriorityPriorityFilter) + "&"; 
        if (workOrderTypeTypeFilter !== undefined)
            url_ += "WorkOrderTypeTypeFilter=" + encodeURIComponent("" + workOrderTypeTypeFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetMaintenancePlanForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetMaintenancePlanForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetMaintenancePlanForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetMaintenancePlanForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetMaintenancePlanForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getMaintenancePlanForView(id: number | null | undefined): Observable<GetMaintenancePlanForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/MaintenancePlans/GetMaintenancePlanForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaintenancePlanForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaintenancePlanForView(<any>response_);
                } catch (e) {
                    return <Observable<GetMaintenancePlanForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetMaintenancePlanForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMaintenancePlanForView(response: HttpResponseBase): Observable<GetMaintenancePlanForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetMaintenancePlanForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetMaintenancePlanForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getMaintenancePlanForEdit(id: number | null | undefined): Observable<GetMaintenancePlanForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/MaintenancePlans/GetMaintenancePlanForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaintenancePlanForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaintenancePlanForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetMaintenancePlanForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetMaintenancePlanForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetMaintenancePlanForEdit(response: HttpResponseBase): Observable<GetMaintenancePlanForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetMaintenancePlanForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetMaintenancePlanForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditMaintenancePlanDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MaintenancePlans/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MaintenancePlans/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllWorkOrderPriorityForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfMaintenancePlanWorkOrderPriorityLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/MaintenancePlans/GetAllWorkOrderPriorityForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWorkOrderPriorityForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWorkOrderPriorityForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfMaintenancePlanWorkOrderPriorityLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfMaintenancePlanWorkOrderPriorityLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllWorkOrderPriorityForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfMaintenancePlanWorkOrderPriorityLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfMaintenancePlanWorkOrderPriorityLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfMaintenancePlanWorkOrderPriorityLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllWorkOrderTypeForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfMaintenancePlanWorkOrderTypeLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/MaintenancePlans/GetAllWorkOrderTypeForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWorkOrderTypeForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWorkOrderTypeForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfMaintenancePlanWorkOrderTypeLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfMaintenancePlanWorkOrderTypeLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllWorkOrderTypeForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfMaintenancePlanWorkOrderTypeLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfMaintenancePlanWorkOrderTypeLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfMaintenancePlanWorkOrderTypeLookupTableDto>(<any>null);
    }
}

@Injectable()
export class MaintenanceStepsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param maintenancePlanId (optional) 
     * @param filter (optional) 
     * @param commentsFilter (optional) 
     * @param maxQuantityFilter (optional) 
     * @param minQuantityFilter (optional) 
     * @param maxCostFilter (optional) 
     * @param minCostFilter (optional) 
     * @param maxPriceFilter (optional) 
     * @param minPriceFilter (optional) 
     * @param maintenancePlanSubjectFilter (optional) 
     * @param itemTypeTypeFilter (optional) 
     * @param workOrderActionActionFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(maintenancePlanId: number | null | undefined, filter: string | null | undefined, commentsFilter: string | null | undefined, maxQuantityFilter: number | null | undefined, minQuantityFilter: number | null | undefined, maxCostFilter: number | null | undefined, minCostFilter: number | null | undefined, maxPriceFilter: number | null | undefined, minPriceFilter: number | null | undefined, maintenancePlanSubjectFilter: string | null | undefined, itemTypeTypeFilter: string | null | undefined, workOrderActionActionFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetMaintenanceStepForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/MaintenanceSteps/GetAll?";
        if (maintenancePlanId !== undefined)
            url_ += "MaintenancePlanId=" + encodeURIComponent("" + maintenancePlanId) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (commentsFilter !== undefined)
            url_ += "CommentsFilter=" + encodeURIComponent("" + commentsFilter) + "&"; 
        if (maxQuantityFilter !== undefined)
            url_ += "MaxQuantityFilter=" + encodeURIComponent("" + maxQuantityFilter) + "&"; 
        if (minQuantityFilter !== undefined)
            url_ += "MinQuantityFilter=" + encodeURIComponent("" + minQuantityFilter) + "&"; 
        if (maxCostFilter !== undefined)
            url_ += "MaxCostFilter=" + encodeURIComponent("" + maxCostFilter) + "&"; 
        if (minCostFilter !== undefined)
            url_ += "MinCostFilter=" + encodeURIComponent("" + minCostFilter) + "&"; 
        if (maxPriceFilter !== undefined)
            url_ += "MaxPriceFilter=" + encodeURIComponent("" + maxPriceFilter) + "&"; 
        if (minPriceFilter !== undefined)
            url_ += "MinPriceFilter=" + encodeURIComponent("" + minPriceFilter) + "&"; 
        if (maintenancePlanSubjectFilter !== undefined)
            url_ += "MaintenancePlanSubjectFilter=" + encodeURIComponent("" + maintenancePlanSubjectFilter) + "&"; 
        if (itemTypeTypeFilter !== undefined)
            url_ += "ItemTypeTypeFilter=" + encodeURIComponent("" + itemTypeTypeFilter) + "&"; 
        if (workOrderActionActionFilter !== undefined)
            url_ += "WorkOrderActionActionFilter=" + encodeURIComponent("" + workOrderActionActionFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetMaintenanceStepForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetMaintenanceStepForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetMaintenanceStepForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetMaintenanceStepForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetMaintenanceStepForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getMaintenanceStepForView(id: number | null | undefined): Observable<GetMaintenanceStepForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/MaintenanceSteps/GetMaintenanceStepForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaintenanceStepForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaintenanceStepForView(<any>response_);
                } catch (e) {
                    return <Observable<GetMaintenanceStepForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetMaintenanceStepForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMaintenanceStepForView(response: HttpResponseBase): Observable<GetMaintenanceStepForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetMaintenanceStepForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetMaintenanceStepForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getMaintenanceStepForEdit(id: number | null | undefined): Observable<GetMaintenanceStepForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/MaintenanceSteps/GetMaintenanceStepForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaintenanceStepForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaintenanceStepForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetMaintenanceStepForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetMaintenanceStepForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetMaintenanceStepForEdit(response: HttpResponseBase): Observable<GetMaintenanceStepForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetMaintenanceStepForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetMaintenanceStepForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditMaintenanceStepDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MaintenanceSteps/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/MaintenanceSteps/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param commentsFilter (optional) 
     * @param maxQuantityFilter (optional) 
     * @param minQuantityFilter (optional) 
     * @param maxCostFilter (optional) 
     * @param minCostFilter (optional) 
     * @param maxPriceFilter (optional) 
     * @param minPriceFilter (optional) 
     * @param maintenancePlanSubjectFilter (optional) 
     * @param itemTypeTypeFilter (optional) 
     * @param workOrderActionActionFilter (optional) 
     * @return Success
     */
    getMaintenanceStepsToExcel(filter: string | null | undefined, commentsFilter: string | null | undefined, maxQuantityFilter: number | null | undefined, minQuantityFilter: number | null | undefined, maxCostFilter: number | null | undefined, minCostFilter: number | null | undefined, maxPriceFilter: number | null | undefined, minPriceFilter: number | null | undefined, maintenancePlanSubjectFilter: string | null | undefined, itemTypeTypeFilter: string | null | undefined, workOrderActionActionFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/MaintenanceSteps/GetMaintenanceStepsToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (commentsFilter !== undefined)
            url_ += "CommentsFilter=" + encodeURIComponent("" + commentsFilter) + "&"; 
        if (maxQuantityFilter !== undefined)
            url_ += "MaxQuantityFilter=" + encodeURIComponent("" + maxQuantityFilter) + "&"; 
        if (minQuantityFilter !== undefined)
            url_ += "MinQuantityFilter=" + encodeURIComponent("" + minQuantityFilter) + "&"; 
        if (maxCostFilter !== undefined)
            url_ += "MaxCostFilter=" + encodeURIComponent("" + maxCostFilter) + "&"; 
        if (minCostFilter !== undefined)
            url_ += "MinCostFilter=" + encodeURIComponent("" + minCostFilter) + "&"; 
        if (maxPriceFilter !== undefined)
            url_ += "MaxPriceFilter=" + encodeURIComponent("" + maxPriceFilter) + "&"; 
        if (minPriceFilter !== undefined)
            url_ += "MinPriceFilter=" + encodeURIComponent("" + minPriceFilter) + "&"; 
        if (maintenancePlanSubjectFilter !== undefined)
            url_ += "MaintenancePlanSubjectFilter=" + encodeURIComponent("" + maintenancePlanSubjectFilter) + "&"; 
        if (itemTypeTypeFilter !== undefined)
            url_ += "ItemTypeTypeFilter=" + encodeURIComponent("" + itemTypeTypeFilter) + "&"; 
        if (workOrderActionActionFilter !== undefined)
            url_ += "WorkOrderActionActionFilter=" + encodeURIComponent("" + workOrderActionActionFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMaintenanceStepsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMaintenanceStepsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetMaintenanceStepsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllMaintenancePlanForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfMaintenanceStepMaintenancePlanLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/MaintenanceSteps/GetAllMaintenancePlanForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllMaintenancePlanForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllMaintenancePlanForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfMaintenanceStepMaintenancePlanLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfMaintenanceStepMaintenancePlanLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllMaintenancePlanForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfMaintenanceStepMaintenancePlanLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfMaintenanceStepMaintenancePlanLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfMaintenanceStepMaintenancePlanLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllItemTypeForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfMaintenanceStepItemTypeLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/MaintenanceSteps/GetAllItemTypeForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllItemTypeForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllItemTypeForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfMaintenanceStepItemTypeLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfMaintenanceStepItemTypeLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllItemTypeForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfMaintenanceStepItemTypeLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfMaintenanceStepItemTypeLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfMaintenanceStepItemTypeLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllWorkOrderActionForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfMaintenanceStepWorkOrderActionLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/MaintenanceSteps/GetAllWorkOrderActionForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWorkOrderActionForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWorkOrderActionForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfMaintenanceStepWorkOrderActionLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfMaintenanceStepWorkOrderActionLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllWorkOrderActionForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfMaintenanceStepWorkOrderActionLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfMaintenanceStepWorkOrderActionLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfMaintenanceStepWorkOrderActionLookupTableDto>(<any>null);
    }
}

@Injectable()
export class NotificationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param state (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getUserNotifications(state: UserNotificationState | null | undefined, startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<GetNotificationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Notification/GetUserNotifications?";
        if (state !== undefined)
            url_ += "State=" + encodeURIComponent("" + state) + "&"; 
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserNotifications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserNotifications(<any>response_);
                } catch (e) {
                    return <Observable<GetNotificationsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetNotificationsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserNotifications(response: HttpResponseBase): Observable<GetNotificationsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetNotificationsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetNotificationsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    setAllNotificationsAsRead(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/SetAllNotificationsAsRead";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetAllNotificationsAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetAllNotificationsAsRead(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetAllNotificationsAsRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    setNotificationAsRead(input: EntityDtoOfGuid | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/SetNotificationAsRead";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetNotificationAsRead(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetNotificationAsRead(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSetNotificationAsRead(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getNotificationSettings(): Observable<GetNotificationSettingsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Notification/GetNotificationSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNotificationSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNotificationSettings(<any>response_);
                } catch (e) {
                    return <Observable<GetNotificationSettingsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetNotificationSettingsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetNotificationSettings(response: HttpResponseBase): Observable<GetNotificationSettingsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetNotificationSettingsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetNotificationSettingsOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateNotificationSettings(input: UpdateNotificationSettingsInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/UpdateNotificationSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateNotificationSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateNotificationSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateNotificationSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteNotification(id: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/DeleteNotification?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteNotification(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteNotification(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param state (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @return Success
     */
    deleteAllUserNotifications(state: UserNotificationState | null | undefined, startDate: moment.Moment | null | undefined, endDate: moment.Moment | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Notification/DeleteAllUserNotifications?";
        if (state !== undefined)
            url_ += "State=" + encodeURIComponent("" + state) + "&"; 
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAllUserNotifications(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAllUserNotifications(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAllUserNotifications(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class OrganizationUnitServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getOrganizationUnits(): Observable<ListResultDtoOfOrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetOrganizationUnits";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnits(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfOrganizationUnitDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfOrganizationUnitDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationUnits(response: HttpResponseBase): Observable<ListResultDtoOfOrganizationUnitDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfOrganizationUnitDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfOrganizationUnitDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getOrganizationUnitUsers(id: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfOrganizationUnitUserListDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetOrganizationUnitUsers?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnitUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnitUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfOrganizationUnitUserListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfOrganizationUnitUserListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationUnitUsers(response: HttpResponseBase): Observable<PagedResultDtoOfOrganizationUnitUserListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfOrganizationUnitUserListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfOrganizationUnitUserListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getOrganizationUnitRoles(id: number | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfOrganizationUnitRoleListDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/GetOrganizationUnitRoles?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOrganizationUnitRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrganizationUnitRoles(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfOrganizationUnitRoleListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfOrganizationUnitRoleListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrganizationUnitRoles(response: HttpResponseBase): Observable<PagedResultDtoOfOrganizationUnitRoleListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfOrganizationUnitRoleListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfOrganizationUnitRoleListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrganizationUnit(input: CreateOrganizationUnitInput | null | undefined): Observable<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/CreateOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrganizationUnit(response: HttpResponseBase): Observable<OrganizationUnitDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrganizationUnitDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateOrganizationUnit(input: UpdateOrganizationUnitInput | null | undefined): Observable<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/UpdateOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitDto>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOrganizationUnit(response: HttpResponseBase): Observable<OrganizationUnitDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrganizationUnitDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    moveOrganizationUnit(input: MoveOrganizationUnitInput | null | undefined): Observable<OrganizationUnitDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/MoveOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMoveOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMoveOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationUnitDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<OrganizationUnitDto>><any>_observableThrow(response_);
        }));
    }

    protected processMoveOrganizationUnit(response: HttpResponseBase): Observable<OrganizationUnitDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = OrganizationUnitDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OrganizationUnitDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteOrganizationUnit(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/DeleteOrganizationUnit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param userId (optional) 
     * @param organizationUnitId (optional) 
     * @return Success
     */
    removeUserFromOrganizationUnit(userId: number | null | undefined, organizationUnitId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/RemoveUserFromOrganizationUnit?";
        if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&"; 
        if (organizationUnitId !== undefined)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveUserFromOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveUserFromOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveUserFromOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param roleId (optional) 
     * @param organizationUnitId (optional) 
     * @return Success
     */
    removeRoleFromOrganizationUnit(roleId: number | null | undefined, organizationUnitId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/RemoveRoleFromOrganizationUnit?";
        if (roleId !== undefined)
            url_ += "RoleId=" + encodeURIComponent("" + roleId) + "&"; 
        if (organizationUnitId !== undefined)
            url_ += "OrganizationUnitId=" + encodeURIComponent("" + organizationUnitId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveRoleFromOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveRoleFromOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveRoleFromOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    addUsersToOrganizationUnit(input: UsersToOrganizationUnitInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/AddUsersToOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUsersToOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUsersToOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddUsersToOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    addRolesToOrganizationUnit(input: RolesToOrganizationUnitInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/AddRolesToOrganizationUnit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddRolesToOrganizationUnit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddRolesToOrganizationUnit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddRolesToOrganizationUnit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    findUsers(input: FindOrganizationUnitUsersInput | null | undefined): Observable<PagedResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/FindUsers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processFindUsers(response: HttpResponseBase): Observable<PagedResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfNameValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfNameValueDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    findRoles(input: FindOrganizationUnitRolesInput | null | undefined): Observable<PagedResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/OrganizationUnit/FindRoles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindRoles(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfNameValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processFindRoles(response: HttpResponseBase): Observable<PagedResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfNameValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfNameValueDto>(<any>null);
    }
}

@Injectable()
export class PaymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param upgradeEditionId (optional) 
     * @return Success
     */
    getPaymentInfo(upgradeEditionId: number | null | undefined): Observable<PaymentInfoDto> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetPaymentInfo?";
        if (upgradeEditionId !== undefined)
            url_ += "UpgradeEditionId=" + encodeURIComponent("" + upgradeEditionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentInfo(<any>response_);
                } catch (e) {
                    return <Observable<PaymentInfoDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaymentInfoDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaymentInfo(response: HttpResponseBase): Observable<PaymentInfoDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PaymentInfoDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentInfoDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createPayment(input: CreatePaymentDto | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/Payment/CreatePayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePayment(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreatePayment(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    cancelPayment(input: CancelPaymentDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/CancelPayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelPayment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCancelPayment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getPaymentHistory(sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfSubscriptionPaymentListDto> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetPaymentHistory?";
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaymentHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaymentHistory(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSubscriptionPaymentListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfSubscriptionPaymentListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaymentHistory(response: HttpResponseBase): Observable<PagedResultDtoOfSubscriptionPaymentListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfSubscriptionPaymentListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSubscriptionPaymentListDto>(<any>null);
    }

    /**
     * @param recurringPaymentsEnabled (optional) 
     * @return Success
     */
    getActiveGateways(recurringPaymentsEnabled: boolean | null | undefined): Observable<PaymentGatewayModel[]> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetActiveGateways?";
        if (recurringPaymentsEnabled !== undefined)
            url_ += "RecurringPaymentsEnabled=" + encodeURIComponent("" + recurringPaymentsEnabled) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActiveGateways(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActiveGateways(<any>response_);
                } catch (e) {
                    return <Observable<PaymentGatewayModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PaymentGatewayModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetActiveGateways(response: HttpResponseBase): Observable<PaymentGatewayModel[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(PaymentGatewayModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PaymentGatewayModel[]>(<any>null);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    getPayment(paymentId: number | null | undefined): Observable<SubscriptionPaymentDto> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetPaymentAsync?";
        if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPayment(<any>response_);
                } catch (e) {
                    return <Observable<SubscriptionPaymentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubscriptionPaymentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPayment(response: HttpResponseBase): Observable<SubscriptionPaymentDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubscriptionPaymentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubscriptionPaymentDto>(<any>null);
    }

    /**
     * @return Success
     */
    getLastCompletedPayment(): Observable<SubscriptionPaymentDto> {
        let url_ = this.baseUrl + "/api/services/app/Payment/GetLastCompletedPayment";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLastCompletedPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLastCompletedPayment(<any>response_);
                } catch (e) {
                    return <Observable<SubscriptionPaymentDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubscriptionPaymentDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLastCompletedPayment(response: HttpResponseBase): Observable<SubscriptionPaymentDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubscriptionPaymentDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubscriptionPaymentDto>(<any>null);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    buyNowSucceed(paymentId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/BuyNowSucceed?";
        if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBuyNowSucceed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBuyNowSucceed(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processBuyNowSucceed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    newRegistrationSucceed(paymentId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/NewRegistrationSucceed?";
        if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processNewRegistrationSucceed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processNewRegistrationSucceed(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processNewRegistrationSucceed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    upgradeSucceed(paymentId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/UpgradeSucceed?";
        if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpgradeSucceed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpgradeSucceed(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpgradeSucceed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    extendSucceed(paymentId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/ExtendSucceed?";
        if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExtendSucceed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExtendSucceed(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processExtendSucceed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param paymentId (optional) 
     * @return Success
     */
    paymentFailed(paymentId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Payment/PaymentFailed?";
        if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPaymentFailed(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPaymentFailed(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPaymentFailed(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class PayPalPaymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param paymentId (optional) 
     * @param paypalOrderId (optional) 
     * @return Success
     */
    confirmPayment(paymentId: number | null | undefined, paypalOrderId: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/PayPalPayment/ConfirmPayment?";
        if (paymentId !== undefined)
            url_ += "paymentId=" + encodeURIComponent("" + paymentId) + "&"; 
        if (paypalOrderId !== undefined)
            url_ += "paypalOrderId=" + encodeURIComponent("" + paypalOrderId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmPayment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processConfirmPayment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getConfiguration(): Observable<PayPalConfigurationDto> {
        let url_ = this.baseUrl + "/api/services/app/PayPalPayment/GetConfiguration";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConfiguration(<any>response_);
                } catch (e) {
                    return <Observable<PayPalConfigurationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PayPalConfigurationDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetConfiguration(response: HttpResponseBase): Observable<PayPalConfigurationDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PayPalConfigurationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PayPalConfigurationDto>(<any>null);
    }
}

@Injectable()
export class PermissionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllPermissions(): Observable<ListResultDtoOfFlatPermissionWithLevelDto> {
        let url_ = this.baseUrl + "/api/services/app/Permission/GetAllPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPermissions(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfFlatPermissionWithLevelDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfFlatPermissionWithLevelDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPermissions(response: HttpResponseBase): Observable<ListResultDtoOfFlatPermissionWithLevelDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfFlatPermissionWithLevelDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfFlatPermissionWithLevelDto>(<any>null);
    }
}

@Injectable()
export class ProfileServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentUserProfileForEdit(): Observable<CurrentUserProfileEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetCurrentUserProfileForEdit";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentUserProfileForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentUserProfileForEdit(<any>response_);
                } catch (e) {
                    return <Observable<CurrentUserProfileEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<CurrentUserProfileEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrentUserProfileForEdit(response: HttpResponseBase): Observable<CurrentUserProfileEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CurrentUserProfileEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CurrentUserProfileEditDto>(<any>null);
    }

    /**
     * @return Success
     */
    disableGoogleAuthenticator(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/DisableGoogleAuthenticator";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDisableGoogleAuthenticator(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisableGoogleAuthenticator(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDisableGoogleAuthenticator(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    updateGoogleAuthenticatorKey(): Observable<UpdateGoogleAuthenticatorKeyOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/UpdateGoogleAuthenticatorKey";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateGoogleAuthenticatorKey(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateGoogleAuthenticatorKey(<any>response_);
                } catch (e) {
                    return <Observable<UpdateGoogleAuthenticatorKeyOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<UpdateGoogleAuthenticatorKeyOutput>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateGoogleAuthenticatorKey(response: HttpResponseBase): Observable<UpdateGoogleAuthenticatorKeyOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateGoogleAuthenticatorKeyOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpdateGoogleAuthenticatorKeyOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    sendVerificationSms(input: SendVerificationSmsInputDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/SendVerificationSms";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendVerificationSms(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendVerificationSms(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendVerificationSms(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    verifySmsCode(input: VerifySmsCodeInputDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/VerifySmsCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerifySmsCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerifySmsCode(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processVerifySmsCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    prepareCollectedData(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/PrepareCollectedData";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPrepareCollectedData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPrepareCollectedData(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processPrepareCollectedData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateCurrentUserProfile(input: CurrentUserProfileEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/UpdateCurrentUserProfile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCurrentUserProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCurrentUserProfile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCurrentUserProfile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    changePassword(input: ChangePasswordInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/ChangePassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangePassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangePassword(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangePassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateProfilePicture(input: UpdateProfilePictureInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/UpdateProfilePicture";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateProfilePicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateProfilePicture(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateProfilePicture(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getPasswordComplexitySetting(): Observable<GetPasswordComplexitySettingOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetPasswordComplexitySetting";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPasswordComplexitySetting(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPasswordComplexitySetting(<any>response_);
                } catch (e) {
                    return <Observable<GetPasswordComplexitySettingOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetPasswordComplexitySettingOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetPasswordComplexitySetting(response: HttpResponseBase): Observable<GetPasswordComplexitySettingOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetPasswordComplexitySettingOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetPasswordComplexitySettingOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getProfilePicture(): Observable<GetProfilePictureOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetProfilePicture";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfilePicture(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfilePicture(<any>response_);
                } catch (e) {
                    return <Observable<GetProfilePictureOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProfilePictureOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetProfilePicture(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProfilePictureOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProfilePictureOutput>(<any>null);
    }

    /**
     * @param profilePictureId (optional) 
     * @param userId (optional) 
     * @param tenantId (optional) 
     * @return Success
     */
    getFriendProfilePictureById(profilePictureId: string | null | undefined, userId: number | null | undefined, tenantId: number | null | undefined): Observable<GetProfilePictureOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetFriendProfilePictureById?";
        if (profilePictureId !== undefined)
            url_ += "ProfilePictureId=" + encodeURIComponent("" + profilePictureId) + "&"; 
        if (userId !== undefined)
            url_ += "UserId=" + encodeURIComponent("" + userId) + "&"; 
        if (tenantId !== undefined)
            url_ += "TenantId=" + encodeURIComponent("" + tenantId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFriendProfilePictureById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFriendProfilePictureById(<any>response_);
                } catch (e) {
                    return <Observable<GetProfilePictureOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProfilePictureOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetFriendProfilePictureById(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProfilePictureOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProfilePictureOutput>(<any>null);
    }

    /**
     * @param profilePictureId (optional) 
     * @return Success
     */
    getProfilePictureById(profilePictureId: string | null | undefined): Observable<GetProfilePictureOutput> {
        let url_ = this.baseUrl + "/api/services/app/Profile/GetProfilePictureById?";
        if (profilePictureId !== undefined)
            url_ += "profilePictureId=" + encodeURIComponent("" + profilePictureId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfilePictureById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfilePictureById(<any>response_);
                } catch (e) {
                    return <Observable<GetProfilePictureOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetProfilePictureOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetProfilePictureById(response: HttpResponseBase): Observable<GetProfilePictureOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetProfilePictureOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetProfilePictureOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    changeLanguage(input: ChangeUserLanguageDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Profile/ChangeLanguage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeLanguage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeLanguage(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeLanguage(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class QuotationDetailsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param quotationId (optional) 
     * @param filter (optional) 
     * @param descriptionFilter (optional) 
     * @param loc8GUIDFilter (optional) 
     * @param assetReferenceFilter (optional) 
     * @param assetClassClassFilter (optional) 
     * @param itemTypeTypeFilter (optional) 
     * @param supportTypeTypeFilter (optional) 
     * @param quotationTitleFilter (optional) 
     * @param uomUnitOfMeasurementFilter (optional) 
     * @param supportItemDescriptionFilter (optional) 
     * @param workOrderSubjectFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(quotationId: number | null | undefined, filter: string | null | undefined, descriptionFilter: string | null | undefined, loc8GUIDFilter: string | null | undefined, assetReferenceFilter: string | null | undefined, assetClassClassFilter: string | null | undefined, itemTypeTypeFilter: string | null | undefined, supportTypeTypeFilter: string | null | undefined, quotationTitleFilter: string | null | undefined, uomUnitOfMeasurementFilter: string | null | undefined, supportItemDescriptionFilter: string | null | undefined, workOrderSubjectFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetQuotationDetailForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/QuotationDetails/GetAll?";
        if (quotationId !== undefined)
            url_ += "QuotationId=" + encodeURIComponent("" + quotationId) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (loc8GUIDFilter !== undefined)
            url_ += "Loc8GUIDFilter=" + encodeURIComponent("" + loc8GUIDFilter) + "&"; 
        if (assetReferenceFilter !== undefined)
            url_ += "AssetReferenceFilter=" + encodeURIComponent("" + assetReferenceFilter) + "&"; 
        if (assetClassClassFilter !== undefined)
            url_ += "AssetClassClassFilter=" + encodeURIComponent("" + assetClassClassFilter) + "&"; 
        if (itemTypeTypeFilter !== undefined)
            url_ += "ItemTypeTypeFilter=" + encodeURIComponent("" + itemTypeTypeFilter) + "&"; 
        if (supportTypeTypeFilter !== undefined)
            url_ += "SupportTypeTypeFilter=" + encodeURIComponent("" + supportTypeTypeFilter) + "&"; 
        if (quotationTitleFilter !== undefined)
            url_ += "QuotationTitleFilter=" + encodeURIComponent("" + quotationTitleFilter) + "&"; 
        if (uomUnitOfMeasurementFilter !== undefined)
            url_ += "UomUnitOfMeasurementFilter=" + encodeURIComponent("" + uomUnitOfMeasurementFilter) + "&"; 
        if (supportItemDescriptionFilter !== undefined)
            url_ += "SupportItemDescriptionFilter=" + encodeURIComponent("" + supportItemDescriptionFilter) + "&"; 
        if (workOrderSubjectFilter !== undefined)
            url_ += "WorkOrderSubjectFilter=" + encodeURIComponent("" + workOrderSubjectFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetQuotationDetailForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetQuotationDetailForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetQuotationDetailForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetQuotationDetailForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetQuotationDetailForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getQuotationDetailForView(id: number | null | undefined): Observable<GetQuotationDetailForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/QuotationDetails/GetQuotationDetailForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQuotationDetailForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQuotationDetailForView(<any>response_);
                } catch (e) {
                    return <Observable<GetQuotationDetailForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetQuotationDetailForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetQuotationDetailForView(response: HttpResponseBase): Observable<GetQuotationDetailForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetQuotationDetailForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetQuotationDetailForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getQuotationDetailForEdit(id: number | null | undefined): Observable<GetQuotationDetailForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/QuotationDetails/GetQuotationDetailForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQuotationDetailForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQuotationDetailForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetQuotationDetailForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetQuotationDetailForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetQuotationDetailForEdit(response: HttpResponseBase): Observable<GetQuotationDetailForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetQuotationDetailForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetQuotationDetailForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditQuotationDetailDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/QuotationDetails/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/QuotationDetails/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param descriptionFilter (optional) 
     * @param loc8GUIDFilter (optional) 
     * @param assetReferenceFilter (optional) 
     * @param assetClassClassFilter (optional) 
     * @param itemTypeTypeFilter (optional) 
     * @param supportTypeTypeFilter (optional) 
     * @param quotationTitleFilter (optional) 
     * @param uomUnitOfMeasurementFilter (optional) 
     * @param supportItemDescriptionFilter (optional) 
     * @param workOrderSubjectFilter (optional) 
     * @return Success
     */
    getQuotationDetailsToExcel(filter: string | null | undefined, descriptionFilter: string | null | undefined, loc8GUIDFilter: string | null | undefined, assetReferenceFilter: string | null | undefined, assetClassClassFilter: string | null | undefined, itemTypeTypeFilter: string | null | undefined, supportTypeTypeFilter: string | null | undefined, quotationTitleFilter: string | null | undefined, uomUnitOfMeasurementFilter: string | null | undefined, supportItemDescriptionFilter: string | null | undefined, workOrderSubjectFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/QuotationDetails/GetQuotationDetailsToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (loc8GUIDFilter !== undefined)
            url_ += "Loc8GUIDFilter=" + encodeURIComponent("" + loc8GUIDFilter) + "&"; 
        if (assetReferenceFilter !== undefined)
            url_ += "AssetReferenceFilter=" + encodeURIComponent("" + assetReferenceFilter) + "&"; 
        if (assetClassClassFilter !== undefined)
            url_ += "AssetClassClassFilter=" + encodeURIComponent("" + assetClassClassFilter) + "&"; 
        if (itemTypeTypeFilter !== undefined)
            url_ += "ItemTypeTypeFilter=" + encodeURIComponent("" + itemTypeTypeFilter) + "&"; 
        if (supportTypeTypeFilter !== undefined)
            url_ += "SupportTypeTypeFilter=" + encodeURIComponent("" + supportTypeTypeFilter) + "&"; 
        if (quotationTitleFilter !== undefined)
            url_ += "QuotationTitleFilter=" + encodeURIComponent("" + quotationTitleFilter) + "&"; 
        if (uomUnitOfMeasurementFilter !== undefined)
            url_ += "UomUnitOfMeasurementFilter=" + encodeURIComponent("" + uomUnitOfMeasurementFilter) + "&"; 
        if (supportItemDescriptionFilter !== undefined)
            url_ += "SupportItemDescriptionFilter=" + encodeURIComponent("" + supportItemDescriptionFilter) + "&"; 
        if (workOrderSubjectFilter !== undefined)
            url_ += "WorkOrderSubjectFilter=" + encodeURIComponent("" + workOrderSubjectFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQuotationDetailsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQuotationDetailsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetQuotationDetailsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllQuotationForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfQuotationDetailQuotationLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/QuotationDetails/GetAllQuotationForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllQuotationForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllQuotationForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfQuotationDetailQuotationLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfQuotationDetailQuotationLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllQuotationForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfQuotationDetailQuotationLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfQuotationDetailQuotationLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfQuotationDetailQuotationLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllWorkOrderForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfQuotationDetailWorkOrderLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/QuotationDetails/GetAllWorkOrderForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWorkOrderForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWorkOrderForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfQuotationDetailWorkOrderLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfQuotationDetailWorkOrderLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllWorkOrderForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfQuotationDetailWorkOrderLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfQuotationDetailWorkOrderLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfQuotationDetailWorkOrderLookupTableDto>(<any>null);
    }

    /**
     * @param quotationId (optional) 
     * @return Success
     */
    updateQuotationPrices(quotationId: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/QuotationDetails/UpdateQuotationPrices?";
        if (quotationId !== undefined)
            url_ += "quotationId=" + encodeURIComponent("" + quotationId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateQuotationPrices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateQuotationPrices(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateQuotationPrices(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param quotationId (optional) 
     * @return Success
     */
    getQuotationPDFInfo(quotationId: number | null | undefined): Observable<QuotationPdfDto> {
        let url_ = this.baseUrl + "/api/services/app/QuotationDetails/GetQuotationPDFInfo?";
        if (quotationId !== undefined)
            url_ += "quotationId=" + encodeURIComponent("" + quotationId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQuotationPDFInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQuotationPDFInfo(<any>response_);
                } catch (e) {
                    return <Observable<QuotationPdfDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<QuotationPdfDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetQuotationPDFInfo(response: HttpResponseBase): Observable<QuotationPdfDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QuotationPdfDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QuotationPdfDto>(<any>null);
    }
}

@Injectable()
export class QuotationsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param referenceFilter (optional) 
     * @param titleFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param maxStartDateFilter (optional) 
     * @param minStartDateFilter (optional) 
     * @param maxEndDateFilter (optional) 
     * @param minEndDateFilter (optional) 
     * @param isFinalFilter (optional) 
     * @param remarkFilter (optional) 
     * @param maxRequoteRefIdFilter (optional) 
     * @param minRequoteRefIdFilter (optional) 
     * @param quotationLoc8GUIDFilter (optional) 
     * @param acknowledgedByFilter (optional) 
     * @param maxAcknowledgedAtFilter (optional) 
     * @param minAcknowledgedAtFilter (optional) 
     * @param supportContractTitleFilter (optional) 
     * @param quotationStatusStatusFilter (optional) 
     * @param workOrderSubjectFilter (optional) 
     * @param assetReferenceFilter (optional) 
     * @param assetClassClassFilter (optional) 
     * @param supportTypeTypeFilter (optional) 
     * @param supportItemDescriptionFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, referenceFilter: string | null | undefined, titleFilter: string | null | undefined, descriptionFilter: string | null | undefined, maxStartDateFilter: moment.Moment | null | undefined, minStartDateFilter: moment.Moment | null | undefined, maxEndDateFilter: moment.Moment | null | undefined, minEndDateFilter: moment.Moment | null | undefined, isFinalFilter: number | null | undefined, remarkFilter: string | null | undefined, maxRequoteRefIdFilter: number | null | undefined, minRequoteRefIdFilter: number | null | undefined, quotationLoc8GUIDFilter: string | null | undefined, acknowledgedByFilter: string | null | undefined, maxAcknowledgedAtFilter: moment.Moment | null | undefined, minAcknowledgedAtFilter: moment.Moment | null | undefined, supportContractTitleFilter: string | null | undefined, quotationStatusStatusFilter: string | null | undefined, workOrderSubjectFilter: string | null | undefined, assetReferenceFilter: string | null | undefined, assetClassClassFilter: string | null | undefined, supportTypeTypeFilter: string | null | undefined, supportItemDescriptionFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetQuotationForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Quotations/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (referenceFilter !== undefined)
            url_ += "ReferenceFilter=" + encodeURIComponent("" + referenceFilter) + "&"; 
        if (titleFilter !== undefined)
            url_ += "TitleFilter=" + encodeURIComponent("" + titleFilter) + "&"; 
        if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (maxStartDateFilter !== undefined)
            url_ += "MaxStartDateFilter=" + encodeURIComponent(maxStartDateFilter ? "" + maxStartDateFilter.toJSON() : "") + "&"; 
        if (minStartDateFilter !== undefined)
            url_ += "MinStartDateFilter=" + encodeURIComponent(minStartDateFilter ? "" + minStartDateFilter.toJSON() : "") + "&"; 
        if (maxEndDateFilter !== undefined)
            url_ += "MaxEndDateFilter=" + encodeURIComponent(maxEndDateFilter ? "" + maxEndDateFilter.toJSON() : "") + "&"; 
        if (minEndDateFilter !== undefined)
            url_ += "MinEndDateFilter=" + encodeURIComponent(minEndDateFilter ? "" + minEndDateFilter.toJSON() : "") + "&"; 
        if (isFinalFilter !== undefined)
            url_ += "IsFinalFilter=" + encodeURIComponent("" + isFinalFilter) + "&"; 
        if (remarkFilter !== undefined)
            url_ += "RemarkFilter=" + encodeURIComponent("" + remarkFilter) + "&"; 
        if (maxRequoteRefIdFilter !== undefined)
            url_ += "MaxRequoteRefIdFilter=" + encodeURIComponent("" + maxRequoteRefIdFilter) + "&"; 
        if (minRequoteRefIdFilter !== undefined)
            url_ += "MinRequoteRefIdFilter=" + encodeURIComponent("" + minRequoteRefIdFilter) + "&"; 
        if (quotationLoc8GUIDFilter !== undefined)
            url_ += "QuotationLoc8GUIDFilter=" + encodeURIComponent("" + quotationLoc8GUIDFilter) + "&"; 
        if (acknowledgedByFilter !== undefined)
            url_ += "AcknowledgedByFilter=" + encodeURIComponent("" + acknowledgedByFilter) + "&"; 
        if (maxAcknowledgedAtFilter !== undefined)
            url_ += "MaxAcknowledgedAtFilter=" + encodeURIComponent(maxAcknowledgedAtFilter ? "" + maxAcknowledgedAtFilter.toJSON() : "") + "&"; 
        if (minAcknowledgedAtFilter !== undefined)
            url_ += "MinAcknowledgedAtFilter=" + encodeURIComponent(minAcknowledgedAtFilter ? "" + minAcknowledgedAtFilter.toJSON() : "") + "&"; 
        if (supportContractTitleFilter !== undefined)
            url_ += "SupportContractTitleFilter=" + encodeURIComponent("" + supportContractTitleFilter) + "&"; 
        if (quotationStatusStatusFilter !== undefined)
            url_ += "QuotationStatusStatusFilter=" + encodeURIComponent("" + quotationStatusStatusFilter) + "&"; 
        if (workOrderSubjectFilter !== undefined)
            url_ += "WorkOrderSubjectFilter=" + encodeURIComponent("" + workOrderSubjectFilter) + "&"; 
        if (assetReferenceFilter !== undefined)
            url_ += "AssetReferenceFilter=" + encodeURIComponent("" + assetReferenceFilter) + "&"; 
        if (assetClassClassFilter !== undefined)
            url_ += "AssetClassClassFilter=" + encodeURIComponent("" + assetClassClassFilter) + "&"; 
        if (supportTypeTypeFilter !== undefined)
            url_ += "SupportTypeTypeFilter=" + encodeURIComponent("" + supportTypeTypeFilter) + "&"; 
        if (supportItemDescriptionFilter !== undefined)
            url_ += "SupportItemDescriptionFilter=" + encodeURIComponent("" + supportItemDescriptionFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetQuotationForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetQuotationForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetQuotationForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetQuotationForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetQuotationForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getQuotationForView(id: number | null | undefined): Observable<GetQuotationForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Quotations/GetQuotationForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQuotationForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQuotationForView(<any>response_);
                } catch (e) {
                    return <Observable<GetQuotationForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetQuotationForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetQuotationForView(response: HttpResponseBase): Observable<GetQuotationForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetQuotationForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetQuotationForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getQuotationForEdit(id: number | null | undefined): Observable<GetQuotationForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Quotations/GetQuotationForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQuotationForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQuotationForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetQuotationForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetQuotationForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetQuotationForEdit(response: HttpResponseBase): Observable<GetQuotationForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetQuotationForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetQuotationForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditQuotationDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Quotations/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createWithDetail(input: CreateQuotationWithDetailDto | null | undefined): Observable<GetQuotationForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Quotations/CreateWithDetail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateWithDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateWithDetail(<any>response_);
                } catch (e) {
                    return <Observable<GetQuotationForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetQuotationForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processCreateWithDetail(response: HttpResponseBase): Observable<GetQuotationForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetQuotationForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetQuotationForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Quotations/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param referenceFilter (optional) 
     * @param titleFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param maxStartDateFilter (optional) 
     * @param minStartDateFilter (optional) 
     * @param maxEndDateFilter (optional) 
     * @param minEndDateFilter (optional) 
     * @param isFinalFilter (optional) 
     * @param remarkFilter (optional) 
     * @param maxRequoteRefIdFilter (optional) 
     * @param minRequoteRefIdFilter (optional) 
     * @param quotationLoc8GUIDFilter (optional) 
     * @param acknowledgedByFilter (optional) 
     * @param maxAcknowledgedAtFilter (optional) 
     * @param minAcknowledgedAtFilter (optional) 
     * @param supportContractTitleFilter (optional) 
     * @param quotationStatusStatusFilter (optional) 
     * @param workOrderSubjectFilter (optional) 
     * @param assetReferenceFilter (optional) 
     * @param assetClassClassFilter (optional) 
     * @param supportTypeTypeFilter (optional) 
     * @param supportItemDescriptionFilter (optional) 
     * @return Success
     */
    getQuotationsToExcel(filter: string | null | undefined, referenceFilter: string | null | undefined, titleFilter: string | null | undefined, descriptionFilter: string | null | undefined, maxStartDateFilter: moment.Moment | null | undefined, minStartDateFilter: moment.Moment | null | undefined, maxEndDateFilter: moment.Moment | null | undefined, minEndDateFilter: moment.Moment | null | undefined, isFinalFilter: number | null | undefined, remarkFilter: string | null | undefined, maxRequoteRefIdFilter: number | null | undefined, minRequoteRefIdFilter: number | null | undefined, quotationLoc8GUIDFilter: string | null | undefined, acknowledgedByFilter: string | null | undefined, maxAcknowledgedAtFilter: moment.Moment | null | undefined, minAcknowledgedAtFilter: moment.Moment | null | undefined, supportContractTitleFilter: string | null | undefined, quotationStatusStatusFilter: string | null | undefined, workOrderSubjectFilter: string | null | undefined, assetReferenceFilter: string | null | undefined, assetClassClassFilter: string | null | undefined, supportTypeTypeFilter: string | null | undefined, supportItemDescriptionFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Quotations/GetQuotationsToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (referenceFilter !== undefined)
            url_ += "ReferenceFilter=" + encodeURIComponent("" + referenceFilter) + "&"; 
        if (titleFilter !== undefined)
            url_ += "TitleFilter=" + encodeURIComponent("" + titleFilter) + "&"; 
        if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (maxStartDateFilter !== undefined)
            url_ += "MaxStartDateFilter=" + encodeURIComponent(maxStartDateFilter ? "" + maxStartDateFilter.toJSON() : "") + "&"; 
        if (minStartDateFilter !== undefined)
            url_ += "MinStartDateFilter=" + encodeURIComponent(minStartDateFilter ? "" + minStartDateFilter.toJSON() : "") + "&"; 
        if (maxEndDateFilter !== undefined)
            url_ += "MaxEndDateFilter=" + encodeURIComponent(maxEndDateFilter ? "" + maxEndDateFilter.toJSON() : "") + "&"; 
        if (minEndDateFilter !== undefined)
            url_ += "MinEndDateFilter=" + encodeURIComponent(minEndDateFilter ? "" + minEndDateFilter.toJSON() : "") + "&"; 
        if (isFinalFilter !== undefined)
            url_ += "IsFinalFilter=" + encodeURIComponent("" + isFinalFilter) + "&"; 
        if (remarkFilter !== undefined)
            url_ += "RemarkFilter=" + encodeURIComponent("" + remarkFilter) + "&"; 
        if (maxRequoteRefIdFilter !== undefined)
            url_ += "MaxRequoteRefIdFilter=" + encodeURIComponent("" + maxRequoteRefIdFilter) + "&"; 
        if (minRequoteRefIdFilter !== undefined)
            url_ += "MinRequoteRefIdFilter=" + encodeURIComponent("" + minRequoteRefIdFilter) + "&"; 
        if (quotationLoc8GUIDFilter !== undefined)
            url_ += "QuotationLoc8GUIDFilter=" + encodeURIComponent("" + quotationLoc8GUIDFilter) + "&"; 
        if (acknowledgedByFilter !== undefined)
            url_ += "AcknowledgedByFilter=" + encodeURIComponent("" + acknowledgedByFilter) + "&"; 
        if (maxAcknowledgedAtFilter !== undefined)
            url_ += "MaxAcknowledgedAtFilter=" + encodeURIComponent(maxAcknowledgedAtFilter ? "" + maxAcknowledgedAtFilter.toJSON() : "") + "&"; 
        if (minAcknowledgedAtFilter !== undefined)
            url_ += "MinAcknowledgedAtFilter=" + encodeURIComponent(minAcknowledgedAtFilter ? "" + minAcknowledgedAtFilter.toJSON() : "") + "&"; 
        if (supportContractTitleFilter !== undefined)
            url_ += "SupportContractTitleFilter=" + encodeURIComponent("" + supportContractTitleFilter) + "&"; 
        if (quotationStatusStatusFilter !== undefined)
            url_ += "QuotationStatusStatusFilter=" + encodeURIComponent("" + quotationStatusStatusFilter) + "&"; 
        if (workOrderSubjectFilter !== undefined)
            url_ += "WorkOrderSubjectFilter=" + encodeURIComponent("" + workOrderSubjectFilter) + "&"; 
        if (assetReferenceFilter !== undefined)
            url_ += "AssetReferenceFilter=" + encodeURIComponent("" + assetReferenceFilter) + "&"; 
        if (assetClassClassFilter !== undefined)
            url_ += "AssetClassClassFilter=" + encodeURIComponent("" + assetClassClassFilter) + "&"; 
        if (supportTypeTypeFilter !== undefined)
            url_ += "SupportTypeTypeFilter=" + encodeURIComponent("" + supportTypeTypeFilter) + "&"; 
        if (supportItemDescriptionFilter !== undefined)
            url_ += "SupportItemDescriptionFilter=" + encodeURIComponent("" + supportItemDescriptionFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQuotationsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQuotationsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetQuotationsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param filterId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllSupportContractForLookupTable(filter: string | null | undefined, filterId: number | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfQuotationSupportContractLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Quotations/GetAllSupportContractForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (filterId !== undefined)
            url_ += "FilterId=" + encodeURIComponent("" + filterId) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSupportContractForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSupportContractForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfQuotationSupportContractLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfQuotationSupportContractLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSupportContractForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfQuotationSupportContractLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfQuotationSupportContractLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfQuotationSupportContractLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllQuotationStatusForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfQuotationQuotationStatusLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Quotations/GetAllQuotationStatusForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllQuotationStatusForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllQuotationStatusForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfQuotationQuotationStatusLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfQuotationQuotationStatusLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllQuotationStatusForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfQuotationQuotationStatusLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfQuotationQuotationStatusLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfQuotationQuotationStatusLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllWorkOrderForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfQuotationWorkOrderLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Quotations/GetAllWorkOrderForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWorkOrderForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWorkOrderForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfQuotationWorkOrderLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfQuotationWorkOrderLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllWorkOrderForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfQuotationWorkOrderLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfQuotationWorkOrderLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfQuotationWorkOrderLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param filterId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllAssetForLookupTable(filter: string | null | undefined, filterId: number | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfQuotationAssetLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Quotations/GetAllAssetForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (filterId !== undefined)
            url_ += "FilterId=" + encodeURIComponent("" + filterId) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAssetForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAssetForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfQuotationAssetLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfQuotationAssetLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAssetForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfQuotationAssetLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfQuotationAssetLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfQuotationAssetLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param filterId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllAssetClassForLookupTable(filter: string | null | undefined, filterId: number | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfQuotationAssetClassLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Quotations/GetAllAssetClassForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (filterId !== undefined)
            url_ += "FilterId=" + encodeURIComponent("" + filterId) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAssetClassForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAssetClassForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfQuotationAssetClassLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfQuotationAssetClassLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAssetClassForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfQuotationAssetClassLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfQuotationAssetClassLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfQuotationAssetClassLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param filterId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllSupportTypeForLookupTable(filter: string | null | undefined, filterId: number | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfQuotationSupportTypeLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Quotations/GetAllSupportTypeForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (filterId !== undefined)
            url_ += "FilterId=" + encodeURIComponent("" + filterId) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSupportTypeForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSupportTypeForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfQuotationSupportTypeLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfQuotationSupportTypeLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSupportTypeForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfQuotationSupportTypeLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfQuotationSupportTypeLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfQuotationSupportTypeLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param filterId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllSupportItemForLookupTable(filter: string | null | undefined, filterId: number | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfQuotationSupportItemLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Quotations/GetAllSupportItemForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (filterId !== undefined)
            url_ += "FilterId=" + encodeURIComponent("" + filterId) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSupportItemForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSupportItemForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfQuotationSupportItemLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfQuotationSupportItemLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSupportItemForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfQuotationSupportItemLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfQuotationSupportItemLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfQuotationSupportItemLookupTableDto>(<any>null);
    }

    /**
     * @param workOrderId (optional) 
     * @param assetId (optional) 
     * @return Success
     */
    getQuotationAssetAndSupportItemList(workOrderId: number | null | undefined, assetId: number | null | undefined): Observable<QuotationAssetAndSupportItemListDto> {
        let url_ = this.baseUrl + "/api/services/app/Quotations/GetQuotationAssetAndSupportItemList?";
        if (workOrderId !== undefined)
            url_ += "workOrderId=" + encodeURIComponent("" + workOrderId) + "&"; 
        if (assetId !== undefined)
            url_ += "assetId=" + encodeURIComponent("" + assetId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQuotationAssetAndSupportItemList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQuotationAssetAndSupportItemList(<any>response_);
                } catch (e) {
                    return <Observable<QuotationAssetAndSupportItemListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<QuotationAssetAndSupportItemListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetQuotationAssetAndSupportItemList(response: HttpResponseBase): Observable<QuotationAssetAndSupportItemListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QuotationAssetAndSupportItemListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<QuotationAssetAndSupportItemListDto>(<any>null);
    }
}

@Injectable()
export class QuotationStatusesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetQuotationStatusForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/QuotationStatuses/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetQuotationStatusForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetQuotationStatusForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetQuotationStatusForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetQuotationStatusForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetQuotationStatusForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getQuotationStatusForView(id: number | null | undefined): Observable<GetQuotationStatusForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/QuotationStatuses/GetQuotationStatusForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQuotationStatusForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQuotationStatusForView(<any>response_);
                } catch (e) {
                    return <Observable<GetQuotationStatusForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetQuotationStatusForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetQuotationStatusForView(response: HttpResponseBase): Observable<GetQuotationStatusForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetQuotationStatusForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetQuotationStatusForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getQuotationStatusForEdit(id: number | null | undefined): Observable<GetQuotationStatusForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/QuotationStatuses/GetQuotationStatusForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQuotationStatusForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQuotationStatusForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetQuotationStatusForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetQuotationStatusForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetQuotationStatusForEdit(response: HttpResponseBase): Observable<GetQuotationStatusForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetQuotationStatusForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetQuotationStatusForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditQuotationStatusDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/QuotationStatuses/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/QuotationStatuses/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class RfqsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param titleFilter (optional) 
     * @param maxRequestDateFilter (optional) 
     * @param minRequestDateFilter (optional) 
     * @param maxRequiredByFilter (optional) 
     * @param minRequiredByFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param requirementsFilter (optional) 
     * @param rfqTypeTypeFilter (optional) 
     * @param assetOwnerNameFilter (optional) 
     * @param customerNameFilter (optional) 
     * @param assetClassClassFilter (optional) 
     * @param incidentDescriptionFilter (optional) 
     * @param vendorNameFilter (optional) 
     * @param userNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, titleFilter: string | null | undefined, maxRequestDateFilter: moment.Moment | null | undefined, minRequestDateFilter: moment.Moment | null | undefined, maxRequiredByFilter: moment.Moment | null | undefined, minRequiredByFilter: moment.Moment | null | undefined, descriptionFilter: string | null | undefined, requirementsFilter: string | null | undefined, rfqTypeTypeFilter: string | null | undefined, assetOwnerNameFilter: string | null | undefined, customerNameFilter: string | null | undefined, assetClassClassFilter: string | null | undefined, incidentDescriptionFilter: string | null | undefined, vendorNameFilter: string | null | undefined, userNameFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetRfqForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Rfqs/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (titleFilter !== undefined)
            url_ += "TitleFilter=" + encodeURIComponent("" + titleFilter) + "&"; 
        if (maxRequestDateFilter !== undefined)
            url_ += "MaxRequestDateFilter=" + encodeURIComponent(maxRequestDateFilter ? "" + maxRequestDateFilter.toJSON() : "") + "&"; 
        if (minRequestDateFilter !== undefined)
            url_ += "MinRequestDateFilter=" + encodeURIComponent(minRequestDateFilter ? "" + minRequestDateFilter.toJSON() : "") + "&"; 
        if (maxRequiredByFilter !== undefined)
            url_ += "MaxRequiredByFilter=" + encodeURIComponent(maxRequiredByFilter ? "" + maxRequiredByFilter.toJSON() : "") + "&"; 
        if (minRequiredByFilter !== undefined)
            url_ += "MinRequiredByFilter=" + encodeURIComponent(minRequiredByFilter ? "" + minRequiredByFilter.toJSON() : "") + "&"; 
        if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (requirementsFilter !== undefined)
            url_ += "RequirementsFilter=" + encodeURIComponent("" + requirementsFilter) + "&"; 
        if (rfqTypeTypeFilter !== undefined)
            url_ += "RfqTypeTypeFilter=" + encodeURIComponent("" + rfqTypeTypeFilter) + "&"; 
        if (assetOwnerNameFilter !== undefined)
            url_ += "AssetOwnerNameFilter=" + encodeURIComponent("" + assetOwnerNameFilter) + "&"; 
        if (customerNameFilter !== undefined)
            url_ += "CustomerNameFilter=" + encodeURIComponent("" + customerNameFilter) + "&"; 
        if (assetClassClassFilter !== undefined)
            url_ += "AssetClassClassFilter=" + encodeURIComponent("" + assetClassClassFilter) + "&"; 
        if (incidentDescriptionFilter !== undefined)
            url_ += "IncidentDescriptionFilter=" + encodeURIComponent("" + incidentDescriptionFilter) + "&"; 
        if (vendorNameFilter !== undefined)
            url_ += "VendorNameFilter=" + encodeURIComponent("" + vendorNameFilter) + "&"; 
        if (userNameFilter !== undefined)
            url_ += "UserNameFilter=" + encodeURIComponent("" + userNameFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetRfqForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetRfqForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetRfqForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetRfqForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetRfqForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRfqForView(id: number | null | undefined): Observable<GetRfqForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Rfqs/GetRfqForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRfqForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRfqForView(<any>response_);
                } catch (e) {
                    return <Observable<GetRfqForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRfqForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRfqForView(response: HttpResponseBase): Observable<GetRfqForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRfqForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRfqForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRfqForEdit(id: number | null | undefined): Observable<GetRfqForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Rfqs/GetRfqForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRfqForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRfqForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetRfqForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRfqForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRfqForEdit(response: HttpResponseBase): Observable<GetRfqForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRfqForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRfqForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditRfqDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Rfqs/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Rfqs/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param titleFilter (optional) 
     * @param maxRequestDateFilter (optional) 
     * @param minRequestDateFilter (optional) 
     * @param maxRequiredByFilter (optional) 
     * @param minRequiredByFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param requirementsFilter (optional) 
     * @param rfqTypeTypeFilter (optional) 
     * @param assetOwnerNameFilter (optional) 
     * @param customerNameFilter (optional) 
     * @param assetClassClassFilter (optional) 
     * @param incidentDescriptionFilter (optional) 
     * @param vendorNameFilter (optional) 
     * @param userNameFilter (optional) 
     * @return Success
     */
    getRfqsToExcel(filter: string | null | undefined, titleFilter: string | null | undefined, maxRequestDateFilter: moment.Moment | null | undefined, minRequestDateFilter: moment.Moment | null | undefined, maxRequiredByFilter: moment.Moment | null | undefined, minRequiredByFilter: moment.Moment | null | undefined, descriptionFilter: string | null | undefined, requirementsFilter: string | null | undefined, rfqTypeTypeFilter: string | null | undefined, assetOwnerNameFilter: string | null | undefined, customerNameFilter: string | null | undefined, assetClassClassFilter: string | null | undefined, incidentDescriptionFilter: string | null | undefined, vendorNameFilter: string | null | undefined, userNameFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Rfqs/GetRfqsToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (titleFilter !== undefined)
            url_ += "TitleFilter=" + encodeURIComponent("" + titleFilter) + "&"; 
        if (maxRequestDateFilter !== undefined)
            url_ += "MaxRequestDateFilter=" + encodeURIComponent(maxRequestDateFilter ? "" + maxRequestDateFilter.toJSON() : "") + "&"; 
        if (minRequestDateFilter !== undefined)
            url_ += "MinRequestDateFilter=" + encodeURIComponent(minRequestDateFilter ? "" + minRequestDateFilter.toJSON() : "") + "&"; 
        if (maxRequiredByFilter !== undefined)
            url_ += "MaxRequiredByFilter=" + encodeURIComponent(maxRequiredByFilter ? "" + maxRequiredByFilter.toJSON() : "") + "&"; 
        if (minRequiredByFilter !== undefined)
            url_ += "MinRequiredByFilter=" + encodeURIComponent(minRequiredByFilter ? "" + minRequiredByFilter.toJSON() : "") + "&"; 
        if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (requirementsFilter !== undefined)
            url_ += "RequirementsFilter=" + encodeURIComponent("" + requirementsFilter) + "&"; 
        if (rfqTypeTypeFilter !== undefined)
            url_ += "RfqTypeTypeFilter=" + encodeURIComponent("" + rfqTypeTypeFilter) + "&"; 
        if (assetOwnerNameFilter !== undefined)
            url_ += "AssetOwnerNameFilter=" + encodeURIComponent("" + assetOwnerNameFilter) + "&"; 
        if (customerNameFilter !== undefined)
            url_ += "CustomerNameFilter=" + encodeURIComponent("" + customerNameFilter) + "&"; 
        if (assetClassClassFilter !== undefined)
            url_ += "AssetClassClassFilter=" + encodeURIComponent("" + assetClassClassFilter) + "&"; 
        if (incidentDescriptionFilter !== undefined)
            url_ += "IncidentDescriptionFilter=" + encodeURIComponent("" + incidentDescriptionFilter) + "&"; 
        if (vendorNameFilter !== undefined)
            url_ += "VendorNameFilter=" + encodeURIComponent("" + vendorNameFilter) + "&"; 
        if (userNameFilter !== undefined)
            url_ += "UserNameFilter=" + encodeURIComponent("" + userNameFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRfqsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRfqsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRfqsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllRfqTypeForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfRfqRfqTypeLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Rfqs/GetAllRfqTypeForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRfqTypeForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRfqTypeForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfRfqRfqTypeLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfRfqRfqTypeLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllRfqTypeForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfRfqRfqTypeLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfRfqRfqTypeLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfRfqRfqTypeLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllAssetOwnerForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfRfqAssetOwnerLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Rfqs/GetAllAssetOwnerForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAssetOwnerForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAssetOwnerForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfRfqAssetOwnerLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfRfqAssetOwnerLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAssetOwnerForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfRfqAssetOwnerLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfRfqAssetOwnerLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfRfqAssetOwnerLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllCustomerForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfRfqCustomerLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Rfqs/GetAllCustomerForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCustomerForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCustomerForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfRfqCustomerLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfRfqCustomerLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCustomerForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfRfqCustomerLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfRfqCustomerLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfRfqCustomerLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllAssetClassForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfRfqAssetClassLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Rfqs/GetAllAssetClassForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAssetClassForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAssetClassForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfRfqAssetClassLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfRfqAssetClassLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAssetClassForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfRfqAssetClassLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfRfqAssetClassLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfRfqAssetClassLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllIncidentForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfRfqIncidentLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Rfqs/GetAllIncidentForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllIncidentForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllIncidentForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfRfqIncidentLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfRfqIncidentLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllIncidentForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfRfqIncidentLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfRfqIncidentLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfRfqIncidentLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllVendorForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfRfqVendorLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Rfqs/GetAllVendorForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllVendorForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllVendorForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfRfqVendorLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfRfqVendorLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllVendorForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfRfqVendorLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfRfqVendorLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfRfqVendorLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllUserForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfRfqUserLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Rfqs/GetAllUserForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfRfqUserLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfRfqUserLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUserForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfRfqUserLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfRfqUserLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfRfqUserLookupTableDto>(<any>null);
    }
}

@Injectable()
export class RfqTypesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetRfqTypeForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/RfqTypes/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetRfqTypeForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetRfqTypeForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetRfqTypeForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetRfqTypeForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetRfqTypeForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRfqTypeForView(id: number | null | undefined): Observable<GetRfqTypeForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/RfqTypes/GetRfqTypeForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRfqTypeForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRfqTypeForView(<any>response_);
                } catch (e) {
                    return <Observable<GetRfqTypeForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRfqTypeForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRfqTypeForView(response: HttpResponseBase): Observable<GetRfqTypeForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRfqTypeForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRfqTypeForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRfqTypeForEdit(id: number | null | undefined): Observable<GetRfqTypeForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/RfqTypes/GetRfqTypeForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRfqTypeForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRfqTypeForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetRfqTypeForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRfqTypeForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRfqTypeForEdit(response: HttpResponseBase): Observable<GetRfqTypeForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRfqTypeForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRfqTypeForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditRfqTypeDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RfqTypes/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/RfqTypes/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class RoleServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param permissions (optional) 
     * @return Success
     */
    getRoles(permissions: string[] | null | undefined): Observable<ListResultDtoOfRoleListDto> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoles?";
        if (permissions !== undefined)
            permissions && permissions.forEach(item => { url_ += "Permissions=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfRoleListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfRoleListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<ListResultDtoOfRoleListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfRoleListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfRoleListDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getRoleForEdit(id: number | null | undefined): Observable<GetRoleForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Role/GetRoleForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetRoleForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRoleForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoleForEdit(response: HttpResponseBase): Observable<GetRoleForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRoleForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRoleForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrUpdateRole(input: CreateOrUpdateRoleInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/CreateOrUpdateRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateRole(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateRole(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteRole(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Role/DeleteRole?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRole(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteRole(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class SessionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getCurrentLoginInformations(): Observable<GetCurrentLoginInformationsOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/GetCurrentLoginInformations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrentLoginInformations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrentLoginInformations(<any>response_);
                } catch (e) {
                    return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetCurrentLoginInformationsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrentLoginInformations(response: HttpResponseBase): Observable<GetCurrentLoginInformationsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetCurrentLoginInformationsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetCurrentLoginInformationsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    updateUserSignInToken(): Observable<UpdateUserSignInTokenOutput> {
        let url_ = this.baseUrl + "/api/services/app/Session/UpdateUserSignInToken";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserSignInToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserSignInToken(<any>response_);
                } catch (e) {
                    return <Observable<UpdateUserSignInTokenOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<UpdateUserSignInTokenOutput>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUserSignInToken(response: HttpResponseBase): Observable<UpdateUserSignInTokenOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UpdateUserSignInTokenOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UpdateUserSignInTokenOutput>(<any>null);
    }
}

@Injectable()
export class SsicCodesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param codeFilter (optional) 
     * @param sSICFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, codeFilter: string | null | undefined, sSICFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetSsicCodeForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SsicCodes/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (codeFilter !== undefined)
            url_ += "CodeFilter=" + encodeURIComponent("" + codeFilter) + "&"; 
        if (sSICFilter !== undefined)
            url_ += "SSICFilter=" + encodeURIComponent("" + sSICFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetSsicCodeForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetSsicCodeForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetSsicCodeForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetSsicCodeForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetSsicCodeForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSsicCodeForView(id: number | null | undefined): Observable<GetSsicCodeForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SsicCodes/GetSsicCodeForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSsicCodeForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSsicCodeForView(<any>response_);
                } catch (e) {
                    return <Observable<GetSsicCodeForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetSsicCodeForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSsicCodeForView(response: HttpResponseBase): Observable<GetSsicCodeForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSsicCodeForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSsicCodeForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSsicCodeForEdit(id: number | null | undefined): Observable<GetSsicCodeForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/SsicCodes/GetSsicCodeForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSsicCodeForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSsicCodeForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetSsicCodeForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetSsicCodeForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetSsicCodeForEdit(response: HttpResponseBase): Observable<GetSsicCodeForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSsicCodeForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSsicCodeForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditSsicCodeDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SsicCodes/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SsicCodes/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param codeFilter (optional) 
     * @param sSICFilter (optional) 
     * @return Success
     */
    getSsicCodesToExcel(filter: string | null | undefined, codeFilter: string | null | undefined, sSICFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/SsicCodes/GetSsicCodesToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (codeFilter !== undefined)
            url_ += "CodeFilter=" + encodeURIComponent("" + codeFilter) + "&"; 
        if (sSICFilter !== undefined)
            url_ += "SSICFilter=" + encodeURIComponent("" + sSICFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSsicCodesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSsicCodesToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSsicCodesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class StripePaymentServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    confirmPayment(input: StripeConfirmPaymentInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StripePayment/ConfirmPayment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processConfirmPayment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processConfirmPayment(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processConfirmPayment(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createSubscription(input: StripeCreateSubscriptionInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StripePayment/CreateSubscription";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateSubscription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateSubscription(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateSubscription(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateSubscription(input: StripeUpdateSubscriptionInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/StripePayment/UpdateSubscription";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateSubscription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateSubscription(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateSubscription(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    getConfiguration(): Observable<StripeConfigurationDto> {
        let url_ = this.baseUrl + "/api/services/app/StripePayment/GetConfiguration";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConfiguration(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConfiguration(<any>response_);
                } catch (e) {
                    return <Observable<StripeConfigurationDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<StripeConfigurationDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetConfiguration(response: HttpResponseBase): Observable<StripeConfigurationDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = StripeConfigurationDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StripeConfigurationDto>(<any>null);
    }
}

@Injectable()
export class SubscriptionServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    disableRecurringPayments(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Subscription/DisableRecurringPayments";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDisableRecurringPayments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDisableRecurringPayments(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDisableRecurringPayments(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    enableRecurringPayments(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Subscription/EnableRecurringPayments";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEnableRecurringPayments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEnableRecurringPayments(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processEnableRecurringPayments(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class SupportContractsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param titleFilter (optional) 
     * @param referenceFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param maxStartDateFilter (optional) 
     * @param minStartDateFilter (optional) 
     * @param maxEndDateFilter (optional) 
     * @param minEndDateFilter (optional) 
     * @param isRFQTemplateFilter (optional) 
     * @param isAcknowledgedFilter (optional) 
     * @param acknowledgedByFilter (optional) 
     * @param maxAcknowledgedAtFilter (optional) 
     * @param minAcknowledgedAtFilter (optional) 
     * @param vendorNameFilter (optional) 
     * @param assetOwnerNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, titleFilter: string | null | undefined, referenceFilter: string | null | undefined, descriptionFilter: string | null | undefined, maxStartDateFilter: moment.Moment | null | undefined, minStartDateFilter: moment.Moment | null | undefined, maxEndDateFilter: moment.Moment | null | undefined, minEndDateFilter: moment.Moment | null | undefined, isRFQTemplateFilter: number | null | undefined, isAcknowledgedFilter: number | null | undefined, acknowledgedByFilter: string | null | undefined, maxAcknowledgedAtFilter: moment.Moment | null | undefined, minAcknowledgedAtFilter: moment.Moment | null | undefined, vendorNameFilter: string | null | undefined, assetOwnerNameFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetSupportContractForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SupportContracts/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (titleFilter !== undefined)
            url_ += "TitleFilter=" + encodeURIComponent("" + titleFilter) + "&"; 
        if (referenceFilter !== undefined)
            url_ += "ReferenceFilter=" + encodeURIComponent("" + referenceFilter) + "&"; 
        if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (maxStartDateFilter !== undefined)
            url_ += "MaxStartDateFilter=" + encodeURIComponent(maxStartDateFilter ? "" + maxStartDateFilter.toJSON() : "") + "&"; 
        if (minStartDateFilter !== undefined)
            url_ += "MinStartDateFilter=" + encodeURIComponent(minStartDateFilter ? "" + minStartDateFilter.toJSON() : "") + "&"; 
        if (maxEndDateFilter !== undefined)
            url_ += "MaxEndDateFilter=" + encodeURIComponent(maxEndDateFilter ? "" + maxEndDateFilter.toJSON() : "") + "&"; 
        if (minEndDateFilter !== undefined)
            url_ += "MinEndDateFilter=" + encodeURIComponent(minEndDateFilter ? "" + minEndDateFilter.toJSON() : "") + "&"; 
        if (isRFQTemplateFilter !== undefined)
            url_ += "IsRFQTemplateFilter=" + encodeURIComponent("" + isRFQTemplateFilter) + "&"; 
        if (isAcknowledgedFilter !== undefined)
            url_ += "IsAcknowledgedFilter=" + encodeURIComponent("" + isAcknowledgedFilter) + "&"; 
        if (acknowledgedByFilter !== undefined)
            url_ += "AcknowledgedByFilter=" + encodeURIComponent("" + acknowledgedByFilter) + "&"; 
        if (maxAcknowledgedAtFilter !== undefined)
            url_ += "MaxAcknowledgedAtFilter=" + encodeURIComponent(maxAcknowledgedAtFilter ? "" + maxAcknowledgedAtFilter.toJSON() : "") + "&"; 
        if (minAcknowledgedAtFilter !== undefined)
            url_ += "MinAcknowledgedAtFilter=" + encodeURIComponent(minAcknowledgedAtFilter ? "" + minAcknowledgedAtFilter.toJSON() : "") + "&"; 
        if (vendorNameFilter !== undefined)
            url_ += "VendorNameFilter=" + encodeURIComponent("" + vendorNameFilter) + "&"; 
        if (assetOwnerNameFilter !== undefined)
            url_ += "AssetOwnerNameFilter=" + encodeURIComponent("" + assetOwnerNameFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetSupportContractForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetSupportContractForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetSupportContractForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetSupportContractForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetSupportContractForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSupportContractForView(id: number | null | undefined): Observable<GetSupportContractForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SupportContracts/GetSupportContractForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSupportContractForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSupportContractForView(<any>response_);
                } catch (e) {
                    return <Observable<GetSupportContractForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetSupportContractForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSupportContractForView(response: HttpResponseBase): Observable<GetSupportContractForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSupportContractForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSupportContractForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSupportContractForEdit(id: number | null | undefined): Observable<GetSupportContractForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/SupportContracts/GetSupportContractForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSupportContractForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSupportContractForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetSupportContractForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetSupportContractForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetSupportContractForEdit(response: HttpResponseBase): Observable<GetSupportContractForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSupportContractForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSupportContractForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditSupportContractDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SupportContracts/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SupportContracts/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param titleFilter (optional) 
     * @param referenceFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param maxStartDateFilter (optional) 
     * @param minStartDateFilter (optional) 
     * @param maxEndDateFilter (optional) 
     * @param minEndDateFilter (optional) 
     * @param isRFQTemplateFilter (optional) 
     * @param isAcknowledgedFilter (optional) 
     * @param acknowledgedByFilter (optional) 
     * @param maxAcknowledgedAtFilter (optional) 
     * @param minAcknowledgedAtFilter (optional) 
     * @param vendorNameFilter (optional) 
     * @param assetOwnerNameFilter (optional) 
     * @return Success
     */
    getSupportContractsToExcel(filter: string | null | undefined, titleFilter: string | null | undefined, referenceFilter: string | null | undefined, descriptionFilter: string | null | undefined, maxStartDateFilter: moment.Moment | null | undefined, minStartDateFilter: moment.Moment | null | undefined, maxEndDateFilter: moment.Moment | null | undefined, minEndDateFilter: moment.Moment | null | undefined, isRFQTemplateFilter: number | null | undefined, isAcknowledgedFilter: number | null | undefined, acknowledgedByFilter: string | null | undefined, maxAcknowledgedAtFilter: moment.Moment | null | undefined, minAcknowledgedAtFilter: moment.Moment | null | undefined, vendorNameFilter: string | null | undefined, assetOwnerNameFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/SupportContracts/GetSupportContractsToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (titleFilter !== undefined)
            url_ += "TitleFilter=" + encodeURIComponent("" + titleFilter) + "&"; 
        if (referenceFilter !== undefined)
            url_ += "ReferenceFilter=" + encodeURIComponent("" + referenceFilter) + "&"; 
        if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (maxStartDateFilter !== undefined)
            url_ += "MaxStartDateFilter=" + encodeURIComponent(maxStartDateFilter ? "" + maxStartDateFilter.toJSON() : "") + "&"; 
        if (minStartDateFilter !== undefined)
            url_ += "MinStartDateFilter=" + encodeURIComponent(minStartDateFilter ? "" + minStartDateFilter.toJSON() : "") + "&"; 
        if (maxEndDateFilter !== undefined)
            url_ += "MaxEndDateFilter=" + encodeURIComponent(maxEndDateFilter ? "" + maxEndDateFilter.toJSON() : "") + "&"; 
        if (minEndDateFilter !== undefined)
            url_ += "MinEndDateFilter=" + encodeURIComponent(minEndDateFilter ? "" + minEndDateFilter.toJSON() : "") + "&"; 
        if (isRFQTemplateFilter !== undefined)
            url_ += "IsRFQTemplateFilter=" + encodeURIComponent("" + isRFQTemplateFilter) + "&"; 
        if (isAcknowledgedFilter !== undefined)
            url_ += "IsAcknowledgedFilter=" + encodeURIComponent("" + isAcknowledgedFilter) + "&"; 
        if (acknowledgedByFilter !== undefined)
            url_ += "AcknowledgedByFilter=" + encodeURIComponent("" + acknowledgedByFilter) + "&"; 
        if (maxAcknowledgedAtFilter !== undefined)
            url_ += "MaxAcknowledgedAtFilter=" + encodeURIComponent(maxAcknowledgedAtFilter ? "" + maxAcknowledgedAtFilter.toJSON() : "") + "&"; 
        if (minAcknowledgedAtFilter !== undefined)
            url_ += "MinAcknowledgedAtFilter=" + encodeURIComponent(minAcknowledgedAtFilter ? "" + minAcknowledgedAtFilter.toJSON() : "") + "&"; 
        if (vendorNameFilter !== undefined)
            url_ += "VendorNameFilter=" + encodeURIComponent("" + vendorNameFilter) + "&"; 
        if (assetOwnerNameFilter !== undefined)
            url_ += "AssetOwnerNameFilter=" + encodeURIComponent("" + assetOwnerNameFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSupportContractsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSupportContractsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSupportContractsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllVendorForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfSupportContractVendorLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/SupportContracts/GetAllVendorForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllVendorForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllVendorForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSupportContractVendorLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfSupportContractVendorLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllVendorForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfSupportContractVendorLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfSupportContractVendorLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSupportContractVendorLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllAssetOwnerForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfSupportContractAssetOwnerLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/SupportContracts/GetAllAssetOwnerForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAssetOwnerForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAssetOwnerForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSupportContractAssetOwnerLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfSupportContractAssetOwnerLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAssetOwnerForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfSupportContractAssetOwnerLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfSupportContractAssetOwnerLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSupportContractAssetOwnerLookupTableDto>(<any>null);
    }
}

@Injectable()
export class SupportItemsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param descriptionFilter (optional) 
     * @param maxUnitPriceFilter (optional) 
     * @param minUnitPriceFilter (optional) 
     * @param maxFrequencyFilter (optional) 
     * @param minFrequencyFilter (optional) 
     * @param isAdHocFilter (optional) 
     * @param isChargeableFilter (optional) 
     * @param isStandbyReplacementUnitFilter (optional) 
     * @param assetReferenceFilter (optional) 
     * @param assetClassClassFilter (optional) 
     * @param uomUnitOfMeasurementFilter (optional) 
     * @param supportContractTitleFilter (optional) 
     * @param consumableTypeTypeFilter (optional) 
     * @param supportTypeTypeFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, descriptionFilter: string | null | undefined, maxUnitPriceFilter: number | null | undefined, minUnitPriceFilter: number | null | undefined, maxFrequencyFilter: number | null | undefined, minFrequencyFilter: number | null | undefined, isAdHocFilter: number | null | undefined, isChargeableFilter: number | null | undefined, isStandbyReplacementUnitFilter: number | null | undefined, assetReferenceFilter: string | null | undefined, assetClassClassFilter: string | null | undefined, uomUnitOfMeasurementFilter: string | null | undefined, supportContractTitleFilter: string | null | undefined, consumableTypeTypeFilter: string | null | undefined, supportTypeTypeFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetSupportItemForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SupportItems/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (maxUnitPriceFilter !== undefined)
            url_ += "MaxUnitPriceFilter=" + encodeURIComponent("" + maxUnitPriceFilter) + "&"; 
        if (minUnitPriceFilter !== undefined)
            url_ += "MinUnitPriceFilter=" + encodeURIComponent("" + minUnitPriceFilter) + "&"; 
        if (maxFrequencyFilter !== undefined)
            url_ += "MaxFrequencyFilter=" + encodeURIComponent("" + maxFrequencyFilter) + "&"; 
        if (minFrequencyFilter !== undefined)
            url_ += "MinFrequencyFilter=" + encodeURIComponent("" + minFrequencyFilter) + "&"; 
        if (isAdHocFilter !== undefined)
            url_ += "IsAdHocFilter=" + encodeURIComponent("" + isAdHocFilter) + "&"; 
        if (isChargeableFilter !== undefined)
            url_ += "IsChargeableFilter=" + encodeURIComponent("" + isChargeableFilter) + "&"; 
        if (isStandbyReplacementUnitFilter !== undefined)
            url_ += "IsStandbyReplacementUnitFilter=" + encodeURIComponent("" + isStandbyReplacementUnitFilter) + "&"; 
        if (assetReferenceFilter !== undefined)
            url_ += "AssetReferenceFilter=" + encodeURIComponent("" + assetReferenceFilter) + "&"; 
        if (assetClassClassFilter !== undefined)
            url_ += "AssetClassClassFilter=" + encodeURIComponent("" + assetClassClassFilter) + "&"; 
        if (uomUnitOfMeasurementFilter !== undefined)
            url_ += "UomUnitOfMeasurementFilter=" + encodeURIComponent("" + uomUnitOfMeasurementFilter) + "&"; 
        if (supportContractTitleFilter !== undefined)
            url_ += "SupportContractTitleFilter=" + encodeURIComponent("" + supportContractTitleFilter) + "&"; 
        if (consumableTypeTypeFilter !== undefined)
            url_ += "ConsumableTypeTypeFilter=" + encodeURIComponent("" + consumableTypeTypeFilter) + "&"; 
        if (supportTypeTypeFilter !== undefined)
            url_ += "SupportTypeTypeFilter=" + encodeURIComponent("" + supportTypeTypeFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetSupportItemForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetSupportItemForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetSupportItemForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetSupportItemForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetSupportItemForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSupportItemForView(id: number | null | undefined): Observable<GetSupportItemForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SupportItems/GetSupportItemForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSupportItemForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSupportItemForView(<any>response_);
                } catch (e) {
                    return <Observable<GetSupportItemForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetSupportItemForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSupportItemForView(response: HttpResponseBase): Observable<GetSupportItemForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSupportItemForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSupportItemForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSupportItemForEdit(id: number | null | undefined): Observable<GetSupportItemForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/SupportItems/GetSupportItemForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSupportItemForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSupportItemForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetSupportItemForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetSupportItemForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetSupportItemForEdit(response: HttpResponseBase): Observable<GetSupportItemForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSupportItemForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSupportItemForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditSupportItemDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SupportItems/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SupportItems/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param descriptionFilter (optional) 
     * @param maxUnitPriceFilter (optional) 
     * @param minUnitPriceFilter (optional) 
     * @param maxFrequencyFilter (optional) 
     * @param minFrequencyFilter (optional) 
     * @param isAdHocFilter (optional) 
     * @param isChargeableFilter (optional) 
     * @param isStandbyReplacementUnitFilter (optional) 
     * @param assetReferenceFilter (optional) 
     * @param assetClassClassFilter (optional) 
     * @param uomUnitOfMeasurementFilter (optional) 
     * @param supportContractTitleFilter (optional) 
     * @param consumableTypeTypeFilter (optional) 
     * @param supportTypeTypeFilter (optional) 
     * @return Success
     */
    getSupportItemsToExcel(filter: string | null | undefined, descriptionFilter: string | null | undefined, maxUnitPriceFilter: number | null | undefined, minUnitPriceFilter: number | null | undefined, maxFrequencyFilter: number | null | undefined, minFrequencyFilter: number | null | undefined, isAdHocFilter: number | null | undefined, isChargeableFilter: number | null | undefined, isStandbyReplacementUnitFilter: number | null | undefined, assetReferenceFilter: string | null | undefined, assetClassClassFilter: string | null | undefined, uomUnitOfMeasurementFilter: string | null | undefined, supportContractTitleFilter: string | null | undefined, consumableTypeTypeFilter: string | null | undefined, supportTypeTypeFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/SupportItems/GetSupportItemsToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (maxUnitPriceFilter !== undefined)
            url_ += "MaxUnitPriceFilter=" + encodeURIComponent("" + maxUnitPriceFilter) + "&"; 
        if (minUnitPriceFilter !== undefined)
            url_ += "MinUnitPriceFilter=" + encodeURIComponent("" + minUnitPriceFilter) + "&"; 
        if (maxFrequencyFilter !== undefined)
            url_ += "MaxFrequencyFilter=" + encodeURIComponent("" + maxFrequencyFilter) + "&"; 
        if (minFrequencyFilter !== undefined)
            url_ += "MinFrequencyFilter=" + encodeURIComponent("" + minFrequencyFilter) + "&"; 
        if (isAdHocFilter !== undefined)
            url_ += "IsAdHocFilter=" + encodeURIComponent("" + isAdHocFilter) + "&"; 
        if (isChargeableFilter !== undefined)
            url_ += "IsChargeableFilter=" + encodeURIComponent("" + isChargeableFilter) + "&"; 
        if (isStandbyReplacementUnitFilter !== undefined)
            url_ += "IsStandbyReplacementUnitFilter=" + encodeURIComponent("" + isStandbyReplacementUnitFilter) + "&"; 
        if (assetReferenceFilter !== undefined)
            url_ += "AssetReferenceFilter=" + encodeURIComponent("" + assetReferenceFilter) + "&"; 
        if (assetClassClassFilter !== undefined)
            url_ += "AssetClassClassFilter=" + encodeURIComponent("" + assetClassClassFilter) + "&"; 
        if (uomUnitOfMeasurementFilter !== undefined)
            url_ += "UomUnitOfMeasurementFilter=" + encodeURIComponent("" + uomUnitOfMeasurementFilter) + "&"; 
        if (supportContractTitleFilter !== undefined)
            url_ += "SupportContractTitleFilter=" + encodeURIComponent("" + supportContractTitleFilter) + "&"; 
        if (consumableTypeTypeFilter !== undefined)
            url_ += "ConsumableTypeTypeFilter=" + encodeURIComponent("" + consumableTypeTypeFilter) + "&"; 
        if (supportTypeTypeFilter !== undefined)
            url_ += "SupportTypeTypeFilter=" + encodeURIComponent("" + supportTypeTypeFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSupportItemsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSupportItemsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSupportItemsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllAssetForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfSupportItemAssetLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/SupportItems/GetAllAssetForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAssetForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAssetForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSupportItemAssetLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfSupportItemAssetLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAssetForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfSupportItemAssetLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfSupportItemAssetLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSupportItemAssetLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllAssetClassForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfSupportItemAssetClassLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/SupportItems/GetAllAssetClassForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAssetClassForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAssetClassForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSupportItemAssetClassLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfSupportItemAssetClassLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAssetClassForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfSupportItemAssetClassLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfSupportItemAssetClassLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSupportItemAssetClassLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllSupportContractForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfSupportItemSupportContractLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/SupportItems/GetAllSupportContractForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSupportContractForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSupportContractForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSupportItemSupportContractLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfSupportItemSupportContractLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSupportContractForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfSupportItemSupportContractLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfSupportItemSupportContractLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSupportItemSupportContractLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllConsumableTypeForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfSupportItemConsumableTypeLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/SupportItems/GetAllConsumableTypeForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllConsumableTypeForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllConsumableTypeForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSupportItemConsumableTypeLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfSupportItemConsumableTypeLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllConsumableTypeForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfSupportItemConsumableTypeLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfSupportItemConsumableTypeLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSupportItemConsumableTypeLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllSupportTypeForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfSupportItemSupportTypeLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/SupportItems/GetAllSupportTypeForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSupportTypeForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSupportTypeForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfSupportItemSupportTypeLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfSupportItemSupportTypeLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSupportTypeForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfSupportItemSupportTypeLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfSupportItemSupportTypeLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfSupportItemSupportTypeLookupTableDto>(<any>null);
    }

    /**
     * @param supportContractId (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @param sorting (optional) 
     * @return Success
     */
    getSome(supportContractId: number | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined, sorting: string | null | undefined): Observable<PagedResultDtoOfGetSupportItemForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SupportItems/GetSome?";
        if (supportContractId !== undefined)
            url_ += "supportContractId=" + encodeURIComponent("" + supportContractId) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSome(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSome(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetSupportItemForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetSupportItemForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSome(response: HttpResponseBase): Observable<PagedResultDtoOfGetSupportItemForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetSupportItemForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetSupportItemForViewDto>(<any>null);
    }
}

@Injectable()
export class SupportTypesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetSupportTypeForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SupportTypes/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetSupportTypeForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetSupportTypeForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetSupportTypeForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetSupportTypeForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetSupportTypeForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSupportTypeForView(id: number | null | undefined): Observable<GetSupportTypeForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/SupportTypes/GetSupportTypeForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSupportTypeForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSupportTypeForView(<any>response_);
                } catch (e) {
                    return <Observable<GetSupportTypeForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetSupportTypeForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSupportTypeForView(response: HttpResponseBase): Observable<GetSupportTypeForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSupportTypeForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSupportTypeForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getSupportTypeForEdit(id: number | null | undefined): Observable<GetSupportTypeForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/SupportTypes/GetSupportTypeForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSupportTypeForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSupportTypeForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetSupportTypeForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetSupportTypeForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetSupportTypeForEdit(response: HttpResponseBase): Observable<GetSupportTypeForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSupportTypeForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSupportTypeForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditSupportTypeDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SupportTypes/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/SupportTypes/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TenantServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param subscriptionEndDateStart (optional) 
     * @param subscriptionEndDateEnd (optional) 
     * @param creationDateStart (optional) 
     * @param creationDateEnd (optional) 
     * @param editionId (optional) 
     * @param editionIdSpecified (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getTenants(filter: string | null | undefined, subscriptionEndDateStart: moment.Moment | null | undefined, subscriptionEndDateEnd: moment.Moment | null | undefined, creationDateStart: moment.Moment | null | undefined, creationDateEnd: moment.Moment | null | undefined, editionId: number | null | undefined, editionIdSpecified: boolean | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfTenantListDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetTenants?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (subscriptionEndDateStart !== undefined)
            url_ += "SubscriptionEndDateStart=" + encodeURIComponent(subscriptionEndDateStart ? "" + subscriptionEndDateStart.toJSON() : "") + "&"; 
        if (subscriptionEndDateEnd !== undefined)
            url_ += "SubscriptionEndDateEnd=" + encodeURIComponent(subscriptionEndDateEnd ? "" + subscriptionEndDateEnd.toJSON() : "") + "&"; 
        if (creationDateStart !== undefined)
            url_ += "CreationDateStart=" + encodeURIComponent(creationDateStart ? "" + creationDateStart.toJSON() : "") + "&"; 
        if (creationDateEnd !== undefined)
            url_ += "CreationDateEnd=" + encodeURIComponent(creationDateEnd ? "" + creationDateEnd.toJSON() : "") + "&"; 
        if (editionId !== undefined)
            url_ += "EditionId=" + encodeURIComponent("" + editionId) + "&"; 
        if (editionIdSpecified !== undefined)
            url_ += "EditionIdSpecified=" + encodeURIComponent("" + editionIdSpecified) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenants(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenants(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfTenantListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfTenantListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenants(response: HttpResponseBase): Observable<PagedResultDtoOfTenantListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfTenantListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfTenantListDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createTenantForCustomer(input: CreateTenantInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/CreateTenantForCustomer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTenantForCustomer(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTenantForCustomer(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateTenantForCustomer(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createTenantForVendor(input: CreateTenantInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/CreateTenantForVendor";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTenantForVendor(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTenantForVendor(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateTenantForVendor(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createTenant(input: CreateTenantInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/CreateTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateTenant(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTenantForEdit(id: number | null | undefined): Observable<TenantEditDto> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetTenantForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantForEdit(<any>response_);
                } catch (e) {
                    return <Observable<TenantEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenantForEdit(response: HttpResponseBase): Observable<TenantEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantEditDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTenantLogoId(id: number | null | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetTenantLogoId?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantLogoId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantLogoId(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenantLogoId(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateTenant(input: TenantEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/UpdateTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTenant(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteTenant(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/DeleteTenant?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTenant(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteTenant(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getTenantFeaturesForEdit(id: number | null | undefined): Observable<GetTenantFeaturesEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/GetTenantFeaturesForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTenantFeaturesForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTenantFeaturesForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetTenantFeaturesEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetTenantFeaturesEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetTenantFeaturesForEdit(response: HttpResponseBase): Observable<GetTenantFeaturesEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetTenantFeaturesEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetTenantFeaturesEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateTenantFeatures(input: UpdateTenantFeaturesInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/UpdateTenantFeatures";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTenantFeatures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTenantFeatures(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTenantFeatures(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    resetTenantSpecificFeatures(input: EntityDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/ResetTenantSpecificFeatures";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetTenantSpecificFeatures(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetTenantSpecificFeatures(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processResetTenantSpecificFeatures(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    unlockTenantAdmin(input: EntityDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Tenant/UnlockTenantAdmin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnlockTenantAdmin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlockTenantAdmin(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnlockTenantAdmin(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TenantDashboardServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getMemberActivity(): Observable<GetMemberActivityOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetMemberActivity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMemberActivity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMemberActivity(<any>response_);
                } catch (e) {
                    return <Observable<GetMemberActivityOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetMemberActivityOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetMemberActivity(response: HttpResponseBase): Observable<GetMemberActivityOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetMemberActivityOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetMemberActivityOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getDashboardData(salesSummaryDatePeriod: SalesSummaryDatePeriod, agedReceivablesDatePeriod: AgedReceivablesDatePeriod): Observable<GetDashboardDataOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetDashboardData?";
        if (salesSummaryDatePeriod === undefined || salesSummaryDatePeriod === null)
            throw new Error("The parameter 'salesSummaryDatePeriod' must be defined and cannot be null.");
        else
            url_ += "SalesSummaryDatePeriod=" + encodeURIComponent("" + salesSummaryDatePeriod) + "&"; 
        if (agedReceivablesDatePeriod === undefined || agedReceivablesDatePeriod === null)
            throw new Error("The parameter 'agedReceivablesDatePeriod' must be defined and cannot be null.");
        else
            url_ += "AgedReceivablesDatePeriod=" + encodeURIComponent("" + agedReceivablesDatePeriod) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDashboardData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDashboardData(<any>response_);
                } catch (e) {
                    return <Observable<GetDashboardDataOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetDashboardDataOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetDashboardData(response: HttpResponseBase): Observable<GetDashboardDataOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetDashboardDataOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetDashboardDataOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getSalesSummary(salesSummaryDatePeriod: SalesSummaryDatePeriod): Observable<GetSalesSummaryOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetSalesSummary?";
        if (salesSummaryDatePeriod === undefined || salesSummaryDatePeriod === null)
            throw new Error("The parameter 'salesSummaryDatePeriod' must be defined and cannot be null.");
        else
            url_ += "SalesSummaryDatePeriod=" + encodeURIComponent("" + salesSummaryDatePeriod) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSalesSummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSalesSummary(<any>response_);
                } catch (e) {
                    return <Observable<GetSalesSummaryOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetSalesSummaryOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetSalesSummary(response: HttpResponseBase): Observable<GetSalesSummaryOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetSalesSummaryOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetSalesSummaryOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getRevenueForecast(): Observable<GetRevenueForecastOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetRevenueForecast";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRevenueForecast(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRevenueForecast(<any>response_);
                } catch (e) {
                    return <Observable<GetRevenueForecastOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRevenueForecastOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRevenueForecast(response: HttpResponseBase): Observable<GetRevenueForecastOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRevenueForecastOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRevenueForecastOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getAgedReceivables(): Observable<GetAgedReceivablesOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetAgedReceivables";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAgedReceivables(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAgedReceivables(<any>response_);
                } catch (e) {
                    return <Observable<GetAgedReceivablesOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetAgedReceivablesOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetAgedReceivables(response: HttpResponseBase): Observable<GetAgedReceivablesOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAgedReceivablesOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetAgedReceivablesOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getRegionalStats(): Observable<GetRegionalStatsOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetRegionalStats";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRegionalStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRegionalStats(<any>response_);
                } catch (e) {
                    return <Observable<GetRegionalStatsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetRegionalStatsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetRegionalStats(response: HttpResponseBase): Observable<GetRegionalStatsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetRegionalStatsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetRegionalStatsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getGeneralStats(): Observable<GetGeneralStatsOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetGeneralStats";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGeneralStats(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGeneralStats(<any>response_);
                } catch (e) {
                    return <Observable<GetGeneralStatsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetGeneralStatsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetGeneralStats(response: HttpResponseBase): Observable<GetGeneralStatsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetGeneralStatsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetGeneralStatsOutput>(<any>null);
    }

    /**
     * @param tenant_TenantType (optional) 
     * @param tenant_SubscriptionEndDateUtc (optional) 
     * @param tenant_IsInTrialPeriod (optional) 
     * @param tenant_CustomCssId (optional) 
     * @param tenant_LogoId (optional) 
     * @param tenant_LogoFileType (optional) 
     * @param tenant_Edition_IsDeleted (optional) 
     * @param tenant_Edition_DeleterUserId (optional) 
     * @param tenant_Edition_DeletionTime (optional) 
     * @param tenant_Edition_LastModificationTime (optional) 
     * @param tenant_Edition_LastModifierUserId (optional) 
     * @param tenant_Edition_CreationTime (optional) 
     * @param tenant_Edition_CreatorUserId (optional) 
     * @param tenant_Edition_Id (optional) 
     * @param tenant_EditionId (optional) 
     * @param tenant_CreatorUser_ProfilePictureId (optional) 
     * @param tenant_CreatorUser_ShouldChangePasswordOnNextLogin (optional) 
     * @param tenant_CreatorUser_SignInTokenExpireTimeUtc (optional) 
     * @param tenant_CreatorUser_SignInToken (optional) 
     * @param tenant_CreatorUser_GoogleAuthenticatorKey (optional) 
     * @param tenant_CreatorUser_OrganizationUnits (optional) 
     * @param tenant_CreatorUser_ConcurrencyStamp (optional) 
     * @param tenant_CreatorUser_Tokens (optional) 
     * @param tenant_CreatorUser_DeleterUser_ProfilePictureId (optional) 
     * @param tenant_CreatorUser_DeleterUser_ShouldChangePasswordOnNextLogin (optional) 
     * @param tenant_CreatorUser_DeleterUser_SignInTokenExpireTimeUtc (optional) 
     * @param tenant_CreatorUser_DeleterUser_SignInToken (optional) 
     * @param tenant_CreatorUser_DeleterUser_GoogleAuthenticatorKey (optional) 
     * @param tenant_CreatorUser_DeleterUser_OrganizationUnits (optional) 
     * @param tenant_CreatorUser_DeleterUser_ConcurrencyStamp (optional) 
     * @param tenant_CreatorUser_DeleterUser_Tokens (optional) 
     * @param tenant_CreatorUser_DeleterUser_DeleterUser (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_ProfilePictureId (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_ShouldChangePasswordOnNextLogin (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_SignInTokenExpireTimeUtc (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_SignInToken (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_GoogleAuthenticatorKey (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_OrganizationUnits (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_ConcurrencyStamp (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_Tokens (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_DeleterUser (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_CreatorUser (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_ProfilePictureId (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_ShouldChangePasswordOnNextLogin (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_SignInTokenExpireTimeUtc (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_SignInToken (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_GoogleAuthenticatorKey (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_OrganizationUnits (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_ConcurrencyStamp (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_Tokens (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_DeleterUser (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_CreatorUser (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_LastModifierUser (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_AuthenticationSource (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_TenantId (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_FullName (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_EmailConfirmationCode (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_PasswordResetCode (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_LockoutEndDateUtc (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_AccessFailedCount (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_IsLockoutEnabled (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_PhoneNumber (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_IsPhoneNumberConfirmed (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_SecurityStamp (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_IsTwoFactorEnabled (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_Logins (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_Roles (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_Claims (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_Permissions (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_Settings (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_IsEmailConfirmed (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_IsActive (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_IsDeleted (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_DeleterUserId (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_DeletionTime (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_LastModificationTime (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_LastModifierUserId (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_CreationTime (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_CreatorUserId (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_Id (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_AuthenticationSource (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_TenantId (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_FullName (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_EmailConfirmationCode (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_PasswordResetCode (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_LockoutEndDateUtc (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_AccessFailedCount (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_IsLockoutEnabled (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_PhoneNumber (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_IsPhoneNumberConfirmed (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_SecurityStamp (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_IsTwoFactorEnabled (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_Logins (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_Roles (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_Claims (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_Permissions (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_Settings (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_IsEmailConfirmed (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_IsActive (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_IsDeleted (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_DeleterUserId (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_DeletionTime (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_LastModificationTime (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUserId (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_CreationTime (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_CreatorUserId (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUser_Id (optional) 
     * @param tenant_CreatorUser_DeleterUser_LastModifierUser (optional) 
     * @param tenant_CreatorUser_DeleterUser_AuthenticationSource (optional) 
     * @param tenant_CreatorUser_DeleterUser_TenantId (optional) 
     * @param tenant_CreatorUser_DeleterUser_FullName (optional) 
     * @param tenant_CreatorUser_DeleterUser_EmailConfirmationCode (optional) 
     * @param tenant_CreatorUser_DeleterUser_PasswordResetCode (optional) 
     * @param tenant_CreatorUser_DeleterUser_LockoutEndDateUtc (optional) 
     * @param tenant_CreatorUser_DeleterUser_AccessFailedCount (optional) 
     * @param tenant_CreatorUser_DeleterUser_IsLockoutEnabled (optional) 
     * @param tenant_CreatorUser_DeleterUser_PhoneNumber (optional) 
     * @param tenant_CreatorUser_DeleterUser_IsPhoneNumberConfirmed (optional) 
     * @param tenant_CreatorUser_DeleterUser_SecurityStamp (optional) 
     * @param tenant_CreatorUser_DeleterUser_IsTwoFactorEnabled (optional) 
     * @param tenant_CreatorUser_DeleterUser_Logins (optional) 
     * @param tenant_CreatorUser_DeleterUser_Roles (optional) 
     * @param tenant_CreatorUser_DeleterUser_Claims (optional) 
     * @param tenant_CreatorUser_DeleterUser_Permissions (optional) 
     * @param tenant_CreatorUser_DeleterUser_Settings (optional) 
     * @param tenant_CreatorUser_DeleterUser_IsEmailConfirmed (optional) 
     * @param tenant_CreatorUser_DeleterUser_IsActive (optional) 
     * @param tenant_CreatorUser_DeleterUser_IsDeleted (optional) 
     * @param tenant_CreatorUser_DeleterUser_DeleterUserId (optional) 
     * @param tenant_CreatorUser_DeleterUser_DeletionTime (optional) 
     * @param tenant_CreatorUser_DeleterUser_LastModificationTime (optional) 
     * @param tenant_CreatorUser_DeleterUser_LastModifierUserId (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreationTime (optional) 
     * @param tenant_CreatorUser_DeleterUser_CreatorUserId (optional) 
     * @param tenant_CreatorUser_DeleterUser_Id (optional) 
     * @param tenant_CreatorUser_CreatorUser (optional) 
     * @param tenant_CreatorUser_LastModifierUser (optional) 
     * @param tenant_CreatorUser_AuthenticationSource (optional) 
     * @param tenant_CreatorUser_TenantId (optional) 
     * @param tenant_CreatorUser_FullName (optional) 
     * @param tenant_CreatorUser_EmailConfirmationCode (optional) 
     * @param tenant_CreatorUser_PasswordResetCode (optional) 
     * @param tenant_CreatorUser_LockoutEndDateUtc (optional) 
     * @param tenant_CreatorUser_AccessFailedCount (optional) 
     * @param tenant_CreatorUser_IsLockoutEnabled (optional) 
     * @param tenant_CreatorUser_PhoneNumber (optional) 
     * @param tenant_CreatorUser_IsPhoneNumberConfirmed (optional) 
     * @param tenant_CreatorUser_SecurityStamp (optional) 
     * @param tenant_CreatorUser_IsTwoFactorEnabled (optional) 
     * @param tenant_CreatorUser_Logins (optional) 
     * @param tenant_CreatorUser_Roles (optional) 
     * @param tenant_CreatorUser_Claims (optional) 
     * @param tenant_CreatorUser_Permissions (optional) 
     * @param tenant_CreatorUser_Settings (optional) 
     * @param tenant_CreatorUser_IsEmailConfirmed (optional) 
     * @param tenant_CreatorUser_IsActive (optional) 
     * @param tenant_CreatorUser_IsDeleted (optional) 
     * @param tenant_CreatorUser_DeleterUserId (optional) 
     * @param tenant_CreatorUser_DeletionTime (optional) 
     * @param tenant_CreatorUser_LastModificationTime (optional) 
     * @param tenant_CreatorUser_LastModifierUserId (optional) 
     * @param tenant_CreatorUser_CreationTime (optional) 
     * @param tenant_CreatorUser_CreatorUserId (optional) 
     * @param tenant_CreatorUser_Id (optional) 
     * @param tenant_LastModifierUser_ProfilePictureId (optional) 
     * @param tenant_LastModifierUser_ShouldChangePasswordOnNextLogin (optional) 
     * @param tenant_LastModifierUser_SignInTokenExpireTimeUtc (optional) 
     * @param tenant_LastModifierUser_SignInToken (optional) 
     * @param tenant_LastModifierUser_GoogleAuthenticatorKey (optional) 
     * @param tenant_LastModifierUser_OrganizationUnits (optional) 
     * @param tenant_LastModifierUser_ConcurrencyStamp (optional) 
     * @param tenant_LastModifierUser_Tokens (optional) 
     * @param tenant_LastModifierUser_DeleterUser (optional) 
     * @param tenant_LastModifierUser_CreatorUser (optional) 
     * @param tenant_LastModifierUser_LastModifierUser (optional) 
     * @param tenant_LastModifierUser_AuthenticationSource (optional) 
     * @param tenant_LastModifierUser_TenantId (optional) 
     * @param tenant_LastModifierUser_FullName (optional) 
     * @param tenant_LastModifierUser_EmailConfirmationCode (optional) 
     * @param tenant_LastModifierUser_PasswordResetCode (optional) 
     * @param tenant_LastModifierUser_LockoutEndDateUtc (optional) 
     * @param tenant_LastModifierUser_AccessFailedCount (optional) 
     * @param tenant_LastModifierUser_IsLockoutEnabled (optional) 
     * @param tenant_LastModifierUser_PhoneNumber (optional) 
     * @param tenant_LastModifierUser_IsPhoneNumberConfirmed (optional) 
     * @param tenant_LastModifierUser_SecurityStamp (optional) 
     * @param tenant_LastModifierUser_IsTwoFactorEnabled (optional) 
     * @param tenant_LastModifierUser_Logins (optional) 
     * @param tenant_LastModifierUser_Roles (optional) 
     * @param tenant_LastModifierUser_Claims (optional) 
     * @param tenant_LastModifierUser_Permissions (optional) 
     * @param tenant_LastModifierUser_Settings (optional) 
     * @param tenant_LastModifierUser_IsEmailConfirmed (optional) 
     * @param tenant_LastModifierUser_IsActive (optional) 
     * @param tenant_LastModifierUser_IsDeleted (optional) 
     * @param tenant_LastModifierUser_DeleterUserId (optional) 
     * @param tenant_LastModifierUser_DeletionTime (optional) 
     * @param tenant_LastModifierUser_LastModificationTime (optional) 
     * @param tenant_LastModifierUser_LastModifierUserId (optional) 
     * @param tenant_LastModifierUser_CreationTime (optional) 
     * @param tenant_LastModifierUser_CreatorUserId (optional) 
     * @param tenant_LastModifierUser_Id (optional) 
     * @param tenant_DeleterUser_ProfilePictureId (optional) 
     * @param tenant_DeleterUser_ShouldChangePasswordOnNextLogin (optional) 
     * @param tenant_DeleterUser_SignInTokenExpireTimeUtc (optional) 
     * @param tenant_DeleterUser_SignInToken (optional) 
     * @param tenant_DeleterUser_GoogleAuthenticatorKey (optional) 
     * @param tenant_DeleterUser_OrganizationUnits (optional) 
     * @param tenant_DeleterUser_ConcurrencyStamp (optional) 
     * @param tenant_DeleterUser_Tokens (optional) 
     * @param tenant_DeleterUser_DeleterUser (optional) 
     * @param tenant_DeleterUser_CreatorUser (optional) 
     * @param tenant_DeleterUser_LastModifierUser (optional) 
     * @param tenant_DeleterUser_AuthenticationSource (optional) 
     * @param tenant_DeleterUser_TenantId (optional) 
     * @param tenant_DeleterUser_FullName (optional) 
     * @param tenant_DeleterUser_EmailConfirmationCode (optional) 
     * @param tenant_DeleterUser_PasswordResetCode (optional) 
     * @param tenant_DeleterUser_LockoutEndDateUtc (optional) 
     * @param tenant_DeleterUser_AccessFailedCount (optional) 
     * @param tenant_DeleterUser_IsLockoutEnabled (optional) 
     * @param tenant_DeleterUser_PhoneNumber (optional) 
     * @param tenant_DeleterUser_IsPhoneNumberConfirmed (optional) 
     * @param tenant_DeleterUser_SecurityStamp (optional) 
     * @param tenant_DeleterUser_IsTwoFactorEnabled (optional) 
     * @param tenant_DeleterUser_Logins (optional) 
     * @param tenant_DeleterUser_Roles (optional) 
     * @param tenant_DeleterUser_Claims (optional) 
     * @param tenant_DeleterUser_Permissions (optional) 
     * @param tenant_DeleterUser_Settings (optional) 
     * @param tenant_DeleterUser_IsEmailConfirmed (optional) 
     * @param tenant_DeleterUser_IsActive (optional) 
     * @param tenant_DeleterUser_IsDeleted (optional) 
     * @param tenant_DeleterUser_DeleterUserId (optional) 
     * @param tenant_DeleterUser_DeletionTime (optional) 
     * @param tenant_DeleterUser_LastModificationTime (optional) 
     * @param tenant_DeleterUser_LastModifierUserId (optional) 
     * @param tenant_DeleterUser_CreationTime (optional) 
     * @param tenant_DeleterUser_CreatorUserId (optional) 
     * @param tenant_DeleterUser_Id (optional) 
     * @param tenant_ConnectionString (optional) 
     * @param tenant_IsActive (optional) 
     * @param tenant_IsDeleted (optional) 
     * @param tenant_DeleterUserId (optional) 
     * @param tenant_DeletionTime (optional) 
     * @param tenant_LastModificationTime (optional) 
     * @param tenant_LastModifierUserId (optional) 
     * @param tenant_CreationTime (optional) 
     * @param tenant_CreatorUserId (optional) 
     * @param tenant_Id (optional) 
     * @param customer_TenantId (optional) 
     * @param customer_LogoUrl (optional) 
     * @param customer_Website (optional) 
     * @param customer_CustomerLoc8UUID (optional) 
     * @param customer_EmailAddress (optional) 
     * @param customer_XeroContactPersons (optional) 
     * @param customer_XeroAccountsReceivableTaxType (optional) 
     * @param customer_XeroAccountsPayableTaxType (optional) 
     * @param customer_XeroAddresses (optional) 
     * @param customer_XeroPhones (optional) 
     * @param customer_XeroDefaultCurrency (optional) 
     * @param customer_XeroPaymentTerms (optional) 
     * @param customer_XeroContactId (optional) 
     * @param customer_CustomerTypeId (optional) 
     * @param customer_CustomerTypeFk_TenantId (optional) 
     * @param customer_CustomerTypeFk_IsDeleted (optional) 
     * @param customer_CustomerTypeFk_DeleterUserId (optional) 
     * @param customer_CustomerTypeFk_DeletionTime (optional) 
     * @param customer_CustomerTypeFk_LastModificationTime (optional) 
     * @param customer_CustomerTypeFk_LastModifierUserId (optional) 
     * @param customer_CustomerTypeFk_CreationTime (optional) 
     * @param customer_CustomerTypeFk_CreatorUserId (optional) 
     * @param customer_CustomerTypeFk_Id (optional) 
     * @param customer_CurrencyId (optional) 
     * @param customer_CurrencyFk_TenantId (optional) 
     * @param customer_CurrencyFk_Symbol (optional) 
     * @param customer_CurrencyFk_IsDeleted (optional) 
     * @param customer_CurrencyFk_DeleterUserId (optional) 
     * @param customer_CurrencyFk_DeletionTime (optional) 
     * @param customer_CurrencyFk_LastModificationTime (optional) 
     * @param customer_CurrencyFk_LastModifierUserId (optional) 
     * @param customer_CurrencyFk_CreationTime (optional) 
     * @param customer_CurrencyFk_CreatorUserId (optional) 
     * @param customer_CurrencyFk_Id (optional) 
     * @param customer_PaymentTermNumber (optional) 
     * @param customer_PaymentTermType (optional) 
     * @param customer_IsDeleted (optional) 
     * @param customer_DeleterUserId (optional) 
     * @param customer_DeletionTime (optional) 
     * @param customer_LastModificationTime (optional) 
     * @param customer_LastModifierUserId (optional) 
     * @param customer_CreationTime (optional) 
     * @param customer_CreatorUserId (optional) 
     * @param customer_Id (optional) 
     * @param vendor_TenantId (optional) 
     * @param vendor_LogoUrl (optional) 
     * @param vendor_Website (optional) 
     * @param vendor_VendorLoc8GUID (optional) 
     * @param vendor_SsicCodeId (optional) 
     * @param vendor_SsicCodeFk_TenantId (optional) 
     * @param vendor_SsicCodeFk_IsDeleted (optional) 
     * @param vendor_SsicCodeFk_DeleterUserId (optional) 
     * @param vendor_SsicCodeFk_DeletionTime (optional) 
     * @param vendor_SsicCodeFk_LastModificationTime (optional) 
     * @param vendor_SsicCodeFk_LastModifierUserId (optional) 
     * @param vendor_SsicCodeFk_CreationTime (optional) 
     * @param vendor_SsicCodeFk_CreatorUserId (optional) 
     * @param vendor_SsicCodeFk_Id (optional) 
     * @param vendor_CurrencyId (optional) 
     * @param vendor_CurrencyFk_TenantId (optional) 
     * @param vendor_CurrencyFk_Symbol (optional) 
     * @param vendor_CurrencyFk_IsDeleted (optional) 
     * @param vendor_CurrencyFk_DeleterUserId (optional) 
     * @param vendor_CurrencyFk_DeletionTime (optional) 
     * @param vendor_CurrencyFk_LastModificationTime (optional) 
     * @param vendor_CurrencyFk_LastModifierUserId (optional) 
     * @param vendor_CurrencyFk_CreationTime (optional) 
     * @param vendor_CurrencyFk_CreatorUserId (optional) 
     * @param vendor_CurrencyFk_Id (optional) 
     * @param vendor_IsDeleted (optional) 
     * @param vendor_DeleterUserId (optional) 
     * @param vendor_DeletionTime (optional) 
     * @param vendor_LastModificationTime (optional) 
     * @param vendor_LastModifierUserId (optional) 
     * @param vendor_CreationTime (optional) 
     * @param vendor_CreatorUserId (optional) 
     * @param vendor_Id (optional) 
     * @param assetOwner_TenantId (optional) 
     * @param assetOwner_Identifier (optional) 
     * @param assetOwner_LogoUrl (optional) 
     * @param assetOwner_Website (optional) 
     * @param assetOwner_CurrencyId (optional) 
     * @param assetOwner_CurrencyFk_TenantId (optional) 
     * @param assetOwner_CurrencyFk_Symbol (optional) 
     * @param assetOwner_CurrencyFk_IsDeleted (optional) 
     * @param assetOwner_CurrencyFk_DeleterUserId (optional) 
     * @param assetOwner_CurrencyFk_DeletionTime (optional) 
     * @param assetOwner_CurrencyFk_LastModificationTime (optional) 
     * @param assetOwner_CurrencyFk_LastModifierUserId (optional) 
     * @param assetOwner_CurrencyFk_CreationTime (optional) 
     * @param assetOwner_CurrencyFk_CreatorUserId (optional) 
     * @param assetOwner_CurrencyFk_Id (optional) 
     * @param assetOwner_SsicCodeId (optional) 
     * @param assetOwner_SsicCodeFk_TenantId (optional) 
     * @param assetOwner_SsicCodeFk_IsDeleted (optional) 
     * @param assetOwner_SsicCodeFk_DeleterUserId (optional) 
     * @param assetOwner_SsicCodeFk_DeletionTime (optional) 
     * @param assetOwner_SsicCodeFk_LastModificationTime (optional) 
     * @param assetOwner_SsicCodeFk_LastModifierUserId (optional) 
     * @param assetOwner_SsicCodeFk_CreationTime (optional) 
     * @param assetOwner_SsicCodeFk_CreatorUserId (optional) 
     * @param assetOwner_SsicCodeFk_Id (optional) 
     * @param assetOwner_IsDeleted (optional) 
     * @param assetOwner_DeleterUserId (optional) 
     * @param assetOwner_DeletionTime (optional) 
     * @param assetOwner_LastModificationTime (optional) 
     * @param assetOwner_LastModifierUserId (optional) 
     * @param assetOwner_CreationTime (optional) 
     * @param assetOwner_CreatorUserId (optional) 
     * @param assetOwner_Id (optional) 
     * @param isHost (optional) 
     * @return Success
     */
    getAgedReceivablesData(tenant_TenantType: string | null | undefined, tenant_SubscriptionEndDateUtc: moment.Moment | null | undefined, tenant_IsInTrialPeriod: boolean | null | undefined, tenant_CustomCssId: string | null | undefined, tenant_LogoId: string | null | undefined, tenant_LogoFileType: string | null | undefined, tenant_SubscriptionPaymentType: SubscriptionPaymentType, tenant_Edition_Name: string, tenant_Edition_DisplayName: string, tenant_Edition_IsDeleted: boolean | null | undefined, tenant_Edition_DeleterUserId: number | null | undefined, tenant_Edition_DeletionTime: moment.Moment | null | undefined, tenant_Edition_LastModificationTime: moment.Moment | null | undefined, tenant_Edition_LastModifierUserId: number | null | undefined, tenant_Edition_CreationTime: moment.Moment | null | undefined, tenant_Edition_CreatorUserId: number | null | undefined, tenant_Edition_Id: number | null | undefined, tenant_EditionId: number | null | undefined, tenant_CreatorUser_ProfilePictureId: string | null | undefined, tenant_CreatorUser_ShouldChangePasswordOnNextLogin: boolean | null | undefined, tenant_CreatorUser_SignInTokenExpireTimeUtc: moment.Moment | null | undefined, tenant_CreatorUser_SignInToken: string | null | undefined, tenant_CreatorUser_GoogleAuthenticatorKey: string | null | undefined, tenant_CreatorUser_OrganizationUnits: any[] | null | undefined, tenant_CreatorUser_NormalizedUserName: string, tenant_CreatorUser_NormalizedEmailAddress: string, tenant_CreatorUser_ConcurrencyStamp: string | null | undefined, tenant_CreatorUser_Tokens: any[] | null | undefined, tenant_CreatorUser_DeleterUser_ProfilePictureId: string | null | undefined, tenant_CreatorUser_DeleterUser_ShouldChangePasswordOnNextLogin: boolean | null | undefined, tenant_CreatorUser_DeleterUser_SignInTokenExpireTimeUtc: moment.Moment | null | undefined, tenant_CreatorUser_DeleterUser_SignInToken: string | null | undefined, tenant_CreatorUser_DeleterUser_GoogleAuthenticatorKey: string | null | undefined, tenant_CreatorUser_DeleterUser_OrganizationUnits: any[] | null | undefined, tenant_CreatorUser_DeleterUser_NormalizedUserName: string, tenant_CreatorUser_DeleterUser_NormalizedEmailAddress: string, tenant_CreatorUser_DeleterUser_ConcurrencyStamp: string | null | undefined, tenant_CreatorUser_DeleterUser_Tokens: any[] | null | undefined, tenant_CreatorUser_DeleterUser_DeleterUser: any | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_ProfilePictureId: string | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_ShouldChangePasswordOnNextLogin: boolean | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_SignInTokenExpireTimeUtc: moment.Moment | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_SignInToken: string | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_GoogleAuthenticatorKey: string | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_OrganizationUnits: any[] | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_NormalizedUserName: string, tenant_CreatorUser_DeleterUser_CreatorUser_NormalizedEmailAddress: string, tenant_CreatorUser_DeleterUser_CreatorUser_ConcurrencyStamp: string | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_Tokens: any[] | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_DeleterUser: any | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_CreatorUser: any | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_ProfilePictureId: string | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_ShouldChangePasswordOnNextLogin: boolean | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_SignInTokenExpireTimeUtc: moment.Moment | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_SignInToken: string | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_GoogleAuthenticatorKey: string | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_OrganizationUnits: any[] | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_NormalizedUserName: string, tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_NormalizedEmailAddress: string, tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_ConcurrencyStamp: string | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_Tokens: any[] | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_DeleterUser: any | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_CreatorUser: any | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_LastModifierUser: any | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_AuthenticationSource: string | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_UserName: string, tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_TenantId: number | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_EmailAddress: string, tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_Name: string, tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_Surname: string, tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_FullName: string | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_Password: string, tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_EmailConfirmationCode: string | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_PasswordResetCode: string | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_LockoutEndDateUtc: moment.Moment | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_AccessFailedCount: number | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_IsLockoutEnabled: boolean | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_PhoneNumber: string | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_IsPhoneNumberConfirmed: boolean | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_SecurityStamp: string | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_IsTwoFactorEnabled: boolean | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_Logins: any[] | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_Roles: any[] | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_Claims: any[] | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_Permissions: any[] | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_Settings: any[] | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_IsEmailConfirmed: boolean | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_IsActive: boolean | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_IsDeleted: boolean | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_DeleterUserId: number | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_DeletionTime: moment.Moment | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_LastModificationTime: moment.Moment | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_LastModifierUserId: number | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_CreationTime: moment.Moment | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_CreatorUserId: number | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_Id: number | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_AuthenticationSource: string | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_UserName: string, tenant_CreatorUser_DeleterUser_CreatorUser_TenantId: number | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_EmailAddress: string, tenant_CreatorUser_DeleterUser_CreatorUser_Name: string, tenant_CreatorUser_DeleterUser_CreatorUser_Surname: string, tenant_CreatorUser_DeleterUser_CreatorUser_FullName: string | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_Password: string, tenant_CreatorUser_DeleterUser_CreatorUser_EmailConfirmationCode: string | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_PasswordResetCode: string | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_LockoutEndDateUtc: moment.Moment | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_AccessFailedCount: number | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_IsLockoutEnabled: boolean | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_PhoneNumber: string | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_IsPhoneNumberConfirmed: boolean | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_SecurityStamp: string | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_IsTwoFactorEnabled: boolean | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_Logins: any[] | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_Roles: any[] | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_Claims: any[] | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_Permissions: any[] | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_Settings: any[] | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_IsEmailConfirmed: boolean | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_IsActive: boolean | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_IsDeleted: boolean | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_DeleterUserId: number | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_DeletionTime: moment.Moment | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_LastModificationTime: moment.Moment | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUserId: number | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_CreationTime: moment.Moment | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_CreatorUserId: number | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUser_Id: number | null | undefined, tenant_CreatorUser_DeleterUser_LastModifierUser: any | null | undefined, tenant_CreatorUser_DeleterUser_AuthenticationSource: string | null | undefined, tenant_CreatorUser_DeleterUser_UserName: string, tenant_CreatorUser_DeleterUser_TenantId: number | null | undefined, tenant_CreatorUser_DeleterUser_EmailAddress: string, tenant_CreatorUser_DeleterUser_Name: string, tenant_CreatorUser_DeleterUser_Surname: string, tenant_CreatorUser_DeleterUser_FullName: string | null | undefined, tenant_CreatorUser_DeleterUser_Password: string, tenant_CreatorUser_DeleterUser_EmailConfirmationCode: string | null | undefined, tenant_CreatorUser_DeleterUser_PasswordResetCode: string | null | undefined, tenant_CreatorUser_DeleterUser_LockoutEndDateUtc: moment.Moment | null | undefined, tenant_CreatorUser_DeleterUser_AccessFailedCount: number | null | undefined, tenant_CreatorUser_DeleterUser_IsLockoutEnabled: boolean | null | undefined, tenant_CreatorUser_DeleterUser_PhoneNumber: string | null | undefined, tenant_CreatorUser_DeleterUser_IsPhoneNumberConfirmed: boolean | null | undefined, tenant_CreatorUser_DeleterUser_SecurityStamp: string | null | undefined, tenant_CreatorUser_DeleterUser_IsTwoFactorEnabled: boolean | null | undefined, tenant_CreatorUser_DeleterUser_Logins: any[] | null | undefined, tenant_CreatorUser_DeleterUser_Roles: any[] | null | undefined, tenant_CreatorUser_DeleterUser_Claims: any[] | null | undefined, tenant_CreatorUser_DeleterUser_Permissions: any[] | null | undefined, tenant_CreatorUser_DeleterUser_Settings: any[] | null | undefined, tenant_CreatorUser_DeleterUser_IsEmailConfirmed: boolean | null | undefined, tenant_CreatorUser_DeleterUser_IsActive: boolean | null | undefined, tenant_CreatorUser_DeleterUser_IsDeleted: boolean | null | undefined, tenant_CreatorUser_DeleterUser_DeleterUserId: number | null | undefined, tenant_CreatorUser_DeleterUser_DeletionTime: moment.Moment | null | undefined, tenant_CreatorUser_DeleterUser_LastModificationTime: moment.Moment | null | undefined, tenant_CreatorUser_DeleterUser_LastModifierUserId: number | null | undefined, tenant_CreatorUser_DeleterUser_CreationTime: moment.Moment | null | undefined, tenant_CreatorUser_DeleterUser_CreatorUserId: number | null | undefined, tenant_CreatorUser_DeleterUser_Id: number | null | undefined, tenant_CreatorUser_CreatorUser: any | null | undefined, tenant_CreatorUser_LastModifierUser: any | null | undefined, tenant_CreatorUser_AuthenticationSource: string | null | undefined, tenant_CreatorUser_UserName: string, tenant_CreatorUser_TenantId: number | null | undefined, tenant_CreatorUser_EmailAddress: string, tenant_CreatorUser_Name: string, tenant_CreatorUser_Surname: string, tenant_CreatorUser_FullName: string | null | undefined, tenant_CreatorUser_Password: string, tenant_CreatorUser_EmailConfirmationCode: string | null | undefined, tenant_CreatorUser_PasswordResetCode: string | null | undefined, tenant_CreatorUser_LockoutEndDateUtc: moment.Moment | null | undefined, tenant_CreatorUser_AccessFailedCount: number | null | undefined, tenant_CreatorUser_IsLockoutEnabled: boolean | null | undefined, tenant_CreatorUser_PhoneNumber: string | null | undefined, tenant_CreatorUser_IsPhoneNumberConfirmed: boolean | null | undefined, tenant_CreatorUser_SecurityStamp: string | null | undefined, tenant_CreatorUser_IsTwoFactorEnabled: boolean | null | undefined, tenant_CreatorUser_Logins: any[] | null | undefined, tenant_CreatorUser_Roles: any[] | null | undefined, tenant_CreatorUser_Claims: any[] | null | undefined, tenant_CreatorUser_Permissions: any[] | null | undefined, tenant_CreatorUser_Settings: any[] | null | undefined, tenant_CreatorUser_IsEmailConfirmed: boolean | null | undefined, tenant_CreatorUser_IsActive: boolean | null | undefined, tenant_CreatorUser_IsDeleted: boolean | null | undefined, tenant_CreatorUser_DeleterUserId: number | null | undefined, tenant_CreatorUser_DeletionTime: moment.Moment | null | undefined, tenant_CreatorUser_LastModificationTime: moment.Moment | null | undefined, tenant_CreatorUser_LastModifierUserId: number | null | undefined, tenant_CreatorUser_CreationTime: moment.Moment | null | undefined, tenant_CreatorUser_CreatorUserId: number | null | undefined, tenant_CreatorUser_Id: number | null | undefined, tenant_LastModifierUser_ProfilePictureId: string | null | undefined, tenant_LastModifierUser_ShouldChangePasswordOnNextLogin: boolean | null | undefined, tenant_LastModifierUser_SignInTokenExpireTimeUtc: moment.Moment | null | undefined, tenant_LastModifierUser_SignInToken: string | null | undefined, tenant_LastModifierUser_GoogleAuthenticatorKey: string | null | undefined, tenant_LastModifierUser_OrganizationUnits: any[] | null | undefined, tenant_LastModifierUser_NormalizedUserName: string, tenant_LastModifierUser_NormalizedEmailAddress: string, tenant_LastModifierUser_ConcurrencyStamp: string | null | undefined, tenant_LastModifierUser_Tokens: any[] | null | undefined, tenant_LastModifierUser_DeleterUser: any | null | undefined, tenant_LastModifierUser_CreatorUser: any | null | undefined, tenant_LastModifierUser_LastModifierUser: any | null | undefined, tenant_LastModifierUser_AuthenticationSource: string | null | undefined, tenant_LastModifierUser_UserName: string, tenant_LastModifierUser_TenantId: number | null | undefined, tenant_LastModifierUser_EmailAddress: string, tenant_LastModifierUser_Name: string, tenant_LastModifierUser_Surname: string, tenant_LastModifierUser_FullName: string | null | undefined, tenant_LastModifierUser_Password: string, tenant_LastModifierUser_EmailConfirmationCode: string | null | undefined, tenant_LastModifierUser_PasswordResetCode: string | null | undefined, tenant_LastModifierUser_LockoutEndDateUtc: moment.Moment | null | undefined, tenant_LastModifierUser_AccessFailedCount: number | null | undefined, tenant_LastModifierUser_IsLockoutEnabled: boolean | null | undefined, tenant_LastModifierUser_PhoneNumber: string | null | undefined, tenant_LastModifierUser_IsPhoneNumberConfirmed: boolean | null | undefined, tenant_LastModifierUser_SecurityStamp: string | null | undefined, tenant_LastModifierUser_IsTwoFactorEnabled: boolean | null | undefined, tenant_LastModifierUser_Logins: any[] | null | undefined, tenant_LastModifierUser_Roles: any[] | null | undefined, tenant_LastModifierUser_Claims: any[] | null | undefined, tenant_LastModifierUser_Permissions: any[] | null | undefined, tenant_LastModifierUser_Settings: any[] | null | undefined, tenant_LastModifierUser_IsEmailConfirmed: boolean | null | undefined, tenant_LastModifierUser_IsActive: boolean | null | undefined, tenant_LastModifierUser_IsDeleted: boolean | null | undefined, tenant_LastModifierUser_DeleterUserId: number | null | undefined, tenant_LastModifierUser_DeletionTime: moment.Moment | null | undefined, tenant_LastModifierUser_LastModificationTime: moment.Moment | null | undefined, tenant_LastModifierUser_LastModifierUserId: number | null | undefined, tenant_LastModifierUser_CreationTime: moment.Moment | null | undefined, tenant_LastModifierUser_CreatorUserId: number | null | undefined, tenant_LastModifierUser_Id: number | null | undefined, tenant_DeleterUser_ProfilePictureId: string | null | undefined, tenant_DeleterUser_ShouldChangePasswordOnNextLogin: boolean | null | undefined, tenant_DeleterUser_SignInTokenExpireTimeUtc: moment.Moment | null | undefined, tenant_DeleterUser_SignInToken: string | null | undefined, tenant_DeleterUser_GoogleAuthenticatorKey: string | null | undefined, tenant_DeleterUser_OrganizationUnits: any[] | null | undefined, tenant_DeleterUser_NormalizedUserName: string, tenant_DeleterUser_NormalizedEmailAddress: string, tenant_DeleterUser_ConcurrencyStamp: string | null | undefined, tenant_DeleterUser_Tokens: any[] | null | undefined, tenant_DeleterUser_DeleterUser: any | null | undefined, tenant_DeleterUser_CreatorUser: any | null | undefined, tenant_DeleterUser_LastModifierUser: any | null | undefined, tenant_DeleterUser_AuthenticationSource: string | null | undefined, tenant_DeleterUser_UserName: string, tenant_DeleterUser_TenantId: number | null | undefined, tenant_DeleterUser_EmailAddress: string, tenant_DeleterUser_Name: string, tenant_DeleterUser_Surname: string, tenant_DeleterUser_FullName: string | null | undefined, tenant_DeleterUser_Password: string, tenant_DeleterUser_EmailConfirmationCode: string | null | undefined, tenant_DeleterUser_PasswordResetCode: string | null | undefined, tenant_DeleterUser_LockoutEndDateUtc: moment.Moment | null | undefined, tenant_DeleterUser_AccessFailedCount: number | null | undefined, tenant_DeleterUser_IsLockoutEnabled: boolean | null | undefined, tenant_DeleterUser_PhoneNumber: string | null | undefined, tenant_DeleterUser_IsPhoneNumberConfirmed: boolean | null | undefined, tenant_DeleterUser_SecurityStamp: string | null | undefined, tenant_DeleterUser_IsTwoFactorEnabled: boolean | null | undefined, tenant_DeleterUser_Logins: any[] | null | undefined, tenant_DeleterUser_Roles: any[] | null | undefined, tenant_DeleterUser_Claims: any[] | null | undefined, tenant_DeleterUser_Permissions: any[] | null | undefined, tenant_DeleterUser_Settings: any[] | null | undefined, tenant_DeleterUser_IsEmailConfirmed: boolean | null | undefined, tenant_DeleterUser_IsActive: boolean | null | undefined, tenant_DeleterUser_IsDeleted: boolean | null | undefined, tenant_DeleterUser_DeleterUserId: number | null | undefined, tenant_DeleterUser_DeletionTime: moment.Moment | null | undefined, tenant_DeleterUser_LastModificationTime: moment.Moment | null | undefined, tenant_DeleterUser_LastModifierUserId: number | null | undefined, tenant_DeleterUser_CreationTime: moment.Moment | null | undefined, tenant_DeleterUser_CreatorUserId: number | null | undefined, tenant_DeleterUser_Id: number | null | undefined, tenant_TenancyName: string, tenant_Name: string, tenant_ConnectionString: string | null | undefined, tenant_IsActive: boolean | null | undefined, tenant_IsDeleted: boolean | null | undefined, tenant_DeleterUserId: number | null | undefined, tenant_DeletionTime: moment.Moment | null | undefined, tenant_LastModificationTime: moment.Moment | null | undefined, tenant_LastModifierUserId: number | null | undefined, tenant_CreationTime: moment.Moment | null | undefined, tenant_CreatorUserId: number | null | undefined, tenant_Id: number | null | undefined, customer_TenantId: number | null | undefined, customer_Reference: string, customer_Name: string, customer_Identifier: string, customer_LogoUrl: string | null | undefined, customer_Website: string | null | undefined, customer_CustomerLoc8UUID: string | null | undefined, customer_EmailAddress: string | null | undefined, customer_XeroContactPersons: string | null | undefined, customer_XeroAccountsReceivableTaxType: string | null | undefined, customer_XeroAccountsPayableTaxType: string | null | undefined, customer_XeroAddresses: string | null | undefined, customer_XeroPhones: string | null | undefined, customer_XeroDefaultCurrency: string | null | undefined, customer_XeroPaymentTerms: string | null | undefined, customer_XeroContactId: string | null | undefined, customer_CustomerTypeId: number | null | undefined, customer_CustomerTypeFk_TenantId: number | null | undefined, customer_CustomerTypeFk_Type: string, customer_CustomerTypeFk_Description: string, customer_CustomerTypeFk_IsDeleted: boolean | null | undefined, customer_CustomerTypeFk_DeleterUserId: number | null | undefined, customer_CustomerTypeFk_DeletionTime: moment.Moment | null | undefined, customer_CustomerTypeFk_LastModificationTime: moment.Moment | null | undefined, customer_CustomerTypeFk_LastModifierUserId: number | null | undefined, customer_CustomerTypeFk_CreationTime: moment.Moment | null | undefined, customer_CustomerTypeFk_CreatorUserId: number | null | undefined, customer_CustomerTypeFk_Id: number | null | undefined, customer_CurrencyId: number | null | undefined, customer_CurrencyFk_TenantId: number | null | undefined, customer_CurrencyFk_Code: string, customer_CurrencyFk_Name: string, customer_CurrencyFk_Symbol: string | null | undefined, customer_CurrencyFk_Country: string, customer_CurrencyFk_BaseCountry: string, customer_CurrencyFk_IsDeleted: boolean | null | undefined, customer_CurrencyFk_DeleterUserId: number | null | undefined, customer_CurrencyFk_DeletionTime: moment.Moment | null | undefined, customer_CurrencyFk_LastModificationTime: moment.Moment | null | undefined, customer_CurrencyFk_LastModifierUserId: number | null | undefined, customer_CurrencyFk_CreationTime: moment.Moment | null | undefined, customer_CurrencyFk_CreatorUserId: number | null | undefined, customer_CurrencyFk_Id: number | null | undefined, customer_PaymentTermNumber: number | null | undefined, customer_PaymentTermType: string | null | undefined, customer_IsDeleted: boolean | null | undefined, customer_DeleterUserId: number | null | undefined, customer_DeletionTime: moment.Moment | null | undefined, customer_LastModificationTime: moment.Moment | null | undefined, customer_LastModifierUserId: number | null | undefined, customer_CreationTime: moment.Moment | null | undefined, customer_CreatorUserId: number | null | undefined, customer_Id: number | null | undefined, vendor_TenantId: number | null | undefined, vendor_Reference: string, vendor_Name: string, vendor_Identifier: string, vendor_LogoUrl: string | null | undefined, vendor_Website: string | null | undefined, vendor_VendorLoc8GUID: string | null | undefined, vendor_SsicCodeId: number | null | undefined, vendor_SsicCodeFk_TenantId: number | null | undefined, vendor_SsicCodeFk_Code: string, vendor_SsicCodeFk_SSIC: string, vendor_SsicCodeFk_IsDeleted: boolean | null | undefined, vendor_SsicCodeFk_DeleterUserId: number | null | undefined, vendor_SsicCodeFk_DeletionTime: moment.Moment | null | undefined, vendor_SsicCodeFk_LastModificationTime: moment.Moment | null | undefined, vendor_SsicCodeFk_LastModifierUserId: number | null | undefined, vendor_SsicCodeFk_CreationTime: moment.Moment | null | undefined, vendor_SsicCodeFk_CreatorUserId: number | null | undefined, vendor_SsicCodeFk_Id: number | null | undefined, vendor_CurrencyId: number | null | undefined, vendor_CurrencyFk_TenantId: number | null | undefined, vendor_CurrencyFk_Code: string, vendor_CurrencyFk_Name: string, vendor_CurrencyFk_Symbol: string | null | undefined, vendor_CurrencyFk_Country: string, vendor_CurrencyFk_BaseCountry: string, vendor_CurrencyFk_IsDeleted: boolean | null | undefined, vendor_CurrencyFk_DeleterUserId: number | null | undefined, vendor_CurrencyFk_DeletionTime: moment.Moment | null | undefined, vendor_CurrencyFk_LastModificationTime: moment.Moment | null | undefined, vendor_CurrencyFk_LastModifierUserId: number | null | undefined, vendor_CurrencyFk_CreationTime: moment.Moment | null | undefined, vendor_CurrencyFk_CreatorUserId: number | null | undefined, vendor_CurrencyFk_Id: number | null | undefined, vendor_IsDeleted: boolean | null | undefined, vendor_DeleterUserId: number | null | undefined, vendor_DeletionTime: moment.Moment | null | undefined, vendor_LastModificationTime: moment.Moment | null | undefined, vendor_LastModifierUserId: number | null | undefined, vendor_CreationTime: moment.Moment | null | undefined, vendor_CreatorUserId: number | null | undefined, vendor_Id: number | null | undefined, assetOwner_TenantId: number | null | undefined, assetOwner_Reference: string, assetOwner_Name: string, assetOwner_Identifier: string | null | undefined, assetOwner_LogoUrl: string | null | undefined, assetOwner_Website: string | null | undefined, assetOwner_CurrencyId: number | null | undefined, assetOwner_CurrencyFk_TenantId: number | null | undefined, assetOwner_CurrencyFk_Code: string, assetOwner_CurrencyFk_Name: string, assetOwner_CurrencyFk_Symbol: string | null | undefined, assetOwner_CurrencyFk_Country: string, assetOwner_CurrencyFk_BaseCountry: string, assetOwner_CurrencyFk_IsDeleted: boolean | null | undefined, assetOwner_CurrencyFk_DeleterUserId: number | null | undefined, assetOwner_CurrencyFk_DeletionTime: moment.Moment | null | undefined, assetOwner_CurrencyFk_LastModificationTime: moment.Moment | null | undefined, assetOwner_CurrencyFk_LastModifierUserId: number | null | undefined, assetOwner_CurrencyFk_CreationTime: moment.Moment | null | undefined, assetOwner_CurrencyFk_CreatorUserId: number | null | undefined, assetOwner_CurrencyFk_Id: number | null | undefined, assetOwner_SsicCodeId: number | null | undefined, assetOwner_SsicCodeFk_TenantId: number | null | undefined, assetOwner_SsicCodeFk_Code: string, assetOwner_SsicCodeFk_SSIC: string, assetOwner_SsicCodeFk_IsDeleted: boolean | null | undefined, assetOwner_SsicCodeFk_DeleterUserId: number | null | undefined, assetOwner_SsicCodeFk_DeletionTime: moment.Moment | null | undefined, assetOwner_SsicCodeFk_LastModificationTime: moment.Moment | null | undefined, assetOwner_SsicCodeFk_LastModifierUserId: number | null | undefined, assetOwner_SsicCodeFk_CreationTime: moment.Moment | null | undefined, assetOwner_SsicCodeFk_CreatorUserId: number | null | undefined, assetOwner_SsicCodeFk_Id: number | null | undefined, assetOwner_IsDeleted: boolean | null | undefined, assetOwner_DeleterUserId: number | null | undefined, assetOwner_DeletionTime: moment.Moment | null | undefined, assetOwner_LastModificationTime: moment.Moment | null | undefined, assetOwner_LastModifierUserId: number | null | undefined, assetOwner_CreationTime: moment.Moment | null | undefined, assetOwner_CreatorUserId: number | null | undefined, assetOwner_Id: number | null | undefined, isHost: boolean | null | undefined): Observable<AgedReceivablesData[]> {
        let url_ = this.baseUrl + "/api/services/app/TenantDashboard/GetAgedReceivablesData?";
        if (tenant_TenantType !== undefined)
            url_ += "Tenant.TenantType=" + encodeURIComponent("" + tenant_TenantType) + "&"; 
        if (tenant_SubscriptionEndDateUtc !== undefined)
            url_ += "Tenant.SubscriptionEndDateUtc=" + encodeURIComponent(tenant_SubscriptionEndDateUtc ? "" + tenant_SubscriptionEndDateUtc.toJSON() : "") + "&"; 
        if (tenant_IsInTrialPeriod !== undefined)
            url_ += "Tenant.IsInTrialPeriod=" + encodeURIComponent("" + tenant_IsInTrialPeriod) + "&"; 
        if (tenant_CustomCssId !== undefined)
            url_ += "Tenant.CustomCssId=" + encodeURIComponent("" + tenant_CustomCssId) + "&"; 
        if (tenant_LogoId !== undefined)
            url_ += "Tenant.LogoId=" + encodeURIComponent("" + tenant_LogoId) + "&"; 
        if (tenant_LogoFileType !== undefined)
            url_ += "Tenant.LogoFileType=" + encodeURIComponent("" + tenant_LogoFileType) + "&"; 
        if (tenant_SubscriptionPaymentType === undefined || tenant_SubscriptionPaymentType === null)
            throw new Error("The parameter 'tenant_SubscriptionPaymentType' must be defined and cannot be null.");
        else
            url_ += "Tenant.SubscriptionPaymentType=" + encodeURIComponent("" + tenant_SubscriptionPaymentType) + "&"; 
        if (tenant_Edition_Name === undefined || tenant_Edition_Name === null)
            throw new Error("The parameter 'tenant_Edition_Name' must be defined and cannot be null.");
        else
            url_ += "Tenant.Edition.Name=" + encodeURIComponent("" + tenant_Edition_Name) + "&"; 
        if (tenant_Edition_DisplayName === undefined || tenant_Edition_DisplayName === null)
            throw new Error("The parameter 'tenant_Edition_DisplayName' must be defined and cannot be null.");
        else
            url_ += "Tenant.Edition.DisplayName=" + encodeURIComponent("" + tenant_Edition_DisplayName) + "&"; 
        if (tenant_Edition_IsDeleted !== undefined)
            url_ += "Tenant.Edition.IsDeleted=" + encodeURIComponent("" + tenant_Edition_IsDeleted) + "&"; 
        if (tenant_Edition_DeleterUserId !== undefined)
            url_ += "Tenant.Edition.DeleterUserId=" + encodeURIComponent("" + tenant_Edition_DeleterUserId) + "&"; 
        if (tenant_Edition_DeletionTime !== undefined)
            url_ += "Tenant.Edition.DeletionTime=" + encodeURIComponent(tenant_Edition_DeletionTime ? "" + tenant_Edition_DeletionTime.toJSON() : "") + "&"; 
        if (tenant_Edition_LastModificationTime !== undefined)
            url_ += "Tenant.Edition.LastModificationTime=" + encodeURIComponent(tenant_Edition_LastModificationTime ? "" + tenant_Edition_LastModificationTime.toJSON() : "") + "&"; 
        if (tenant_Edition_LastModifierUserId !== undefined)
            url_ += "Tenant.Edition.LastModifierUserId=" + encodeURIComponent("" + tenant_Edition_LastModifierUserId) + "&"; 
        if (tenant_Edition_CreationTime !== undefined)
            url_ += "Tenant.Edition.CreationTime=" + encodeURIComponent(tenant_Edition_CreationTime ? "" + tenant_Edition_CreationTime.toJSON() : "") + "&"; 
        if (tenant_Edition_CreatorUserId !== undefined)
            url_ += "Tenant.Edition.CreatorUserId=" + encodeURIComponent("" + tenant_Edition_CreatorUserId) + "&"; 
        if (tenant_Edition_Id !== undefined)
            url_ += "Tenant.Edition.Id=" + encodeURIComponent("" + tenant_Edition_Id) + "&"; 
        if (tenant_EditionId !== undefined)
            url_ += "Tenant.EditionId=" + encodeURIComponent("" + tenant_EditionId) + "&"; 
        if (tenant_CreatorUser_ProfilePictureId !== undefined)
            url_ += "Tenant.CreatorUser.ProfilePictureId=" + encodeURIComponent("" + tenant_CreatorUser_ProfilePictureId) + "&"; 
        if (tenant_CreatorUser_ShouldChangePasswordOnNextLogin !== undefined)
            url_ += "Tenant.CreatorUser.ShouldChangePasswordOnNextLogin=" + encodeURIComponent("" + tenant_CreatorUser_ShouldChangePasswordOnNextLogin) + "&"; 
        if (tenant_CreatorUser_SignInTokenExpireTimeUtc !== undefined)
            url_ += "Tenant.CreatorUser.SignInTokenExpireTimeUtc=" + encodeURIComponent(tenant_CreatorUser_SignInTokenExpireTimeUtc ? "" + tenant_CreatorUser_SignInTokenExpireTimeUtc.toJSON() : "") + "&"; 
        if (tenant_CreatorUser_SignInToken !== undefined)
            url_ += "Tenant.CreatorUser.SignInToken=" + encodeURIComponent("" + tenant_CreatorUser_SignInToken) + "&"; 
        if (tenant_CreatorUser_GoogleAuthenticatorKey !== undefined)
            url_ += "Tenant.CreatorUser.GoogleAuthenticatorKey=" + encodeURIComponent("" + tenant_CreatorUser_GoogleAuthenticatorKey) + "&"; 
        if (tenant_CreatorUser_OrganizationUnits !== undefined)
            tenant_CreatorUser_OrganizationUnits && tenant_CreatorUser_OrganizationUnits.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Tenant.CreatorUser.OrganizationUnits[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (tenant_CreatorUser_NormalizedUserName === undefined || tenant_CreatorUser_NormalizedUserName === null)
            throw new Error("The parameter 'tenant_CreatorUser_NormalizedUserName' must be defined and cannot be null.");
        else
            url_ += "Tenant.CreatorUser.NormalizedUserName=" + encodeURIComponent("" + tenant_CreatorUser_NormalizedUserName) + "&"; 
        if (tenant_CreatorUser_NormalizedEmailAddress === undefined || tenant_CreatorUser_NormalizedEmailAddress === null)
            throw new Error("The parameter 'tenant_CreatorUser_NormalizedEmailAddress' must be defined and cannot be null.");
        else
            url_ += "Tenant.CreatorUser.NormalizedEmailAddress=" + encodeURIComponent("" + tenant_CreatorUser_NormalizedEmailAddress) + "&"; 
        if (tenant_CreatorUser_ConcurrencyStamp !== undefined)
            url_ += "Tenant.CreatorUser.ConcurrencyStamp=" + encodeURIComponent("" + tenant_CreatorUser_ConcurrencyStamp) + "&"; 
        if (tenant_CreatorUser_Tokens !== undefined)
            tenant_CreatorUser_Tokens && tenant_CreatorUser_Tokens.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Tenant.CreatorUser.Tokens[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (tenant_CreatorUser_DeleterUser_ProfilePictureId !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.ProfilePictureId=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_ProfilePictureId) + "&"; 
        if (tenant_CreatorUser_DeleterUser_ShouldChangePasswordOnNextLogin !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.ShouldChangePasswordOnNextLogin=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_ShouldChangePasswordOnNextLogin) + "&"; 
        if (tenant_CreatorUser_DeleterUser_SignInTokenExpireTimeUtc !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.SignInTokenExpireTimeUtc=" + encodeURIComponent(tenant_CreatorUser_DeleterUser_SignInTokenExpireTimeUtc ? "" + tenant_CreatorUser_DeleterUser_SignInTokenExpireTimeUtc.toJSON() : "") + "&"; 
        if (tenant_CreatorUser_DeleterUser_SignInToken !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.SignInToken=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_SignInToken) + "&"; 
        if (tenant_CreatorUser_DeleterUser_GoogleAuthenticatorKey !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.GoogleAuthenticatorKey=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_GoogleAuthenticatorKey) + "&"; 
        if (tenant_CreatorUser_DeleterUser_OrganizationUnits !== undefined)
            tenant_CreatorUser_DeleterUser_OrganizationUnits && tenant_CreatorUser_DeleterUser_OrganizationUnits.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Tenant.CreatorUser.DeleterUser.OrganizationUnits[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (tenant_CreatorUser_DeleterUser_NormalizedUserName === undefined || tenant_CreatorUser_DeleterUser_NormalizedUserName === null)
            throw new Error("The parameter 'tenant_CreatorUser_DeleterUser_NormalizedUserName' must be defined and cannot be null.");
        else
            url_ += "Tenant.CreatorUser.DeleterUser.NormalizedUserName=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_NormalizedUserName) + "&"; 
        if (tenant_CreatorUser_DeleterUser_NormalizedEmailAddress === undefined || tenant_CreatorUser_DeleterUser_NormalizedEmailAddress === null)
            throw new Error("The parameter 'tenant_CreatorUser_DeleterUser_NormalizedEmailAddress' must be defined and cannot be null.");
        else
            url_ += "Tenant.CreatorUser.DeleterUser.NormalizedEmailAddress=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_NormalizedEmailAddress) + "&"; 
        if (tenant_CreatorUser_DeleterUser_ConcurrencyStamp !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.ConcurrencyStamp=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_ConcurrencyStamp) + "&"; 
        if (tenant_CreatorUser_DeleterUser_Tokens !== undefined)
            tenant_CreatorUser_DeleterUser_Tokens && tenant_CreatorUser_DeleterUser_Tokens.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Tenant.CreatorUser.DeleterUser.Tokens[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (tenant_CreatorUser_DeleterUser_DeleterUser !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.DeleterUser=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_DeleterUser) + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_ProfilePictureId !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.ProfilePictureId=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_CreatorUser_ProfilePictureId) + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_ShouldChangePasswordOnNextLogin !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.ShouldChangePasswordOnNextLogin=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_CreatorUser_ShouldChangePasswordOnNextLogin) + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_SignInTokenExpireTimeUtc !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.SignInTokenExpireTimeUtc=" + encodeURIComponent(tenant_CreatorUser_DeleterUser_CreatorUser_SignInTokenExpireTimeUtc ? "" + tenant_CreatorUser_DeleterUser_CreatorUser_SignInTokenExpireTimeUtc.toJSON() : "") + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_SignInToken !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.SignInToken=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_CreatorUser_SignInToken) + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_GoogleAuthenticatorKey !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.GoogleAuthenticatorKey=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_CreatorUser_GoogleAuthenticatorKey) + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_OrganizationUnits !== undefined)
            tenant_CreatorUser_DeleterUser_CreatorUser_OrganizationUnits && tenant_CreatorUser_DeleterUser_CreatorUser_OrganizationUnits.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.OrganizationUnits[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (tenant_CreatorUser_DeleterUser_CreatorUser_NormalizedUserName === undefined || tenant_CreatorUser_DeleterUser_CreatorUser_NormalizedUserName === null)
            throw new Error("The parameter 'tenant_CreatorUser_DeleterUser_CreatorUser_NormalizedUserName' must be defined and cannot be null.");
        else
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.NormalizedUserName=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_CreatorUser_NormalizedUserName) + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_NormalizedEmailAddress === undefined || tenant_CreatorUser_DeleterUser_CreatorUser_NormalizedEmailAddress === null)
            throw new Error("The parameter 'tenant_CreatorUser_DeleterUser_CreatorUser_NormalizedEmailAddress' must be defined and cannot be null.");
        else
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.NormalizedEmailAddress=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_CreatorUser_NormalizedEmailAddress) + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_ConcurrencyStamp !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.ConcurrencyStamp=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_CreatorUser_ConcurrencyStamp) + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_Tokens !== undefined)
            tenant_CreatorUser_DeleterUser_CreatorUser_Tokens && tenant_CreatorUser_DeleterUser_CreatorUser_Tokens.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.Tokens[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (tenant_CreatorUser_DeleterUser_CreatorUser_DeleterUser !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.DeleterUser=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_CreatorUser_DeleterUser) + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_CreatorUser !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.CreatorUser=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_CreatorUser_CreatorUser) + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_ProfilePictureId !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.LastModifierUser.ProfilePictureId=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_ProfilePictureId) + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_ShouldChangePasswordOnNextLogin !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.LastModifierUser.ShouldChangePasswordOnNextLogin=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_ShouldChangePasswordOnNextLogin) + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_SignInTokenExpireTimeUtc !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.LastModifierUser.SignInTokenExpireTimeUtc=" + encodeURIComponent(tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_SignInTokenExpireTimeUtc ? "" + tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_SignInTokenExpireTimeUtc.toJSON() : "") + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_SignInToken !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.LastModifierUser.SignInToken=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_SignInToken) + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_GoogleAuthenticatorKey !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.LastModifierUser.GoogleAuthenticatorKey=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_GoogleAuthenticatorKey) + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_OrganizationUnits !== undefined)
            tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_OrganizationUnits && tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_OrganizationUnits.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.LastModifierUser.OrganizationUnits[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_NormalizedUserName === undefined || tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_NormalizedUserName === null)
            throw new Error("The parameter 'tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_NormalizedUserName' must be defined and cannot be null.");
        else
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.LastModifierUser.NormalizedUserName=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_NormalizedUserName) + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_NormalizedEmailAddress === undefined || tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_NormalizedEmailAddress === null)
            throw new Error("The parameter 'tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_NormalizedEmailAddress' must be defined and cannot be null.");
        else
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.LastModifierUser.NormalizedEmailAddress=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_NormalizedEmailAddress) + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_ConcurrencyStamp !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.LastModifierUser.ConcurrencyStamp=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_ConcurrencyStamp) + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_Tokens !== undefined)
            tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_Tokens && tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_Tokens.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.LastModifierUser.Tokens[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_DeleterUser !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.LastModifierUser.DeleterUser=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_DeleterUser) + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_CreatorUser !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.LastModifierUser.CreatorUser=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_CreatorUser) + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_LastModifierUser !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.LastModifierUser.LastModifierUser=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_LastModifierUser) + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_AuthenticationSource !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.LastModifierUser.AuthenticationSource=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_AuthenticationSource) + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_UserName === undefined || tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_UserName === null)
            throw new Error("The parameter 'tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_UserName' must be defined and cannot be null.");
        else
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.LastModifierUser.UserName=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_UserName) + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_TenantId !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.LastModifierUser.TenantId=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_TenantId) + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_EmailAddress === undefined || tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_EmailAddress === null)
            throw new Error("The parameter 'tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_EmailAddress' must be defined and cannot be null.");
        else
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.LastModifierUser.EmailAddress=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_EmailAddress) + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_Name === undefined || tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_Name === null)
            throw new Error("The parameter 'tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_Name' must be defined and cannot be null.");
        else
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.LastModifierUser.Name=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_Name) + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_Surname === undefined || tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_Surname === null)
            throw new Error("The parameter 'tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_Surname' must be defined and cannot be null.");
        else
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.LastModifierUser.Surname=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_Surname) + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_FullName !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.LastModifierUser.FullName=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_FullName) + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_Password === undefined || tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_Password === null)
            throw new Error("The parameter 'tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_Password' must be defined and cannot be null.");
        else
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.LastModifierUser.Password=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_Password) + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_EmailConfirmationCode !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.LastModifierUser.EmailConfirmationCode=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_EmailConfirmationCode) + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_PasswordResetCode !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.LastModifierUser.PasswordResetCode=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_PasswordResetCode) + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_LockoutEndDateUtc !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.LastModifierUser.LockoutEndDateUtc=" + encodeURIComponent(tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_LockoutEndDateUtc ? "" + tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_LockoutEndDateUtc.toJSON() : "") + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_AccessFailedCount !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.LastModifierUser.AccessFailedCount=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_AccessFailedCount) + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_IsLockoutEnabled !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.LastModifierUser.IsLockoutEnabled=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_IsLockoutEnabled) + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_PhoneNumber !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.LastModifierUser.PhoneNumber=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_PhoneNumber) + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_IsPhoneNumberConfirmed !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.LastModifierUser.IsPhoneNumberConfirmed=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_IsPhoneNumberConfirmed) + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_SecurityStamp !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.LastModifierUser.SecurityStamp=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_SecurityStamp) + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_IsTwoFactorEnabled !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.LastModifierUser.IsTwoFactorEnabled=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_IsTwoFactorEnabled) + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_Logins !== undefined)
            tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_Logins && tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_Logins.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.LastModifierUser.Logins[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_Roles !== undefined)
            tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_Roles && tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_Roles.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.LastModifierUser.Roles[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_Claims !== undefined)
            tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_Claims && tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_Claims.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.LastModifierUser.Claims[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_Permissions !== undefined)
            tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_Permissions && tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_Permissions.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.LastModifierUser.Permissions[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_Settings !== undefined)
            tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_Settings && tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_Settings.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.LastModifierUser.Settings[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_IsEmailConfirmed !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.LastModifierUser.IsEmailConfirmed=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_IsEmailConfirmed) + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_IsActive !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.LastModifierUser.IsActive=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_IsActive) + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_IsDeleted !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.LastModifierUser.IsDeleted=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_IsDeleted) + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_DeleterUserId !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.LastModifierUser.DeleterUserId=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_DeleterUserId) + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_DeletionTime !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.LastModifierUser.DeletionTime=" + encodeURIComponent(tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_DeletionTime ? "" + tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_DeletionTime.toJSON() : "") + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_LastModificationTime !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.LastModifierUser.LastModificationTime=" + encodeURIComponent(tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_LastModificationTime ? "" + tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_LastModificationTime.toJSON() : "") + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_LastModifierUserId !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.LastModifierUser.LastModifierUserId=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_LastModifierUserId) + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_CreationTime !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.LastModifierUser.CreationTime=" + encodeURIComponent(tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_CreationTime ? "" + tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_CreationTime.toJSON() : "") + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_CreatorUserId !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.LastModifierUser.CreatorUserId=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_CreatorUserId) + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_Id !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.LastModifierUser.Id=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUser_Id) + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_AuthenticationSource !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.AuthenticationSource=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_CreatorUser_AuthenticationSource) + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_UserName === undefined || tenant_CreatorUser_DeleterUser_CreatorUser_UserName === null)
            throw new Error("The parameter 'tenant_CreatorUser_DeleterUser_CreatorUser_UserName' must be defined and cannot be null.");
        else
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.UserName=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_CreatorUser_UserName) + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_TenantId !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.TenantId=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_CreatorUser_TenantId) + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_EmailAddress === undefined || tenant_CreatorUser_DeleterUser_CreatorUser_EmailAddress === null)
            throw new Error("The parameter 'tenant_CreatorUser_DeleterUser_CreatorUser_EmailAddress' must be defined and cannot be null.");
        else
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.EmailAddress=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_CreatorUser_EmailAddress) + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_Name === undefined || tenant_CreatorUser_DeleterUser_CreatorUser_Name === null)
            throw new Error("The parameter 'tenant_CreatorUser_DeleterUser_CreatorUser_Name' must be defined and cannot be null.");
        else
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.Name=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_CreatorUser_Name) + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_Surname === undefined || tenant_CreatorUser_DeleterUser_CreatorUser_Surname === null)
            throw new Error("The parameter 'tenant_CreatorUser_DeleterUser_CreatorUser_Surname' must be defined and cannot be null.");
        else
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.Surname=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_CreatorUser_Surname) + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_FullName !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.FullName=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_CreatorUser_FullName) + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_Password === undefined || tenant_CreatorUser_DeleterUser_CreatorUser_Password === null)
            throw new Error("The parameter 'tenant_CreatorUser_DeleterUser_CreatorUser_Password' must be defined and cannot be null.");
        else
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.Password=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_CreatorUser_Password) + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_EmailConfirmationCode !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.EmailConfirmationCode=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_CreatorUser_EmailConfirmationCode) + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_PasswordResetCode !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.PasswordResetCode=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_CreatorUser_PasswordResetCode) + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_LockoutEndDateUtc !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.LockoutEndDateUtc=" + encodeURIComponent(tenant_CreatorUser_DeleterUser_CreatorUser_LockoutEndDateUtc ? "" + tenant_CreatorUser_DeleterUser_CreatorUser_LockoutEndDateUtc.toJSON() : "") + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_AccessFailedCount !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.AccessFailedCount=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_CreatorUser_AccessFailedCount) + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_IsLockoutEnabled !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.IsLockoutEnabled=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_CreatorUser_IsLockoutEnabled) + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_PhoneNumber !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.PhoneNumber=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_CreatorUser_PhoneNumber) + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_IsPhoneNumberConfirmed !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.IsPhoneNumberConfirmed=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_CreatorUser_IsPhoneNumberConfirmed) + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_SecurityStamp !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.SecurityStamp=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_CreatorUser_SecurityStamp) + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_IsTwoFactorEnabled !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.IsTwoFactorEnabled=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_CreatorUser_IsTwoFactorEnabled) + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_Logins !== undefined)
            tenant_CreatorUser_DeleterUser_CreatorUser_Logins && tenant_CreatorUser_DeleterUser_CreatorUser_Logins.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.Logins[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (tenant_CreatorUser_DeleterUser_CreatorUser_Roles !== undefined)
            tenant_CreatorUser_DeleterUser_CreatorUser_Roles && tenant_CreatorUser_DeleterUser_CreatorUser_Roles.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.Roles[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (tenant_CreatorUser_DeleterUser_CreatorUser_Claims !== undefined)
            tenant_CreatorUser_DeleterUser_CreatorUser_Claims && tenant_CreatorUser_DeleterUser_CreatorUser_Claims.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.Claims[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (tenant_CreatorUser_DeleterUser_CreatorUser_Permissions !== undefined)
            tenant_CreatorUser_DeleterUser_CreatorUser_Permissions && tenant_CreatorUser_DeleterUser_CreatorUser_Permissions.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.Permissions[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (tenant_CreatorUser_DeleterUser_CreatorUser_Settings !== undefined)
            tenant_CreatorUser_DeleterUser_CreatorUser_Settings && tenant_CreatorUser_DeleterUser_CreatorUser_Settings.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.Settings[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (tenant_CreatorUser_DeleterUser_CreatorUser_IsEmailConfirmed !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.IsEmailConfirmed=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_CreatorUser_IsEmailConfirmed) + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_IsActive !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.IsActive=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_CreatorUser_IsActive) + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_IsDeleted !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.IsDeleted=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_CreatorUser_IsDeleted) + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_DeleterUserId !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.DeleterUserId=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_CreatorUser_DeleterUserId) + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_DeletionTime !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.DeletionTime=" + encodeURIComponent(tenant_CreatorUser_DeleterUser_CreatorUser_DeletionTime ? "" + tenant_CreatorUser_DeleterUser_CreatorUser_DeletionTime.toJSON() : "") + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_LastModificationTime !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.LastModificationTime=" + encodeURIComponent(tenant_CreatorUser_DeleterUser_CreatorUser_LastModificationTime ? "" + tenant_CreatorUser_DeleterUser_CreatorUser_LastModificationTime.toJSON() : "") + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUserId !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.LastModifierUserId=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_CreatorUser_LastModifierUserId) + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_CreationTime !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.CreationTime=" + encodeURIComponent(tenant_CreatorUser_DeleterUser_CreatorUser_CreationTime ? "" + tenant_CreatorUser_DeleterUser_CreatorUser_CreationTime.toJSON() : "") + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_CreatorUserId !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.CreatorUserId=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_CreatorUser_CreatorUserId) + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUser_Id !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUser.Id=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_CreatorUser_Id) + "&"; 
        if (tenant_CreatorUser_DeleterUser_LastModifierUser !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.LastModifierUser=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_LastModifierUser) + "&"; 
        if (tenant_CreatorUser_DeleterUser_AuthenticationSource !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.AuthenticationSource=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_AuthenticationSource) + "&"; 
        if (tenant_CreatorUser_DeleterUser_UserName === undefined || tenant_CreatorUser_DeleterUser_UserName === null)
            throw new Error("The parameter 'tenant_CreatorUser_DeleterUser_UserName' must be defined and cannot be null.");
        else
            url_ += "Tenant.CreatorUser.DeleterUser.UserName=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_UserName) + "&"; 
        if (tenant_CreatorUser_DeleterUser_TenantId !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.TenantId=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_TenantId) + "&"; 
        if (tenant_CreatorUser_DeleterUser_EmailAddress === undefined || tenant_CreatorUser_DeleterUser_EmailAddress === null)
            throw new Error("The parameter 'tenant_CreatorUser_DeleterUser_EmailAddress' must be defined and cannot be null.");
        else
            url_ += "Tenant.CreatorUser.DeleterUser.EmailAddress=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_EmailAddress) + "&"; 
        if (tenant_CreatorUser_DeleterUser_Name === undefined || tenant_CreatorUser_DeleterUser_Name === null)
            throw new Error("The parameter 'tenant_CreatorUser_DeleterUser_Name' must be defined and cannot be null.");
        else
            url_ += "Tenant.CreatorUser.DeleterUser.Name=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_Name) + "&"; 
        if (tenant_CreatorUser_DeleterUser_Surname === undefined || tenant_CreatorUser_DeleterUser_Surname === null)
            throw new Error("The parameter 'tenant_CreatorUser_DeleterUser_Surname' must be defined and cannot be null.");
        else
            url_ += "Tenant.CreatorUser.DeleterUser.Surname=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_Surname) + "&"; 
        if (tenant_CreatorUser_DeleterUser_FullName !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.FullName=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_FullName) + "&"; 
        if (tenant_CreatorUser_DeleterUser_Password === undefined || tenant_CreatorUser_DeleterUser_Password === null)
            throw new Error("The parameter 'tenant_CreatorUser_DeleterUser_Password' must be defined and cannot be null.");
        else
            url_ += "Tenant.CreatorUser.DeleterUser.Password=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_Password) + "&"; 
        if (tenant_CreatorUser_DeleterUser_EmailConfirmationCode !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.EmailConfirmationCode=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_EmailConfirmationCode) + "&"; 
        if (tenant_CreatorUser_DeleterUser_PasswordResetCode !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.PasswordResetCode=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_PasswordResetCode) + "&"; 
        if (tenant_CreatorUser_DeleterUser_LockoutEndDateUtc !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.LockoutEndDateUtc=" + encodeURIComponent(tenant_CreatorUser_DeleterUser_LockoutEndDateUtc ? "" + tenant_CreatorUser_DeleterUser_LockoutEndDateUtc.toJSON() : "") + "&"; 
        if (tenant_CreatorUser_DeleterUser_AccessFailedCount !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.AccessFailedCount=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_AccessFailedCount) + "&"; 
        if (tenant_CreatorUser_DeleterUser_IsLockoutEnabled !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.IsLockoutEnabled=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_IsLockoutEnabled) + "&"; 
        if (tenant_CreatorUser_DeleterUser_PhoneNumber !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.PhoneNumber=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_PhoneNumber) + "&"; 
        if (tenant_CreatorUser_DeleterUser_IsPhoneNumberConfirmed !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.IsPhoneNumberConfirmed=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_IsPhoneNumberConfirmed) + "&"; 
        if (tenant_CreatorUser_DeleterUser_SecurityStamp !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.SecurityStamp=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_SecurityStamp) + "&"; 
        if (tenant_CreatorUser_DeleterUser_IsTwoFactorEnabled !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.IsTwoFactorEnabled=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_IsTwoFactorEnabled) + "&"; 
        if (tenant_CreatorUser_DeleterUser_Logins !== undefined)
            tenant_CreatorUser_DeleterUser_Logins && tenant_CreatorUser_DeleterUser_Logins.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Tenant.CreatorUser.DeleterUser.Logins[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (tenant_CreatorUser_DeleterUser_Roles !== undefined)
            tenant_CreatorUser_DeleterUser_Roles && tenant_CreatorUser_DeleterUser_Roles.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Tenant.CreatorUser.DeleterUser.Roles[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (tenant_CreatorUser_DeleterUser_Claims !== undefined)
            tenant_CreatorUser_DeleterUser_Claims && tenant_CreatorUser_DeleterUser_Claims.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Tenant.CreatorUser.DeleterUser.Claims[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (tenant_CreatorUser_DeleterUser_Permissions !== undefined)
            tenant_CreatorUser_DeleterUser_Permissions && tenant_CreatorUser_DeleterUser_Permissions.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Tenant.CreatorUser.DeleterUser.Permissions[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (tenant_CreatorUser_DeleterUser_Settings !== undefined)
            tenant_CreatorUser_DeleterUser_Settings && tenant_CreatorUser_DeleterUser_Settings.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Tenant.CreatorUser.DeleterUser.Settings[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (tenant_CreatorUser_DeleterUser_IsEmailConfirmed !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.IsEmailConfirmed=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_IsEmailConfirmed) + "&"; 
        if (tenant_CreatorUser_DeleterUser_IsActive !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.IsActive=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_IsActive) + "&"; 
        if (tenant_CreatorUser_DeleterUser_IsDeleted !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.IsDeleted=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_IsDeleted) + "&"; 
        if (tenant_CreatorUser_DeleterUser_DeleterUserId !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.DeleterUserId=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_DeleterUserId) + "&"; 
        if (tenant_CreatorUser_DeleterUser_DeletionTime !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.DeletionTime=" + encodeURIComponent(tenant_CreatorUser_DeleterUser_DeletionTime ? "" + tenant_CreatorUser_DeleterUser_DeletionTime.toJSON() : "") + "&"; 
        if (tenant_CreatorUser_DeleterUser_LastModificationTime !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.LastModificationTime=" + encodeURIComponent(tenant_CreatorUser_DeleterUser_LastModificationTime ? "" + tenant_CreatorUser_DeleterUser_LastModificationTime.toJSON() : "") + "&"; 
        if (tenant_CreatorUser_DeleterUser_LastModifierUserId !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.LastModifierUserId=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_LastModifierUserId) + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreationTime !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.CreationTime=" + encodeURIComponent(tenant_CreatorUser_DeleterUser_CreationTime ? "" + tenant_CreatorUser_DeleterUser_CreationTime.toJSON() : "") + "&"; 
        if (tenant_CreatorUser_DeleterUser_CreatorUserId !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.CreatorUserId=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_CreatorUserId) + "&"; 
        if (tenant_CreatorUser_DeleterUser_Id !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUser.Id=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUser_Id) + "&"; 
        if (tenant_CreatorUser_CreatorUser !== undefined)
            url_ += "Tenant.CreatorUser.CreatorUser=" + encodeURIComponent("" + tenant_CreatorUser_CreatorUser) + "&"; 
        if (tenant_CreatorUser_LastModifierUser !== undefined)
            url_ += "Tenant.CreatorUser.LastModifierUser=" + encodeURIComponent("" + tenant_CreatorUser_LastModifierUser) + "&"; 
        if (tenant_CreatorUser_AuthenticationSource !== undefined)
            url_ += "Tenant.CreatorUser.AuthenticationSource=" + encodeURIComponent("" + tenant_CreatorUser_AuthenticationSource) + "&"; 
        if (tenant_CreatorUser_UserName === undefined || tenant_CreatorUser_UserName === null)
            throw new Error("The parameter 'tenant_CreatorUser_UserName' must be defined and cannot be null.");
        else
            url_ += "Tenant.CreatorUser.UserName=" + encodeURIComponent("" + tenant_CreatorUser_UserName) + "&"; 
        if (tenant_CreatorUser_TenantId !== undefined)
            url_ += "Tenant.CreatorUser.TenantId=" + encodeURIComponent("" + tenant_CreatorUser_TenantId) + "&"; 
        if (tenant_CreatorUser_EmailAddress === undefined || tenant_CreatorUser_EmailAddress === null)
            throw new Error("The parameter 'tenant_CreatorUser_EmailAddress' must be defined and cannot be null.");
        else
            url_ += "Tenant.CreatorUser.EmailAddress=" + encodeURIComponent("" + tenant_CreatorUser_EmailAddress) + "&"; 
        if (tenant_CreatorUser_Name === undefined || tenant_CreatorUser_Name === null)
            throw new Error("The parameter 'tenant_CreatorUser_Name' must be defined and cannot be null.");
        else
            url_ += "Tenant.CreatorUser.Name=" + encodeURIComponent("" + tenant_CreatorUser_Name) + "&"; 
        if (tenant_CreatorUser_Surname === undefined || tenant_CreatorUser_Surname === null)
            throw new Error("The parameter 'tenant_CreatorUser_Surname' must be defined and cannot be null.");
        else
            url_ += "Tenant.CreatorUser.Surname=" + encodeURIComponent("" + tenant_CreatorUser_Surname) + "&"; 
        if (tenant_CreatorUser_FullName !== undefined)
            url_ += "Tenant.CreatorUser.FullName=" + encodeURIComponent("" + tenant_CreatorUser_FullName) + "&"; 
        if (tenant_CreatorUser_Password === undefined || tenant_CreatorUser_Password === null)
            throw new Error("The parameter 'tenant_CreatorUser_Password' must be defined and cannot be null.");
        else
            url_ += "Tenant.CreatorUser.Password=" + encodeURIComponent("" + tenant_CreatorUser_Password) + "&"; 
        if (tenant_CreatorUser_EmailConfirmationCode !== undefined)
            url_ += "Tenant.CreatorUser.EmailConfirmationCode=" + encodeURIComponent("" + tenant_CreatorUser_EmailConfirmationCode) + "&"; 
        if (tenant_CreatorUser_PasswordResetCode !== undefined)
            url_ += "Tenant.CreatorUser.PasswordResetCode=" + encodeURIComponent("" + tenant_CreatorUser_PasswordResetCode) + "&"; 
        if (tenant_CreatorUser_LockoutEndDateUtc !== undefined)
            url_ += "Tenant.CreatorUser.LockoutEndDateUtc=" + encodeURIComponent(tenant_CreatorUser_LockoutEndDateUtc ? "" + tenant_CreatorUser_LockoutEndDateUtc.toJSON() : "") + "&"; 
        if (tenant_CreatorUser_AccessFailedCount !== undefined)
            url_ += "Tenant.CreatorUser.AccessFailedCount=" + encodeURIComponent("" + tenant_CreatorUser_AccessFailedCount) + "&"; 
        if (tenant_CreatorUser_IsLockoutEnabled !== undefined)
            url_ += "Tenant.CreatorUser.IsLockoutEnabled=" + encodeURIComponent("" + tenant_CreatorUser_IsLockoutEnabled) + "&"; 
        if (tenant_CreatorUser_PhoneNumber !== undefined)
            url_ += "Tenant.CreatorUser.PhoneNumber=" + encodeURIComponent("" + tenant_CreatorUser_PhoneNumber) + "&"; 
        if (tenant_CreatorUser_IsPhoneNumberConfirmed !== undefined)
            url_ += "Tenant.CreatorUser.IsPhoneNumberConfirmed=" + encodeURIComponent("" + tenant_CreatorUser_IsPhoneNumberConfirmed) + "&"; 
        if (tenant_CreatorUser_SecurityStamp !== undefined)
            url_ += "Tenant.CreatorUser.SecurityStamp=" + encodeURIComponent("" + tenant_CreatorUser_SecurityStamp) + "&"; 
        if (tenant_CreatorUser_IsTwoFactorEnabled !== undefined)
            url_ += "Tenant.CreatorUser.IsTwoFactorEnabled=" + encodeURIComponent("" + tenant_CreatorUser_IsTwoFactorEnabled) + "&"; 
        if (tenant_CreatorUser_Logins !== undefined)
            tenant_CreatorUser_Logins && tenant_CreatorUser_Logins.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Tenant.CreatorUser.Logins[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (tenant_CreatorUser_Roles !== undefined)
            tenant_CreatorUser_Roles && tenant_CreatorUser_Roles.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Tenant.CreatorUser.Roles[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (tenant_CreatorUser_Claims !== undefined)
            tenant_CreatorUser_Claims && tenant_CreatorUser_Claims.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Tenant.CreatorUser.Claims[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (tenant_CreatorUser_Permissions !== undefined)
            tenant_CreatorUser_Permissions && tenant_CreatorUser_Permissions.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Tenant.CreatorUser.Permissions[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (tenant_CreatorUser_Settings !== undefined)
            tenant_CreatorUser_Settings && tenant_CreatorUser_Settings.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Tenant.CreatorUser.Settings[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (tenant_CreatorUser_IsEmailConfirmed !== undefined)
            url_ += "Tenant.CreatorUser.IsEmailConfirmed=" + encodeURIComponent("" + tenant_CreatorUser_IsEmailConfirmed) + "&"; 
        if (tenant_CreatorUser_IsActive !== undefined)
            url_ += "Tenant.CreatorUser.IsActive=" + encodeURIComponent("" + tenant_CreatorUser_IsActive) + "&"; 
        if (tenant_CreatorUser_IsDeleted !== undefined)
            url_ += "Tenant.CreatorUser.IsDeleted=" + encodeURIComponent("" + tenant_CreatorUser_IsDeleted) + "&"; 
        if (tenant_CreatorUser_DeleterUserId !== undefined)
            url_ += "Tenant.CreatorUser.DeleterUserId=" + encodeURIComponent("" + tenant_CreatorUser_DeleterUserId) + "&"; 
        if (tenant_CreatorUser_DeletionTime !== undefined)
            url_ += "Tenant.CreatorUser.DeletionTime=" + encodeURIComponent(tenant_CreatorUser_DeletionTime ? "" + tenant_CreatorUser_DeletionTime.toJSON() : "") + "&"; 
        if (tenant_CreatorUser_LastModificationTime !== undefined)
            url_ += "Tenant.CreatorUser.LastModificationTime=" + encodeURIComponent(tenant_CreatorUser_LastModificationTime ? "" + tenant_CreatorUser_LastModificationTime.toJSON() : "") + "&"; 
        if (tenant_CreatorUser_LastModifierUserId !== undefined)
            url_ += "Tenant.CreatorUser.LastModifierUserId=" + encodeURIComponent("" + tenant_CreatorUser_LastModifierUserId) + "&"; 
        if (tenant_CreatorUser_CreationTime !== undefined)
            url_ += "Tenant.CreatorUser.CreationTime=" + encodeURIComponent(tenant_CreatorUser_CreationTime ? "" + tenant_CreatorUser_CreationTime.toJSON() : "") + "&"; 
        if (tenant_CreatorUser_CreatorUserId !== undefined)
            url_ += "Tenant.CreatorUser.CreatorUserId=" + encodeURIComponent("" + tenant_CreatorUser_CreatorUserId) + "&"; 
        if (tenant_CreatorUser_Id !== undefined)
            url_ += "Tenant.CreatorUser.Id=" + encodeURIComponent("" + tenant_CreatorUser_Id) + "&"; 
        if (tenant_LastModifierUser_ProfilePictureId !== undefined)
            url_ += "Tenant.LastModifierUser.ProfilePictureId=" + encodeURIComponent("" + tenant_LastModifierUser_ProfilePictureId) + "&"; 
        if (tenant_LastModifierUser_ShouldChangePasswordOnNextLogin !== undefined)
            url_ += "Tenant.LastModifierUser.ShouldChangePasswordOnNextLogin=" + encodeURIComponent("" + tenant_LastModifierUser_ShouldChangePasswordOnNextLogin) + "&"; 
        if (tenant_LastModifierUser_SignInTokenExpireTimeUtc !== undefined)
            url_ += "Tenant.LastModifierUser.SignInTokenExpireTimeUtc=" + encodeURIComponent(tenant_LastModifierUser_SignInTokenExpireTimeUtc ? "" + tenant_LastModifierUser_SignInTokenExpireTimeUtc.toJSON() : "") + "&"; 
        if (tenant_LastModifierUser_SignInToken !== undefined)
            url_ += "Tenant.LastModifierUser.SignInToken=" + encodeURIComponent("" + tenant_LastModifierUser_SignInToken) + "&"; 
        if (tenant_LastModifierUser_GoogleAuthenticatorKey !== undefined)
            url_ += "Tenant.LastModifierUser.GoogleAuthenticatorKey=" + encodeURIComponent("" + tenant_LastModifierUser_GoogleAuthenticatorKey) + "&"; 
        if (tenant_LastModifierUser_OrganizationUnits !== undefined)
            tenant_LastModifierUser_OrganizationUnits && tenant_LastModifierUser_OrganizationUnits.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Tenant.LastModifierUser.OrganizationUnits[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (tenant_LastModifierUser_NormalizedUserName === undefined || tenant_LastModifierUser_NormalizedUserName === null)
            throw new Error("The parameter 'tenant_LastModifierUser_NormalizedUserName' must be defined and cannot be null.");
        else
            url_ += "Tenant.LastModifierUser.NormalizedUserName=" + encodeURIComponent("" + tenant_LastModifierUser_NormalizedUserName) + "&"; 
        if (tenant_LastModifierUser_NormalizedEmailAddress === undefined || tenant_LastModifierUser_NormalizedEmailAddress === null)
            throw new Error("The parameter 'tenant_LastModifierUser_NormalizedEmailAddress' must be defined and cannot be null.");
        else
            url_ += "Tenant.LastModifierUser.NormalizedEmailAddress=" + encodeURIComponent("" + tenant_LastModifierUser_NormalizedEmailAddress) + "&"; 
        if (tenant_LastModifierUser_ConcurrencyStamp !== undefined)
            url_ += "Tenant.LastModifierUser.ConcurrencyStamp=" + encodeURIComponent("" + tenant_LastModifierUser_ConcurrencyStamp) + "&"; 
        if (tenant_LastModifierUser_Tokens !== undefined)
            tenant_LastModifierUser_Tokens && tenant_LastModifierUser_Tokens.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Tenant.LastModifierUser.Tokens[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (tenant_LastModifierUser_DeleterUser !== undefined)
            url_ += "Tenant.LastModifierUser.DeleterUser=" + encodeURIComponent("" + tenant_LastModifierUser_DeleterUser) + "&"; 
        if (tenant_LastModifierUser_CreatorUser !== undefined)
            url_ += "Tenant.LastModifierUser.CreatorUser=" + encodeURIComponent("" + tenant_LastModifierUser_CreatorUser) + "&"; 
        if (tenant_LastModifierUser_LastModifierUser !== undefined)
            url_ += "Tenant.LastModifierUser.LastModifierUser=" + encodeURIComponent("" + tenant_LastModifierUser_LastModifierUser) + "&"; 
        if (tenant_LastModifierUser_AuthenticationSource !== undefined)
            url_ += "Tenant.LastModifierUser.AuthenticationSource=" + encodeURIComponent("" + tenant_LastModifierUser_AuthenticationSource) + "&"; 
        if (tenant_LastModifierUser_UserName === undefined || tenant_LastModifierUser_UserName === null)
            throw new Error("The parameter 'tenant_LastModifierUser_UserName' must be defined and cannot be null.");
        else
            url_ += "Tenant.LastModifierUser.UserName=" + encodeURIComponent("" + tenant_LastModifierUser_UserName) + "&"; 
        if (tenant_LastModifierUser_TenantId !== undefined)
            url_ += "Tenant.LastModifierUser.TenantId=" + encodeURIComponent("" + tenant_LastModifierUser_TenantId) + "&"; 
        if (tenant_LastModifierUser_EmailAddress === undefined || tenant_LastModifierUser_EmailAddress === null)
            throw new Error("The parameter 'tenant_LastModifierUser_EmailAddress' must be defined and cannot be null.");
        else
            url_ += "Tenant.LastModifierUser.EmailAddress=" + encodeURIComponent("" + tenant_LastModifierUser_EmailAddress) + "&"; 
        if (tenant_LastModifierUser_Name === undefined || tenant_LastModifierUser_Name === null)
            throw new Error("The parameter 'tenant_LastModifierUser_Name' must be defined and cannot be null.");
        else
            url_ += "Tenant.LastModifierUser.Name=" + encodeURIComponent("" + tenant_LastModifierUser_Name) + "&"; 
        if (tenant_LastModifierUser_Surname === undefined || tenant_LastModifierUser_Surname === null)
            throw new Error("The parameter 'tenant_LastModifierUser_Surname' must be defined and cannot be null.");
        else
            url_ += "Tenant.LastModifierUser.Surname=" + encodeURIComponent("" + tenant_LastModifierUser_Surname) + "&"; 
        if (tenant_LastModifierUser_FullName !== undefined)
            url_ += "Tenant.LastModifierUser.FullName=" + encodeURIComponent("" + tenant_LastModifierUser_FullName) + "&"; 
        if (tenant_LastModifierUser_Password === undefined || tenant_LastModifierUser_Password === null)
            throw new Error("The parameter 'tenant_LastModifierUser_Password' must be defined and cannot be null.");
        else
            url_ += "Tenant.LastModifierUser.Password=" + encodeURIComponent("" + tenant_LastModifierUser_Password) + "&"; 
        if (tenant_LastModifierUser_EmailConfirmationCode !== undefined)
            url_ += "Tenant.LastModifierUser.EmailConfirmationCode=" + encodeURIComponent("" + tenant_LastModifierUser_EmailConfirmationCode) + "&"; 
        if (tenant_LastModifierUser_PasswordResetCode !== undefined)
            url_ += "Tenant.LastModifierUser.PasswordResetCode=" + encodeURIComponent("" + tenant_LastModifierUser_PasswordResetCode) + "&"; 
        if (tenant_LastModifierUser_LockoutEndDateUtc !== undefined)
            url_ += "Tenant.LastModifierUser.LockoutEndDateUtc=" + encodeURIComponent(tenant_LastModifierUser_LockoutEndDateUtc ? "" + tenant_LastModifierUser_LockoutEndDateUtc.toJSON() : "") + "&"; 
        if (tenant_LastModifierUser_AccessFailedCount !== undefined)
            url_ += "Tenant.LastModifierUser.AccessFailedCount=" + encodeURIComponent("" + tenant_LastModifierUser_AccessFailedCount) + "&"; 
        if (tenant_LastModifierUser_IsLockoutEnabled !== undefined)
            url_ += "Tenant.LastModifierUser.IsLockoutEnabled=" + encodeURIComponent("" + tenant_LastModifierUser_IsLockoutEnabled) + "&"; 
        if (tenant_LastModifierUser_PhoneNumber !== undefined)
            url_ += "Tenant.LastModifierUser.PhoneNumber=" + encodeURIComponent("" + tenant_LastModifierUser_PhoneNumber) + "&"; 
        if (tenant_LastModifierUser_IsPhoneNumberConfirmed !== undefined)
            url_ += "Tenant.LastModifierUser.IsPhoneNumberConfirmed=" + encodeURIComponent("" + tenant_LastModifierUser_IsPhoneNumberConfirmed) + "&"; 
        if (tenant_LastModifierUser_SecurityStamp !== undefined)
            url_ += "Tenant.LastModifierUser.SecurityStamp=" + encodeURIComponent("" + tenant_LastModifierUser_SecurityStamp) + "&"; 
        if (tenant_LastModifierUser_IsTwoFactorEnabled !== undefined)
            url_ += "Tenant.LastModifierUser.IsTwoFactorEnabled=" + encodeURIComponent("" + tenant_LastModifierUser_IsTwoFactorEnabled) + "&"; 
        if (tenant_LastModifierUser_Logins !== undefined)
            tenant_LastModifierUser_Logins && tenant_LastModifierUser_Logins.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Tenant.LastModifierUser.Logins[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (tenant_LastModifierUser_Roles !== undefined)
            tenant_LastModifierUser_Roles && tenant_LastModifierUser_Roles.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Tenant.LastModifierUser.Roles[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (tenant_LastModifierUser_Claims !== undefined)
            tenant_LastModifierUser_Claims && tenant_LastModifierUser_Claims.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Tenant.LastModifierUser.Claims[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (tenant_LastModifierUser_Permissions !== undefined)
            tenant_LastModifierUser_Permissions && tenant_LastModifierUser_Permissions.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Tenant.LastModifierUser.Permissions[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (tenant_LastModifierUser_Settings !== undefined)
            tenant_LastModifierUser_Settings && tenant_LastModifierUser_Settings.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Tenant.LastModifierUser.Settings[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (tenant_LastModifierUser_IsEmailConfirmed !== undefined)
            url_ += "Tenant.LastModifierUser.IsEmailConfirmed=" + encodeURIComponent("" + tenant_LastModifierUser_IsEmailConfirmed) + "&"; 
        if (tenant_LastModifierUser_IsActive !== undefined)
            url_ += "Tenant.LastModifierUser.IsActive=" + encodeURIComponent("" + tenant_LastModifierUser_IsActive) + "&"; 
        if (tenant_LastModifierUser_IsDeleted !== undefined)
            url_ += "Tenant.LastModifierUser.IsDeleted=" + encodeURIComponent("" + tenant_LastModifierUser_IsDeleted) + "&"; 
        if (tenant_LastModifierUser_DeleterUserId !== undefined)
            url_ += "Tenant.LastModifierUser.DeleterUserId=" + encodeURIComponent("" + tenant_LastModifierUser_DeleterUserId) + "&"; 
        if (tenant_LastModifierUser_DeletionTime !== undefined)
            url_ += "Tenant.LastModifierUser.DeletionTime=" + encodeURIComponent(tenant_LastModifierUser_DeletionTime ? "" + tenant_LastModifierUser_DeletionTime.toJSON() : "") + "&"; 
        if (tenant_LastModifierUser_LastModificationTime !== undefined)
            url_ += "Tenant.LastModifierUser.LastModificationTime=" + encodeURIComponent(tenant_LastModifierUser_LastModificationTime ? "" + tenant_LastModifierUser_LastModificationTime.toJSON() : "") + "&"; 
        if (tenant_LastModifierUser_LastModifierUserId !== undefined)
            url_ += "Tenant.LastModifierUser.LastModifierUserId=" + encodeURIComponent("" + tenant_LastModifierUser_LastModifierUserId) + "&"; 
        if (tenant_LastModifierUser_CreationTime !== undefined)
            url_ += "Tenant.LastModifierUser.CreationTime=" + encodeURIComponent(tenant_LastModifierUser_CreationTime ? "" + tenant_LastModifierUser_CreationTime.toJSON() : "") + "&"; 
        if (tenant_LastModifierUser_CreatorUserId !== undefined)
            url_ += "Tenant.LastModifierUser.CreatorUserId=" + encodeURIComponent("" + tenant_LastModifierUser_CreatorUserId) + "&"; 
        if (tenant_LastModifierUser_Id !== undefined)
            url_ += "Tenant.LastModifierUser.Id=" + encodeURIComponent("" + tenant_LastModifierUser_Id) + "&"; 
        if (tenant_DeleterUser_ProfilePictureId !== undefined)
            url_ += "Tenant.DeleterUser.ProfilePictureId=" + encodeURIComponent("" + tenant_DeleterUser_ProfilePictureId) + "&"; 
        if (tenant_DeleterUser_ShouldChangePasswordOnNextLogin !== undefined)
            url_ += "Tenant.DeleterUser.ShouldChangePasswordOnNextLogin=" + encodeURIComponent("" + tenant_DeleterUser_ShouldChangePasswordOnNextLogin) + "&"; 
        if (tenant_DeleterUser_SignInTokenExpireTimeUtc !== undefined)
            url_ += "Tenant.DeleterUser.SignInTokenExpireTimeUtc=" + encodeURIComponent(tenant_DeleterUser_SignInTokenExpireTimeUtc ? "" + tenant_DeleterUser_SignInTokenExpireTimeUtc.toJSON() : "") + "&"; 
        if (tenant_DeleterUser_SignInToken !== undefined)
            url_ += "Tenant.DeleterUser.SignInToken=" + encodeURIComponent("" + tenant_DeleterUser_SignInToken) + "&"; 
        if (tenant_DeleterUser_GoogleAuthenticatorKey !== undefined)
            url_ += "Tenant.DeleterUser.GoogleAuthenticatorKey=" + encodeURIComponent("" + tenant_DeleterUser_GoogleAuthenticatorKey) + "&"; 
        if (tenant_DeleterUser_OrganizationUnits !== undefined)
            tenant_DeleterUser_OrganizationUnits && tenant_DeleterUser_OrganizationUnits.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Tenant.DeleterUser.OrganizationUnits[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (tenant_DeleterUser_NormalizedUserName === undefined || tenant_DeleterUser_NormalizedUserName === null)
            throw new Error("The parameter 'tenant_DeleterUser_NormalizedUserName' must be defined and cannot be null.");
        else
            url_ += "Tenant.DeleterUser.NormalizedUserName=" + encodeURIComponent("" + tenant_DeleterUser_NormalizedUserName) + "&"; 
        if (tenant_DeleterUser_NormalizedEmailAddress === undefined || tenant_DeleterUser_NormalizedEmailAddress === null)
            throw new Error("The parameter 'tenant_DeleterUser_NormalizedEmailAddress' must be defined and cannot be null.");
        else
            url_ += "Tenant.DeleterUser.NormalizedEmailAddress=" + encodeURIComponent("" + tenant_DeleterUser_NormalizedEmailAddress) + "&"; 
        if (tenant_DeleterUser_ConcurrencyStamp !== undefined)
            url_ += "Tenant.DeleterUser.ConcurrencyStamp=" + encodeURIComponent("" + tenant_DeleterUser_ConcurrencyStamp) + "&"; 
        if (tenant_DeleterUser_Tokens !== undefined)
            tenant_DeleterUser_Tokens && tenant_DeleterUser_Tokens.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Tenant.DeleterUser.Tokens[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (tenant_DeleterUser_DeleterUser !== undefined)
            url_ += "Tenant.DeleterUser.DeleterUser=" + encodeURIComponent("" + tenant_DeleterUser_DeleterUser) + "&"; 
        if (tenant_DeleterUser_CreatorUser !== undefined)
            url_ += "Tenant.DeleterUser.CreatorUser=" + encodeURIComponent("" + tenant_DeleterUser_CreatorUser) + "&"; 
        if (tenant_DeleterUser_LastModifierUser !== undefined)
            url_ += "Tenant.DeleterUser.LastModifierUser=" + encodeURIComponent("" + tenant_DeleterUser_LastModifierUser) + "&"; 
        if (tenant_DeleterUser_AuthenticationSource !== undefined)
            url_ += "Tenant.DeleterUser.AuthenticationSource=" + encodeURIComponent("" + tenant_DeleterUser_AuthenticationSource) + "&"; 
        if (tenant_DeleterUser_UserName === undefined || tenant_DeleterUser_UserName === null)
            throw new Error("The parameter 'tenant_DeleterUser_UserName' must be defined and cannot be null.");
        else
            url_ += "Tenant.DeleterUser.UserName=" + encodeURIComponent("" + tenant_DeleterUser_UserName) + "&"; 
        if (tenant_DeleterUser_TenantId !== undefined)
            url_ += "Tenant.DeleterUser.TenantId=" + encodeURIComponent("" + tenant_DeleterUser_TenantId) + "&"; 
        if (tenant_DeleterUser_EmailAddress === undefined || tenant_DeleterUser_EmailAddress === null)
            throw new Error("The parameter 'tenant_DeleterUser_EmailAddress' must be defined and cannot be null.");
        else
            url_ += "Tenant.DeleterUser.EmailAddress=" + encodeURIComponent("" + tenant_DeleterUser_EmailAddress) + "&"; 
        if (tenant_DeleterUser_Name === undefined || tenant_DeleterUser_Name === null)
            throw new Error("The parameter 'tenant_DeleterUser_Name' must be defined and cannot be null.");
        else
            url_ += "Tenant.DeleterUser.Name=" + encodeURIComponent("" + tenant_DeleterUser_Name) + "&"; 
        if (tenant_DeleterUser_Surname === undefined || tenant_DeleterUser_Surname === null)
            throw new Error("The parameter 'tenant_DeleterUser_Surname' must be defined and cannot be null.");
        else
            url_ += "Tenant.DeleterUser.Surname=" + encodeURIComponent("" + tenant_DeleterUser_Surname) + "&"; 
        if (tenant_DeleterUser_FullName !== undefined)
            url_ += "Tenant.DeleterUser.FullName=" + encodeURIComponent("" + tenant_DeleterUser_FullName) + "&"; 
        if (tenant_DeleterUser_Password === undefined || tenant_DeleterUser_Password === null)
            throw new Error("The parameter 'tenant_DeleterUser_Password' must be defined and cannot be null.");
        else
            url_ += "Tenant.DeleterUser.Password=" + encodeURIComponent("" + tenant_DeleterUser_Password) + "&"; 
        if (tenant_DeleterUser_EmailConfirmationCode !== undefined)
            url_ += "Tenant.DeleterUser.EmailConfirmationCode=" + encodeURIComponent("" + tenant_DeleterUser_EmailConfirmationCode) + "&"; 
        if (tenant_DeleterUser_PasswordResetCode !== undefined)
            url_ += "Tenant.DeleterUser.PasswordResetCode=" + encodeURIComponent("" + tenant_DeleterUser_PasswordResetCode) + "&"; 
        if (tenant_DeleterUser_LockoutEndDateUtc !== undefined)
            url_ += "Tenant.DeleterUser.LockoutEndDateUtc=" + encodeURIComponent(tenant_DeleterUser_LockoutEndDateUtc ? "" + tenant_DeleterUser_LockoutEndDateUtc.toJSON() : "") + "&"; 
        if (tenant_DeleterUser_AccessFailedCount !== undefined)
            url_ += "Tenant.DeleterUser.AccessFailedCount=" + encodeURIComponent("" + tenant_DeleterUser_AccessFailedCount) + "&"; 
        if (tenant_DeleterUser_IsLockoutEnabled !== undefined)
            url_ += "Tenant.DeleterUser.IsLockoutEnabled=" + encodeURIComponent("" + tenant_DeleterUser_IsLockoutEnabled) + "&"; 
        if (tenant_DeleterUser_PhoneNumber !== undefined)
            url_ += "Tenant.DeleterUser.PhoneNumber=" + encodeURIComponent("" + tenant_DeleterUser_PhoneNumber) + "&"; 
        if (tenant_DeleterUser_IsPhoneNumberConfirmed !== undefined)
            url_ += "Tenant.DeleterUser.IsPhoneNumberConfirmed=" + encodeURIComponent("" + tenant_DeleterUser_IsPhoneNumberConfirmed) + "&"; 
        if (tenant_DeleterUser_SecurityStamp !== undefined)
            url_ += "Tenant.DeleterUser.SecurityStamp=" + encodeURIComponent("" + tenant_DeleterUser_SecurityStamp) + "&"; 
        if (tenant_DeleterUser_IsTwoFactorEnabled !== undefined)
            url_ += "Tenant.DeleterUser.IsTwoFactorEnabled=" + encodeURIComponent("" + tenant_DeleterUser_IsTwoFactorEnabled) + "&"; 
        if (tenant_DeleterUser_Logins !== undefined)
            tenant_DeleterUser_Logins && tenant_DeleterUser_Logins.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Tenant.DeleterUser.Logins[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (tenant_DeleterUser_Roles !== undefined)
            tenant_DeleterUser_Roles && tenant_DeleterUser_Roles.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Tenant.DeleterUser.Roles[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (tenant_DeleterUser_Claims !== undefined)
            tenant_DeleterUser_Claims && tenant_DeleterUser_Claims.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Tenant.DeleterUser.Claims[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (tenant_DeleterUser_Permissions !== undefined)
            tenant_DeleterUser_Permissions && tenant_DeleterUser_Permissions.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Tenant.DeleterUser.Permissions[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (tenant_DeleterUser_Settings !== undefined)
            tenant_DeleterUser_Settings && tenant_DeleterUser_Settings.forEach((item, index) => { 
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Tenant.DeleterUser.Settings[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (tenant_DeleterUser_IsEmailConfirmed !== undefined)
            url_ += "Tenant.DeleterUser.IsEmailConfirmed=" + encodeURIComponent("" + tenant_DeleterUser_IsEmailConfirmed) + "&"; 
        if (tenant_DeleterUser_IsActive !== undefined)
            url_ += "Tenant.DeleterUser.IsActive=" + encodeURIComponent("" + tenant_DeleterUser_IsActive) + "&"; 
        if (tenant_DeleterUser_IsDeleted !== undefined)
            url_ += "Tenant.DeleterUser.IsDeleted=" + encodeURIComponent("" + tenant_DeleterUser_IsDeleted) + "&"; 
        if (tenant_DeleterUser_DeleterUserId !== undefined)
            url_ += "Tenant.DeleterUser.DeleterUserId=" + encodeURIComponent("" + tenant_DeleterUser_DeleterUserId) + "&"; 
        if (tenant_DeleterUser_DeletionTime !== undefined)
            url_ += "Tenant.DeleterUser.DeletionTime=" + encodeURIComponent(tenant_DeleterUser_DeletionTime ? "" + tenant_DeleterUser_DeletionTime.toJSON() : "") + "&"; 
        if (tenant_DeleterUser_LastModificationTime !== undefined)
            url_ += "Tenant.DeleterUser.LastModificationTime=" + encodeURIComponent(tenant_DeleterUser_LastModificationTime ? "" + tenant_DeleterUser_LastModificationTime.toJSON() : "") + "&"; 
        if (tenant_DeleterUser_LastModifierUserId !== undefined)
            url_ += "Tenant.DeleterUser.LastModifierUserId=" + encodeURIComponent("" + tenant_DeleterUser_LastModifierUserId) + "&"; 
        if (tenant_DeleterUser_CreationTime !== undefined)
            url_ += "Tenant.DeleterUser.CreationTime=" + encodeURIComponent(tenant_DeleterUser_CreationTime ? "" + tenant_DeleterUser_CreationTime.toJSON() : "") + "&"; 
        if (tenant_DeleterUser_CreatorUserId !== undefined)
            url_ += "Tenant.DeleterUser.CreatorUserId=" + encodeURIComponent("" + tenant_DeleterUser_CreatorUserId) + "&"; 
        if (tenant_DeleterUser_Id !== undefined)
            url_ += "Tenant.DeleterUser.Id=" + encodeURIComponent("" + tenant_DeleterUser_Id) + "&"; 
        if (tenant_TenancyName === undefined || tenant_TenancyName === null)
            throw new Error("The parameter 'tenant_TenancyName' must be defined and cannot be null.");
        else
            url_ += "Tenant.TenancyName=" + encodeURIComponent("" + tenant_TenancyName) + "&"; 
        if (tenant_Name === undefined || tenant_Name === null)
            throw new Error("The parameter 'tenant_Name' must be defined and cannot be null.");
        else
            url_ += "Tenant.Name=" + encodeURIComponent("" + tenant_Name) + "&"; 
        if (tenant_ConnectionString !== undefined)
            url_ += "Tenant.ConnectionString=" + encodeURIComponent("" + tenant_ConnectionString) + "&"; 
        if (tenant_IsActive !== undefined)
            url_ += "Tenant.IsActive=" + encodeURIComponent("" + tenant_IsActive) + "&"; 
        if (tenant_IsDeleted !== undefined)
            url_ += "Tenant.IsDeleted=" + encodeURIComponent("" + tenant_IsDeleted) + "&"; 
        if (tenant_DeleterUserId !== undefined)
            url_ += "Tenant.DeleterUserId=" + encodeURIComponent("" + tenant_DeleterUserId) + "&"; 
        if (tenant_DeletionTime !== undefined)
            url_ += "Tenant.DeletionTime=" + encodeURIComponent(tenant_DeletionTime ? "" + tenant_DeletionTime.toJSON() : "") + "&"; 
        if (tenant_LastModificationTime !== undefined)
            url_ += "Tenant.LastModificationTime=" + encodeURIComponent(tenant_LastModificationTime ? "" + tenant_LastModificationTime.toJSON() : "") + "&"; 
        if (tenant_LastModifierUserId !== undefined)
            url_ += "Tenant.LastModifierUserId=" + encodeURIComponent("" + tenant_LastModifierUserId) + "&"; 
        if (tenant_CreationTime !== undefined)
            url_ += "Tenant.CreationTime=" + encodeURIComponent(tenant_CreationTime ? "" + tenant_CreationTime.toJSON() : "") + "&"; 
        if (tenant_CreatorUserId !== undefined)
            url_ += "Tenant.CreatorUserId=" + encodeURIComponent("" + tenant_CreatorUserId) + "&"; 
        if (tenant_Id !== undefined)
            url_ += "Tenant.Id=" + encodeURIComponent("" + tenant_Id) + "&"; 
        if (customer_TenantId !== undefined)
            url_ += "Customer.TenantId=" + encodeURIComponent("" + customer_TenantId) + "&"; 
        if (customer_Reference === undefined || customer_Reference === null)
            throw new Error("The parameter 'customer_Reference' must be defined and cannot be null.");
        else
            url_ += "Customer.Reference=" + encodeURIComponent("" + customer_Reference) + "&"; 
        if (customer_Name === undefined || customer_Name === null)
            throw new Error("The parameter 'customer_Name' must be defined and cannot be null.");
        else
            url_ += "Customer.Name=" + encodeURIComponent("" + customer_Name) + "&"; 
        if (customer_Identifier === undefined || customer_Identifier === null)
            throw new Error("The parameter 'customer_Identifier' must be defined and cannot be null.");
        else
            url_ += "Customer.Identifier=" + encodeURIComponent("" + customer_Identifier) + "&"; 
        if (customer_LogoUrl !== undefined)
            url_ += "Customer.LogoUrl=" + encodeURIComponent("" + customer_LogoUrl) + "&"; 
        if (customer_Website !== undefined)
            url_ += "Customer.Website=" + encodeURIComponent("" + customer_Website) + "&"; 
        if (customer_CustomerLoc8UUID !== undefined)
            url_ += "Customer.CustomerLoc8UUID=" + encodeURIComponent("" + customer_CustomerLoc8UUID) + "&"; 
        if (customer_EmailAddress !== undefined)
            url_ += "Customer.EmailAddress=" + encodeURIComponent("" + customer_EmailAddress) + "&"; 
        if (customer_XeroContactPersons !== undefined)
            url_ += "Customer.XeroContactPersons=" + encodeURIComponent("" + customer_XeroContactPersons) + "&"; 
        if (customer_XeroAccountsReceivableTaxType !== undefined)
            url_ += "Customer.XeroAccountsReceivableTaxType=" + encodeURIComponent("" + customer_XeroAccountsReceivableTaxType) + "&"; 
        if (customer_XeroAccountsPayableTaxType !== undefined)
            url_ += "Customer.XeroAccountsPayableTaxType=" + encodeURIComponent("" + customer_XeroAccountsPayableTaxType) + "&"; 
        if (customer_XeroAddresses !== undefined)
            url_ += "Customer.XeroAddresses=" + encodeURIComponent("" + customer_XeroAddresses) + "&"; 
        if (customer_XeroPhones !== undefined)
            url_ += "Customer.XeroPhones=" + encodeURIComponent("" + customer_XeroPhones) + "&"; 
        if (customer_XeroDefaultCurrency !== undefined)
            url_ += "Customer.XeroDefaultCurrency=" + encodeURIComponent("" + customer_XeroDefaultCurrency) + "&"; 
        if (customer_XeroPaymentTerms !== undefined)
            url_ += "Customer.XeroPaymentTerms=" + encodeURIComponent("" + customer_XeroPaymentTerms) + "&"; 
        if (customer_XeroContactId !== undefined)
            url_ += "Customer.XeroContactId=" + encodeURIComponent("" + customer_XeroContactId) + "&"; 
        if (customer_CustomerTypeId !== undefined)
            url_ += "Customer.CustomerTypeId=" + encodeURIComponent("" + customer_CustomerTypeId) + "&"; 
        if (customer_CustomerTypeFk_TenantId !== undefined)
            url_ += "Customer.CustomerTypeFk.TenantId=" + encodeURIComponent("" + customer_CustomerTypeFk_TenantId) + "&"; 
        if (customer_CustomerTypeFk_Type === undefined || customer_CustomerTypeFk_Type === null)
            throw new Error("The parameter 'customer_CustomerTypeFk_Type' must be defined and cannot be null.");
        else
            url_ += "Customer.CustomerTypeFk.Type=" + encodeURIComponent("" + customer_CustomerTypeFk_Type) + "&"; 
        if (customer_CustomerTypeFk_Description === undefined || customer_CustomerTypeFk_Description === null)
            throw new Error("The parameter 'customer_CustomerTypeFk_Description' must be defined and cannot be null.");
        else
            url_ += "Customer.CustomerTypeFk.Description=" + encodeURIComponent("" + customer_CustomerTypeFk_Description) + "&"; 
        if (customer_CustomerTypeFk_IsDeleted !== undefined)
            url_ += "Customer.CustomerTypeFk.IsDeleted=" + encodeURIComponent("" + customer_CustomerTypeFk_IsDeleted) + "&"; 
        if (customer_CustomerTypeFk_DeleterUserId !== undefined)
            url_ += "Customer.CustomerTypeFk.DeleterUserId=" + encodeURIComponent("" + customer_CustomerTypeFk_DeleterUserId) + "&"; 
        if (customer_CustomerTypeFk_DeletionTime !== undefined)
            url_ += "Customer.CustomerTypeFk.DeletionTime=" + encodeURIComponent(customer_CustomerTypeFk_DeletionTime ? "" + customer_CustomerTypeFk_DeletionTime.toJSON() : "") + "&"; 
        if (customer_CustomerTypeFk_LastModificationTime !== undefined)
            url_ += "Customer.CustomerTypeFk.LastModificationTime=" + encodeURIComponent(customer_CustomerTypeFk_LastModificationTime ? "" + customer_CustomerTypeFk_LastModificationTime.toJSON() : "") + "&"; 
        if (customer_CustomerTypeFk_LastModifierUserId !== undefined)
            url_ += "Customer.CustomerTypeFk.LastModifierUserId=" + encodeURIComponent("" + customer_CustomerTypeFk_LastModifierUserId) + "&"; 
        if (customer_CustomerTypeFk_CreationTime !== undefined)
            url_ += "Customer.CustomerTypeFk.CreationTime=" + encodeURIComponent(customer_CustomerTypeFk_CreationTime ? "" + customer_CustomerTypeFk_CreationTime.toJSON() : "") + "&"; 
        if (customer_CustomerTypeFk_CreatorUserId !== undefined)
            url_ += "Customer.CustomerTypeFk.CreatorUserId=" + encodeURIComponent("" + customer_CustomerTypeFk_CreatorUserId) + "&"; 
        if (customer_CustomerTypeFk_Id !== undefined)
            url_ += "Customer.CustomerTypeFk.Id=" + encodeURIComponent("" + customer_CustomerTypeFk_Id) + "&"; 
        if (customer_CurrencyId !== undefined)
            url_ += "Customer.CurrencyId=" + encodeURIComponent("" + customer_CurrencyId) + "&"; 
        if (customer_CurrencyFk_TenantId !== undefined)
            url_ += "Customer.CurrencyFk.TenantId=" + encodeURIComponent("" + customer_CurrencyFk_TenantId) + "&"; 
        if (customer_CurrencyFk_Code === undefined || customer_CurrencyFk_Code === null)
            throw new Error("The parameter 'customer_CurrencyFk_Code' must be defined and cannot be null.");
        else
            url_ += "Customer.CurrencyFk.Code=" + encodeURIComponent("" + customer_CurrencyFk_Code) + "&"; 
        if (customer_CurrencyFk_Name === undefined || customer_CurrencyFk_Name === null)
            throw new Error("The parameter 'customer_CurrencyFk_Name' must be defined and cannot be null.");
        else
            url_ += "Customer.CurrencyFk.Name=" + encodeURIComponent("" + customer_CurrencyFk_Name) + "&"; 
        if (customer_CurrencyFk_Symbol !== undefined)
            url_ += "Customer.CurrencyFk.Symbol=" + encodeURIComponent("" + customer_CurrencyFk_Symbol) + "&"; 
        if (customer_CurrencyFk_Country === undefined || customer_CurrencyFk_Country === null)
            throw new Error("The parameter 'customer_CurrencyFk_Country' must be defined and cannot be null.");
        else
            url_ += "Customer.CurrencyFk.Country=" + encodeURIComponent("" + customer_CurrencyFk_Country) + "&"; 
        if (customer_CurrencyFk_BaseCountry === undefined || customer_CurrencyFk_BaseCountry === null)
            throw new Error("The parameter 'customer_CurrencyFk_BaseCountry' must be defined and cannot be null.");
        else
            url_ += "Customer.CurrencyFk.BaseCountry=" + encodeURIComponent("" + customer_CurrencyFk_BaseCountry) + "&"; 
        if (customer_CurrencyFk_IsDeleted !== undefined)
            url_ += "Customer.CurrencyFk.IsDeleted=" + encodeURIComponent("" + customer_CurrencyFk_IsDeleted) + "&"; 
        if (customer_CurrencyFk_DeleterUserId !== undefined)
            url_ += "Customer.CurrencyFk.DeleterUserId=" + encodeURIComponent("" + customer_CurrencyFk_DeleterUserId) + "&"; 
        if (customer_CurrencyFk_DeletionTime !== undefined)
            url_ += "Customer.CurrencyFk.DeletionTime=" + encodeURIComponent(customer_CurrencyFk_DeletionTime ? "" + customer_CurrencyFk_DeletionTime.toJSON() : "") + "&"; 
        if (customer_CurrencyFk_LastModificationTime !== undefined)
            url_ += "Customer.CurrencyFk.LastModificationTime=" + encodeURIComponent(customer_CurrencyFk_LastModificationTime ? "" + customer_CurrencyFk_LastModificationTime.toJSON() : "") + "&"; 
        if (customer_CurrencyFk_LastModifierUserId !== undefined)
            url_ += "Customer.CurrencyFk.LastModifierUserId=" + encodeURIComponent("" + customer_CurrencyFk_LastModifierUserId) + "&"; 
        if (customer_CurrencyFk_CreationTime !== undefined)
            url_ += "Customer.CurrencyFk.CreationTime=" + encodeURIComponent(customer_CurrencyFk_CreationTime ? "" + customer_CurrencyFk_CreationTime.toJSON() : "") + "&"; 
        if (customer_CurrencyFk_CreatorUserId !== undefined)
            url_ += "Customer.CurrencyFk.CreatorUserId=" + encodeURIComponent("" + customer_CurrencyFk_CreatorUserId) + "&"; 
        if (customer_CurrencyFk_Id !== undefined)
            url_ += "Customer.CurrencyFk.Id=" + encodeURIComponent("" + customer_CurrencyFk_Id) + "&"; 
        if (customer_PaymentTermNumber !== undefined)
            url_ += "Customer.PaymentTermNumber=" + encodeURIComponent("" + customer_PaymentTermNumber) + "&"; 
        if (customer_PaymentTermType !== undefined)
            url_ += "Customer.PaymentTermType=" + encodeURIComponent("" + customer_PaymentTermType) + "&"; 
        if (customer_IsDeleted !== undefined)
            url_ += "Customer.IsDeleted=" + encodeURIComponent("" + customer_IsDeleted) + "&"; 
        if (customer_DeleterUserId !== undefined)
            url_ += "Customer.DeleterUserId=" + encodeURIComponent("" + customer_DeleterUserId) + "&"; 
        if (customer_DeletionTime !== undefined)
            url_ += "Customer.DeletionTime=" + encodeURIComponent(customer_DeletionTime ? "" + customer_DeletionTime.toJSON() : "") + "&"; 
        if (customer_LastModificationTime !== undefined)
            url_ += "Customer.LastModificationTime=" + encodeURIComponent(customer_LastModificationTime ? "" + customer_LastModificationTime.toJSON() : "") + "&"; 
        if (customer_LastModifierUserId !== undefined)
            url_ += "Customer.LastModifierUserId=" + encodeURIComponent("" + customer_LastModifierUserId) + "&"; 
        if (customer_CreationTime !== undefined)
            url_ += "Customer.CreationTime=" + encodeURIComponent(customer_CreationTime ? "" + customer_CreationTime.toJSON() : "") + "&"; 
        if (customer_CreatorUserId !== undefined)
            url_ += "Customer.CreatorUserId=" + encodeURIComponent("" + customer_CreatorUserId) + "&"; 
        if (customer_Id !== undefined)
            url_ += "Customer.Id=" + encodeURIComponent("" + customer_Id) + "&"; 
        if (vendor_TenantId !== undefined)
            url_ += "Vendor.TenantId=" + encodeURIComponent("" + vendor_TenantId) + "&"; 
        if (vendor_Reference === undefined || vendor_Reference === null)
            throw new Error("The parameter 'vendor_Reference' must be defined and cannot be null.");
        else
            url_ += "Vendor.Reference=" + encodeURIComponent("" + vendor_Reference) + "&"; 
        if (vendor_Name === undefined || vendor_Name === null)
            throw new Error("The parameter 'vendor_Name' must be defined and cannot be null.");
        else
            url_ += "Vendor.Name=" + encodeURIComponent("" + vendor_Name) + "&"; 
        if (vendor_Identifier === undefined || vendor_Identifier === null)
            throw new Error("The parameter 'vendor_Identifier' must be defined and cannot be null.");
        else
            url_ += "Vendor.Identifier=" + encodeURIComponent("" + vendor_Identifier) + "&"; 
        if (vendor_LogoUrl !== undefined)
            url_ += "Vendor.LogoUrl=" + encodeURIComponent("" + vendor_LogoUrl) + "&"; 
        if (vendor_Website !== undefined)
            url_ += "Vendor.Website=" + encodeURIComponent("" + vendor_Website) + "&"; 
        if (vendor_VendorLoc8GUID !== undefined)
            url_ += "Vendor.VendorLoc8GUID=" + encodeURIComponent("" + vendor_VendorLoc8GUID) + "&"; 
        if (vendor_SsicCodeId !== undefined)
            url_ += "Vendor.SsicCodeId=" + encodeURIComponent("" + vendor_SsicCodeId) + "&"; 
        if (vendor_SsicCodeFk_TenantId !== undefined)
            url_ += "Vendor.SsicCodeFk.TenantId=" + encodeURIComponent("" + vendor_SsicCodeFk_TenantId) + "&"; 
        if (vendor_SsicCodeFk_Code === undefined || vendor_SsicCodeFk_Code === null)
            throw new Error("The parameter 'vendor_SsicCodeFk_Code' must be defined and cannot be null.");
        else
            url_ += "Vendor.SsicCodeFk.Code=" + encodeURIComponent("" + vendor_SsicCodeFk_Code) + "&"; 
        if (vendor_SsicCodeFk_SSIC === undefined || vendor_SsicCodeFk_SSIC === null)
            throw new Error("The parameter 'vendor_SsicCodeFk_SSIC' must be defined and cannot be null.");
        else
            url_ += "Vendor.SsicCodeFk.SSIC=" + encodeURIComponent("" + vendor_SsicCodeFk_SSIC) + "&"; 
        if (vendor_SsicCodeFk_IsDeleted !== undefined)
            url_ += "Vendor.SsicCodeFk.IsDeleted=" + encodeURIComponent("" + vendor_SsicCodeFk_IsDeleted) + "&"; 
        if (vendor_SsicCodeFk_DeleterUserId !== undefined)
            url_ += "Vendor.SsicCodeFk.DeleterUserId=" + encodeURIComponent("" + vendor_SsicCodeFk_DeleterUserId) + "&"; 
        if (vendor_SsicCodeFk_DeletionTime !== undefined)
            url_ += "Vendor.SsicCodeFk.DeletionTime=" + encodeURIComponent(vendor_SsicCodeFk_DeletionTime ? "" + vendor_SsicCodeFk_DeletionTime.toJSON() : "") + "&"; 
        if (vendor_SsicCodeFk_LastModificationTime !== undefined)
            url_ += "Vendor.SsicCodeFk.LastModificationTime=" + encodeURIComponent(vendor_SsicCodeFk_LastModificationTime ? "" + vendor_SsicCodeFk_LastModificationTime.toJSON() : "") + "&"; 
        if (vendor_SsicCodeFk_LastModifierUserId !== undefined)
            url_ += "Vendor.SsicCodeFk.LastModifierUserId=" + encodeURIComponent("" + vendor_SsicCodeFk_LastModifierUserId) + "&"; 
        if (vendor_SsicCodeFk_CreationTime !== undefined)
            url_ += "Vendor.SsicCodeFk.CreationTime=" + encodeURIComponent(vendor_SsicCodeFk_CreationTime ? "" + vendor_SsicCodeFk_CreationTime.toJSON() : "") + "&"; 
        if (vendor_SsicCodeFk_CreatorUserId !== undefined)
            url_ += "Vendor.SsicCodeFk.CreatorUserId=" + encodeURIComponent("" + vendor_SsicCodeFk_CreatorUserId) + "&"; 
        if (vendor_SsicCodeFk_Id !== undefined)
            url_ += "Vendor.SsicCodeFk.Id=" + encodeURIComponent("" + vendor_SsicCodeFk_Id) + "&"; 
        if (vendor_CurrencyId !== undefined)
            url_ += "Vendor.CurrencyId=" + encodeURIComponent("" + vendor_CurrencyId) + "&"; 
        if (vendor_CurrencyFk_TenantId !== undefined)
            url_ += "Vendor.CurrencyFk.TenantId=" + encodeURIComponent("" + vendor_CurrencyFk_TenantId) + "&"; 
        if (vendor_CurrencyFk_Code === undefined || vendor_CurrencyFk_Code === null)
            throw new Error("The parameter 'vendor_CurrencyFk_Code' must be defined and cannot be null.");
        else
            url_ += "Vendor.CurrencyFk.Code=" + encodeURIComponent("" + vendor_CurrencyFk_Code) + "&"; 
        if (vendor_CurrencyFk_Name === undefined || vendor_CurrencyFk_Name === null)
            throw new Error("The parameter 'vendor_CurrencyFk_Name' must be defined and cannot be null.");
        else
            url_ += "Vendor.CurrencyFk.Name=" + encodeURIComponent("" + vendor_CurrencyFk_Name) + "&"; 
        if (vendor_CurrencyFk_Symbol !== undefined)
            url_ += "Vendor.CurrencyFk.Symbol=" + encodeURIComponent("" + vendor_CurrencyFk_Symbol) + "&"; 
        if (vendor_CurrencyFk_Country === undefined || vendor_CurrencyFk_Country === null)
            throw new Error("The parameter 'vendor_CurrencyFk_Country' must be defined and cannot be null.");
        else
            url_ += "Vendor.CurrencyFk.Country=" + encodeURIComponent("" + vendor_CurrencyFk_Country) + "&"; 
        if (vendor_CurrencyFk_BaseCountry === undefined || vendor_CurrencyFk_BaseCountry === null)
            throw new Error("The parameter 'vendor_CurrencyFk_BaseCountry' must be defined and cannot be null.");
        else
            url_ += "Vendor.CurrencyFk.BaseCountry=" + encodeURIComponent("" + vendor_CurrencyFk_BaseCountry) + "&"; 
        if (vendor_CurrencyFk_IsDeleted !== undefined)
            url_ += "Vendor.CurrencyFk.IsDeleted=" + encodeURIComponent("" + vendor_CurrencyFk_IsDeleted) + "&"; 
        if (vendor_CurrencyFk_DeleterUserId !== undefined)
            url_ += "Vendor.CurrencyFk.DeleterUserId=" + encodeURIComponent("" + vendor_CurrencyFk_DeleterUserId) + "&"; 
        if (vendor_CurrencyFk_DeletionTime !== undefined)
            url_ += "Vendor.CurrencyFk.DeletionTime=" + encodeURIComponent(vendor_CurrencyFk_DeletionTime ? "" + vendor_CurrencyFk_DeletionTime.toJSON() : "") + "&"; 
        if (vendor_CurrencyFk_LastModificationTime !== undefined)
            url_ += "Vendor.CurrencyFk.LastModificationTime=" + encodeURIComponent(vendor_CurrencyFk_LastModificationTime ? "" + vendor_CurrencyFk_LastModificationTime.toJSON() : "") + "&"; 
        if (vendor_CurrencyFk_LastModifierUserId !== undefined)
            url_ += "Vendor.CurrencyFk.LastModifierUserId=" + encodeURIComponent("" + vendor_CurrencyFk_LastModifierUserId) + "&"; 
        if (vendor_CurrencyFk_CreationTime !== undefined)
            url_ += "Vendor.CurrencyFk.CreationTime=" + encodeURIComponent(vendor_CurrencyFk_CreationTime ? "" + vendor_CurrencyFk_CreationTime.toJSON() : "") + "&"; 
        if (vendor_CurrencyFk_CreatorUserId !== undefined)
            url_ += "Vendor.CurrencyFk.CreatorUserId=" + encodeURIComponent("" + vendor_CurrencyFk_CreatorUserId) + "&"; 
        if (vendor_CurrencyFk_Id !== undefined)
            url_ += "Vendor.CurrencyFk.Id=" + encodeURIComponent("" + vendor_CurrencyFk_Id) + "&"; 
        if (vendor_IsDeleted !== undefined)
            url_ += "Vendor.IsDeleted=" + encodeURIComponent("" + vendor_IsDeleted) + "&"; 
        if (vendor_DeleterUserId !== undefined)
            url_ += "Vendor.DeleterUserId=" + encodeURIComponent("" + vendor_DeleterUserId) + "&"; 
        if (vendor_DeletionTime !== undefined)
            url_ += "Vendor.DeletionTime=" + encodeURIComponent(vendor_DeletionTime ? "" + vendor_DeletionTime.toJSON() : "") + "&"; 
        if (vendor_LastModificationTime !== undefined)
            url_ += "Vendor.LastModificationTime=" + encodeURIComponent(vendor_LastModificationTime ? "" + vendor_LastModificationTime.toJSON() : "") + "&"; 
        if (vendor_LastModifierUserId !== undefined)
            url_ += "Vendor.LastModifierUserId=" + encodeURIComponent("" + vendor_LastModifierUserId) + "&"; 
        if (vendor_CreationTime !== undefined)
            url_ += "Vendor.CreationTime=" + encodeURIComponent(vendor_CreationTime ? "" + vendor_CreationTime.toJSON() : "") + "&"; 
        if (vendor_CreatorUserId !== undefined)
            url_ += "Vendor.CreatorUserId=" + encodeURIComponent("" + vendor_CreatorUserId) + "&"; 
        if (vendor_Id !== undefined)
            url_ += "Vendor.Id=" + encodeURIComponent("" + vendor_Id) + "&"; 
        if (assetOwner_TenantId !== undefined)
            url_ += "AssetOwner.TenantId=" + encodeURIComponent("" + assetOwner_TenantId) + "&"; 
        if (assetOwner_Reference === undefined || assetOwner_Reference === null)
            throw new Error("The parameter 'assetOwner_Reference' must be defined and cannot be null.");
        else
            url_ += "AssetOwner.Reference=" + encodeURIComponent("" + assetOwner_Reference) + "&"; 
        if (assetOwner_Name === undefined || assetOwner_Name === null)
            throw new Error("The parameter 'assetOwner_Name' must be defined and cannot be null.");
        else
            url_ += "AssetOwner.Name=" + encodeURIComponent("" + assetOwner_Name) + "&"; 
        if (assetOwner_Identifier !== undefined)
            url_ += "AssetOwner.Identifier=" + encodeURIComponent("" + assetOwner_Identifier) + "&"; 
        if (assetOwner_LogoUrl !== undefined)
            url_ += "AssetOwner.LogoUrl=" + encodeURIComponent("" + assetOwner_LogoUrl) + "&"; 
        if (assetOwner_Website !== undefined)
            url_ += "AssetOwner.Website=" + encodeURIComponent("" + assetOwner_Website) + "&"; 
        if (assetOwner_CurrencyId !== undefined)
            url_ += "AssetOwner.CurrencyId=" + encodeURIComponent("" + assetOwner_CurrencyId) + "&"; 
        if (assetOwner_CurrencyFk_TenantId !== undefined)
            url_ += "AssetOwner.CurrencyFk.TenantId=" + encodeURIComponent("" + assetOwner_CurrencyFk_TenantId) + "&"; 
        if (assetOwner_CurrencyFk_Code === undefined || assetOwner_CurrencyFk_Code === null)
            throw new Error("The parameter 'assetOwner_CurrencyFk_Code' must be defined and cannot be null.");
        else
            url_ += "AssetOwner.CurrencyFk.Code=" + encodeURIComponent("" + assetOwner_CurrencyFk_Code) + "&"; 
        if (assetOwner_CurrencyFk_Name === undefined || assetOwner_CurrencyFk_Name === null)
            throw new Error("The parameter 'assetOwner_CurrencyFk_Name' must be defined and cannot be null.");
        else
            url_ += "AssetOwner.CurrencyFk.Name=" + encodeURIComponent("" + assetOwner_CurrencyFk_Name) + "&"; 
        if (assetOwner_CurrencyFk_Symbol !== undefined)
            url_ += "AssetOwner.CurrencyFk.Symbol=" + encodeURIComponent("" + assetOwner_CurrencyFk_Symbol) + "&"; 
        if (assetOwner_CurrencyFk_Country === undefined || assetOwner_CurrencyFk_Country === null)
            throw new Error("The parameter 'assetOwner_CurrencyFk_Country' must be defined and cannot be null.");
        else
            url_ += "AssetOwner.CurrencyFk.Country=" + encodeURIComponent("" + assetOwner_CurrencyFk_Country) + "&"; 
        if (assetOwner_CurrencyFk_BaseCountry === undefined || assetOwner_CurrencyFk_BaseCountry === null)
            throw new Error("The parameter 'assetOwner_CurrencyFk_BaseCountry' must be defined and cannot be null.");
        else
            url_ += "AssetOwner.CurrencyFk.BaseCountry=" + encodeURIComponent("" + assetOwner_CurrencyFk_BaseCountry) + "&"; 
        if (assetOwner_CurrencyFk_IsDeleted !== undefined)
            url_ += "AssetOwner.CurrencyFk.IsDeleted=" + encodeURIComponent("" + assetOwner_CurrencyFk_IsDeleted) + "&"; 
        if (assetOwner_CurrencyFk_DeleterUserId !== undefined)
            url_ += "AssetOwner.CurrencyFk.DeleterUserId=" + encodeURIComponent("" + assetOwner_CurrencyFk_DeleterUserId) + "&"; 
        if (assetOwner_CurrencyFk_DeletionTime !== undefined)
            url_ += "AssetOwner.CurrencyFk.DeletionTime=" + encodeURIComponent(assetOwner_CurrencyFk_DeletionTime ? "" + assetOwner_CurrencyFk_DeletionTime.toJSON() : "") + "&"; 
        if (assetOwner_CurrencyFk_LastModificationTime !== undefined)
            url_ += "AssetOwner.CurrencyFk.LastModificationTime=" + encodeURIComponent(assetOwner_CurrencyFk_LastModificationTime ? "" + assetOwner_CurrencyFk_LastModificationTime.toJSON() : "") + "&"; 
        if (assetOwner_CurrencyFk_LastModifierUserId !== undefined)
            url_ += "AssetOwner.CurrencyFk.LastModifierUserId=" + encodeURIComponent("" + assetOwner_CurrencyFk_LastModifierUserId) + "&"; 
        if (assetOwner_CurrencyFk_CreationTime !== undefined)
            url_ += "AssetOwner.CurrencyFk.CreationTime=" + encodeURIComponent(assetOwner_CurrencyFk_CreationTime ? "" + assetOwner_CurrencyFk_CreationTime.toJSON() : "") + "&"; 
        if (assetOwner_CurrencyFk_CreatorUserId !== undefined)
            url_ += "AssetOwner.CurrencyFk.CreatorUserId=" + encodeURIComponent("" + assetOwner_CurrencyFk_CreatorUserId) + "&"; 
        if (assetOwner_CurrencyFk_Id !== undefined)
            url_ += "AssetOwner.CurrencyFk.Id=" + encodeURIComponent("" + assetOwner_CurrencyFk_Id) + "&"; 
        if (assetOwner_SsicCodeId !== undefined)
            url_ += "AssetOwner.SsicCodeId=" + encodeURIComponent("" + assetOwner_SsicCodeId) + "&"; 
        if (assetOwner_SsicCodeFk_TenantId !== undefined)
            url_ += "AssetOwner.SsicCodeFk.TenantId=" + encodeURIComponent("" + assetOwner_SsicCodeFk_TenantId) + "&"; 
        if (assetOwner_SsicCodeFk_Code === undefined || assetOwner_SsicCodeFk_Code === null)
            throw new Error("The parameter 'assetOwner_SsicCodeFk_Code' must be defined and cannot be null.");
        else
            url_ += "AssetOwner.SsicCodeFk.Code=" + encodeURIComponent("" + assetOwner_SsicCodeFk_Code) + "&"; 
        if (assetOwner_SsicCodeFk_SSIC === undefined || assetOwner_SsicCodeFk_SSIC === null)
            throw new Error("The parameter 'assetOwner_SsicCodeFk_SSIC' must be defined and cannot be null.");
        else
            url_ += "AssetOwner.SsicCodeFk.SSIC=" + encodeURIComponent("" + assetOwner_SsicCodeFk_SSIC) + "&"; 
        if (assetOwner_SsicCodeFk_IsDeleted !== undefined)
            url_ += "AssetOwner.SsicCodeFk.IsDeleted=" + encodeURIComponent("" + assetOwner_SsicCodeFk_IsDeleted) + "&"; 
        if (assetOwner_SsicCodeFk_DeleterUserId !== undefined)
            url_ += "AssetOwner.SsicCodeFk.DeleterUserId=" + encodeURIComponent("" + assetOwner_SsicCodeFk_DeleterUserId) + "&"; 
        if (assetOwner_SsicCodeFk_DeletionTime !== undefined)
            url_ += "AssetOwner.SsicCodeFk.DeletionTime=" + encodeURIComponent(assetOwner_SsicCodeFk_DeletionTime ? "" + assetOwner_SsicCodeFk_DeletionTime.toJSON() : "") + "&"; 
        if (assetOwner_SsicCodeFk_LastModificationTime !== undefined)
            url_ += "AssetOwner.SsicCodeFk.LastModificationTime=" + encodeURIComponent(assetOwner_SsicCodeFk_LastModificationTime ? "" + assetOwner_SsicCodeFk_LastModificationTime.toJSON() : "") + "&"; 
        if (assetOwner_SsicCodeFk_LastModifierUserId !== undefined)
            url_ += "AssetOwner.SsicCodeFk.LastModifierUserId=" + encodeURIComponent("" + assetOwner_SsicCodeFk_LastModifierUserId) + "&"; 
        if (assetOwner_SsicCodeFk_CreationTime !== undefined)
            url_ += "AssetOwner.SsicCodeFk.CreationTime=" + encodeURIComponent(assetOwner_SsicCodeFk_CreationTime ? "" + assetOwner_SsicCodeFk_CreationTime.toJSON() : "") + "&"; 
        if (assetOwner_SsicCodeFk_CreatorUserId !== undefined)
            url_ += "AssetOwner.SsicCodeFk.CreatorUserId=" + encodeURIComponent("" + assetOwner_SsicCodeFk_CreatorUserId) + "&"; 
        if (assetOwner_SsicCodeFk_Id !== undefined)
            url_ += "AssetOwner.SsicCodeFk.Id=" + encodeURIComponent("" + assetOwner_SsicCodeFk_Id) + "&"; 
        if (assetOwner_IsDeleted !== undefined)
            url_ += "AssetOwner.IsDeleted=" + encodeURIComponent("" + assetOwner_IsDeleted) + "&"; 
        if (assetOwner_DeleterUserId !== undefined)
            url_ += "AssetOwner.DeleterUserId=" + encodeURIComponent("" + assetOwner_DeleterUserId) + "&"; 
        if (assetOwner_DeletionTime !== undefined)
            url_ += "AssetOwner.DeletionTime=" + encodeURIComponent(assetOwner_DeletionTime ? "" + assetOwner_DeletionTime.toJSON() : "") + "&"; 
        if (assetOwner_LastModificationTime !== undefined)
            url_ += "AssetOwner.LastModificationTime=" + encodeURIComponent(assetOwner_LastModificationTime ? "" + assetOwner_LastModificationTime.toJSON() : "") + "&"; 
        if (assetOwner_LastModifierUserId !== undefined)
            url_ += "AssetOwner.LastModifierUserId=" + encodeURIComponent("" + assetOwner_LastModifierUserId) + "&"; 
        if (assetOwner_CreationTime !== undefined)
            url_ += "AssetOwner.CreationTime=" + encodeURIComponent(assetOwner_CreationTime ? "" + assetOwner_CreationTime.toJSON() : "") + "&"; 
        if (assetOwner_CreatorUserId !== undefined)
            url_ += "AssetOwner.CreatorUserId=" + encodeURIComponent("" + assetOwner_CreatorUserId) + "&"; 
        if (assetOwner_Id !== undefined)
            url_ += "AssetOwner.Id=" + encodeURIComponent("" + assetOwner_Id) + "&"; 
        if (isHost !== undefined)
            url_ += "IsHost=" + encodeURIComponent("" + isHost) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAgedReceivablesData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAgedReceivablesData(<any>response_);
                } catch (e) {
                    return <Observable<AgedReceivablesData[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AgedReceivablesData[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAgedReceivablesData(response: HttpResponseBase): Observable<AgedReceivablesData[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AgedReceivablesData.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AgedReceivablesData[]>(<any>null);
    }
}

@Injectable()
export class TenantRegistrationServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    registerTenant(input: RegisterTenantInput | null | undefined): Observable<RegisterTenantOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantRegistration/RegisterTenant";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterTenant(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterTenant(<any>response_);
                } catch (e) {
                    return <Observable<RegisterTenantOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<RegisterTenantOutput>><any>_observableThrow(response_);
        }));
    }

    protected processRegisterTenant(response: HttpResponseBase): Observable<RegisterTenantOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RegisterTenantOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RegisterTenantOutput>(<any>null);
    }

    /**
     * @return Success
     */
    getEditionsForSelect(): Observable<EditionsSelectOutput> {
        let url_ = this.baseUrl + "/api/services/app/TenantRegistration/GetEditionsForSelect";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEditionsForSelect(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEditionsForSelect(<any>response_);
                } catch (e) {
                    return <Observable<EditionsSelectOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<EditionsSelectOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetEditionsForSelect(response: HttpResponseBase): Observable<EditionsSelectOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EditionsSelectOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EditionsSelectOutput>(<any>null);
    }

    /**
     * @param editionId (optional) 
     * @return Success
     */
    getEdition(editionId: number | null | undefined): Observable<EditionSelectDto> {
        let url_ = this.baseUrl + "/api/services/app/TenantRegistration/GetEdition?";
        if (editionId !== undefined)
            url_ += "editionId=" + encodeURIComponent("" + editionId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEdition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEdition(<any>response_);
                } catch (e) {
                    return <Observable<EditionSelectDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<EditionSelectDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetEdition(response: HttpResponseBase): Observable<EditionSelectDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EditionSelectDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EditionSelectDto>(<any>null);
    }
}

@Injectable()
export class TenantSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getAllSettings(): Observable<TenantSettingsEditDto> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/GetAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSettings(<any>response_);
                } catch (e) {
                    return <Observable<TenantSettingsEditDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<TenantSettingsEditDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSettings(response: HttpResponseBase): Observable<TenantSettingsEditDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TenantSettingsEditDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TenantSettingsEditDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateAllSettings(input: TenantSettingsEditDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/UpdateAllSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAllSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAllSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAllSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    clearLogo(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/ClearLogo";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearLogo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearLogo(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearLogo(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    clearCustomCss(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/ClearCustomCss";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearCustomCss(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearCustomCss(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processClearCustomCss(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    sendTestEmail(input: SendTestEmailInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/TenantSettings/SendTestEmail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTestEmail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTestEmail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendTestEmail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class TimingServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getTimezones(defaultTimezoneScope: SettingScopes): Observable<ListResultDtoOfNameValueDto> {
        let url_ = this.baseUrl + "/api/services/app/Timing/GetTimezones?";
        if (defaultTimezoneScope === undefined || defaultTimezoneScope === null)
            throw new Error("The parameter 'defaultTimezoneScope' must be defined and cannot be null.");
        else
            url_ += "DefaultTimezoneScope=" + encodeURIComponent("" + defaultTimezoneScope) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTimezones(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTimezones(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfNameValueDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfNameValueDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetTimezones(response: HttpResponseBase): Observable<ListResultDtoOfNameValueDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfNameValueDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfNameValueDto>(<any>null);
    }

    /**
     * @param selectedTimezoneId (optional) 
     * @return Success
     */
    getTimezoneComboboxItems(selectedTimezoneId: string | null | undefined): Observable<ComboboxItemDto[]> {
        let url_ = this.baseUrl + "/api/services/app/Timing/GetTimezoneComboboxItems?";
        if (selectedTimezoneId !== undefined)
            url_ += "SelectedTimezoneId=" + encodeURIComponent("" + selectedTimezoneId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTimezoneComboboxItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTimezoneComboboxItems(<any>response_);
                } catch (e) {
                    return <Observable<ComboboxItemDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ComboboxItemDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTimezoneComboboxItems(response: HttpResponseBase): Observable<ComboboxItemDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ComboboxItemDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ComboboxItemDto[]>(<any>null);
    }
}

@Injectable()
export class TokenAuthServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    authenticate(model: AuthenticateModel | null | undefined): Observable<AuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/Authenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processAuthenticate(response: HttpResponseBase): Observable<AuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticateResultModel>(<any>null);
    }

    /**
     * @param refreshToken (optional) 
     * @return Success
     */
    refreshToken(refreshToken: string | null | undefined): Observable<RefreshTokenResult> {
        let url_ = this.baseUrl + "/api/TokenAuth/RefreshToken?";
        if (refreshToken !== undefined)
            url_ += "refreshToken=" + encodeURIComponent("" + refreshToken) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefreshToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefreshToken(<any>response_);
                } catch (e) {
                    return <Observable<RefreshTokenResult>><any>_observableThrow(e);
                }
            } else
                return <Observable<RefreshTokenResult>><any>_observableThrow(response_);
        }));
    }

    protected processRefreshToken(response: HttpResponseBase): Observable<RefreshTokenResult> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RefreshTokenResult.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RefreshTokenResult>(<any>null);
    }

    /**
     * @return Success
     */
    logOut(): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/LogOut";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogOut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogOut(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processLogOut(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    sendTwoFactorAuthCode(model: SendTwoFactorAuthCodeModel | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/SendTwoFactorAuthCode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendTwoFactorAuthCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendTwoFactorAuthCode(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSendTwoFactorAuthCode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param impersonationToken (optional) 
     * @return Success
     */
    impersonatedAuthenticate(impersonationToken: string | null | undefined): Observable<ImpersonatedAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ImpersonatedAuthenticate?";
        if (impersonationToken !== undefined)
            url_ += "impersonationToken=" + encodeURIComponent("" + impersonationToken) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImpersonatedAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImpersonatedAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<ImpersonatedAuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ImpersonatedAuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processImpersonatedAuthenticate(response: HttpResponseBase): Observable<ImpersonatedAuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImpersonatedAuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ImpersonatedAuthenticateResultModel>(<any>null);
    }

    /**
     * @param switchAccountToken (optional) 
     * @return Success
     */
    linkedAccountAuthenticate(switchAccountToken: string | null | undefined): Observable<SwitchedAccountAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/LinkedAccountAuthenticate?";
        if (switchAccountToken !== undefined)
            url_ += "switchAccountToken=" + encodeURIComponent("" + switchAccountToken) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLinkedAccountAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLinkedAccountAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<SwitchedAccountAuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<SwitchedAccountAuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processLinkedAccountAuthenticate(response: HttpResponseBase): Observable<SwitchedAccountAuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SwitchedAccountAuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SwitchedAccountAuthenticateResultModel>(<any>null);
    }

    /**
     * @return Success
     */
    getExternalAuthenticationProviders(): Observable<ExternalLoginProviderInfoModel[]> {
        let url_ = this.baseUrl + "/api/TokenAuth/GetExternalAuthenticationProviders";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetExternalAuthenticationProviders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetExternalAuthenticationProviders(<any>response_);
                } catch (e) {
                    return <Observable<ExternalLoginProviderInfoModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalLoginProviderInfoModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetExternalAuthenticationProviders(response: HttpResponseBase): Observable<ExternalLoginProviderInfoModel[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ExternalLoginProviderInfoModel.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalLoginProviderInfoModel[]>(<any>null);
    }

    /**
     * @param model (optional) 
     * @return Success
     */
    externalAuthenticate(model: ExternalAuthenticateModel | null | undefined): Observable<ExternalAuthenticateResultModel> {
        let url_ = this.baseUrl + "/api/TokenAuth/ExternalAuthenticate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExternalAuthenticate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExternalAuthenticate(<any>response_);
                } catch (e) {
                    return <Observable<ExternalAuthenticateResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExternalAuthenticateResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processExternalAuthenticate(response: HttpResponseBase): Observable<ExternalAuthenticateResultModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExternalAuthenticateResultModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExternalAuthenticateResultModel>(<any>null);
    }

    /**
     * @param message (optional) 
     * @param severity (optional) 
     * @return Success
     */
    testNotification(message: string | null | undefined, severity: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/TokenAuth/TestNotification?";
        if (message !== undefined)
            url_ += "message=" + encodeURIComponent("" + message) + "&"; 
        if (severity !== undefined)
            url_ += "severity=" + encodeURIComponent("" + severity) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTestNotification(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTestNotification(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processTestNotification(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class UiCustomizationSettingsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getUiManagementSettings(): Observable<ThemeSettingsDto[]> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/GetUiManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUiManagementSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUiManagementSettings(<any>response_);
                } catch (e) {
                    return <Observable<ThemeSettingsDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ThemeSettingsDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetUiManagementSettings(response: HttpResponseBase): Observable<ThemeSettingsDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ThemeSettingsDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ThemeSettingsDto[]>(<any>null);
    }

    /**
     * @param themeName (optional) 
     * @return Success
     */
    changeThemeWithDefaultValues(themeName: string | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/ChangeThemeWithDefaultValues?";
        if (themeName !== undefined)
            url_ += "themeName=" + encodeURIComponent("" + themeName) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeThemeWithDefaultValues(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeThemeWithDefaultValues(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processChangeThemeWithDefaultValues(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param settings (optional) 
     * @return Success
     */
    updateUiManagementSettings(settings: ThemeSettingsDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/UpdateUiManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUiManagementSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUiManagementSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUiManagementSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param settings (optional) 
     * @return Success
     */
    updateDefaultUiManagementSettings(settings: ThemeSettingsDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/UpdateDefaultUiManagementSettings";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(settings);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDefaultUiManagementSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDefaultUiManagementSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateDefaultUiManagementSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @return Success
     */
    useSystemDefaultSettings(): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UiCustomizationSettings/UseSystemDefaultSettings";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUseSystemDefaultSettings(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUseSystemDefaultSettings(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUseSystemDefaultSettings(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class UomsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetUomForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Uoms/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetUomForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetUomForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetUomForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetUomForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetUomForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUomForView(id: number | null | undefined): Observable<GetUomForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Uoms/GetUomForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUomForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUomForView(<any>response_);
                } catch (e) {
                    return <Observable<GetUomForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUomForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUomForView(response: HttpResponseBase): Observable<GetUomForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUomForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUomForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUomForEdit(id: number | null | undefined): Observable<GetUomForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Uoms/GetUomForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUomForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUomForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetUomForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUomForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUomForEdit(response: HttpResponseBase): Observable<GetUomForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUomForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUomForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditUomDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Uoms/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Uoms/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllUomForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfUomLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Uoms/GetAllUomForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUomForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUomForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUomLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfUomLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUomForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfUomLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfUomLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUomLookupTableDto>(<any>null);
    }
}

@Injectable()
export class UsageMetricRecordsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param referenceFilter (optional) 
     * @param maxStartTimeFilter (optional) 
     * @param minStartTimeFilter (optional) 
     * @param maxEndTimeFilter (optional) 
     * @param minEndTimeFilter (optional) 
     * @param maxUnitsConsumedFilter (optional) 
     * @param minUnitsConsumedFilter (optional) 
     * @param usageMetricMetricFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, referenceFilter: string | null | undefined, maxStartTimeFilter: moment.Moment | null | undefined, minStartTimeFilter: moment.Moment | null | undefined, maxEndTimeFilter: moment.Moment | null | undefined, minEndTimeFilter: moment.Moment | null | undefined, maxUnitsConsumedFilter: number | null | undefined, minUnitsConsumedFilter: number | null | undefined, usageMetricMetricFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetUsageMetricRecordForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/UsageMetricRecords/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (referenceFilter !== undefined)
            url_ += "ReferenceFilter=" + encodeURIComponent("" + referenceFilter) + "&"; 
        if (maxStartTimeFilter !== undefined)
            url_ += "MaxStartTimeFilter=" + encodeURIComponent(maxStartTimeFilter ? "" + maxStartTimeFilter.toJSON() : "") + "&"; 
        if (minStartTimeFilter !== undefined)
            url_ += "MinStartTimeFilter=" + encodeURIComponent(minStartTimeFilter ? "" + minStartTimeFilter.toJSON() : "") + "&"; 
        if (maxEndTimeFilter !== undefined)
            url_ += "MaxEndTimeFilter=" + encodeURIComponent(maxEndTimeFilter ? "" + maxEndTimeFilter.toJSON() : "") + "&"; 
        if (minEndTimeFilter !== undefined)
            url_ += "MinEndTimeFilter=" + encodeURIComponent(minEndTimeFilter ? "" + minEndTimeFilter.toJSON() : "") + "&"; 
        if (maxUnitsConsumedFilter !== undefined)
            url_ += "MaxUnitsConsumedFilter=" + encodeURIComponent("" + maxUnitsConsumedFilter) + "&"; 
        if (minUnitsConsumedFilter !== undefined)
            url_ += "MinUnitsConsumedFilter=" + encodeURIComponent("" + minUnitsConsumedFilter) + "&"; 
        if (usageMetricMetricFilter !== undefined)
            url_ += "UsageMetricMetricFilter=" + encodeURIComponent("" + usageMetricMetricFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetUsageMetricRecordForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetUsageMetricRecordForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetUsageMetricRecordForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetUsageMetricRecordForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetUsageMetricRecordForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUsageMetricRecordForView(id: number | null | undefined): Observable<GetUsageMetricRecordForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/UsageMetricRecords/GetUsageMetricRecordForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsageMetricRecordForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsageMetricRecordForView(<any>response_);
                } catch (e) {
                    return <Observable<GetUsageMetricRecordForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUsageMetricRecordForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsageMetricRecordForView(response: HttpResponseBase): Observable<GetUsageMetricRecordForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUsageMetricRecordForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUsageMetricRecordForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUsageMetricRecordForEdit(id: number | null | undefined): Observable<GetUsageMetricRecordForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/UsageMetricRecords/GetUsageMetricRecordForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsageMetricRecordForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsageMetricRecordForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetUsageMetricRecordForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUsageMetricRecordForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsageMetricRecordForEdit(response: HttpResponseBase): Observable<GetUsageMetricRecordForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUsageMetricRecordForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUsageMetricRecordForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditUsageMetricRecordDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UsageMetricRecords/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UsageMetricRecords/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param referenceFilter (optional) 
     * @param maxStartTimeFilter (optional) 
     * @param minStartTimeFilter (optional) 
     * @param maxEndTimeFilter (optional) 
     * @param minEndTimeFilter (optional) 
     * @param maxUnitsConsumedFilter (optional) 
     * @param minUnitsConsumedFilter (optional) 
     * @param usageMetricMetricFilter (optional) 
     * @return Success
     */
    getUsageMetricRecordsToExcel(filter: string | null | undefined, referenceFilter: string | null | undefined, maxStartTimeFilter: moment.Moment | null | undefined, minStartTimeFilter: moment.Moment | null | undefined, maxEndTimeFilter: moment.Moment | null | undefined, minEndTimeFilter: moment.Moment | null | undefined, maxUnitsConsumedFilter: number | null | undefined, minUnitsConsumedFilter: number | null | undefined, usageMetricMetricFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/UsageMetricRecords/GetUsageMetricRecordsToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (referenceFilter !== undefined)
            url_ += "ReferenceFilter=" + encodeURIComponent("" + referenceFilter) + "&"; 
        if (maxStartTimeFilter !== undefined)
            url_ += "MaxStartTimeFilter=" + encodeURIComponent(maxStartTimeFilter ? "" + maxStartTimeFilter.toJSON() : "") + "&"; 
        if (minStartTimeFilter !== undefined)
            url_ += "MinStartTimeFilter=" + encodeURIComponent(minStartTimeFilter ? "" + minStartTimeFilter.toJSON() : "") + "&"; 
        if (maxEndTimeFilter !== undefined)
            url_ += "MaxEndTimeFilter=" + encodeURIComponent(maxEndTimeFilter ? "" + maxEndTimeFilter.toJSON() : "") + "&"; 
        if (minEndTimeFilter !== undefined)
            url_ += "MinEndTimeFilter=" + encodeURIComponent(minEndTimeFilter ? "" + minEndTimeFilter.toJSON() : "") + "&"; 
        if (maxUnitsConsumedFilter !== undefined)
            url_ += "MaxUnitsConsumedFilter=" + encodeURIComponent("" + maxUnitsConsumedFilter) + "&"; 
        if (minUnitsConsumedFilter !== undefined)
            url_ += "MinUnitsConsumedFilter=" + encodeURIComponent("" + minUnitsConsumedFilter) + "&"; 
        if (usageMetricMetricFilter !== undefined)
            url_ += "UsageMetricMetricFilter=" + encodeURIComponent("" + usageMetricMetricFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsageMetricRecordsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsageMetricRecordsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsageMetricRecordsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllUsageMetricForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfUsageMetricRecordUsageMetricLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/UsageMetricRecords/GetAllUsageMetricForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUsageMetricForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUsageMetricForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUsageMetricRecordUsageMetricLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfUsageMetricRecordUsageMetricLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUsageMetricForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfUsageMetricRecordUsageMetricLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfUsageMetricRecordUsageMetricLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUsageMetricRecordUsageMetricLookupTableDto>(<any>null);
    }

    /**
     * @param usageMetricId (optional) 
     * @param filter (optional) 
     * @param referenceFilter (optional) 
     * @param maxStartTimeFilter (optional) 
     * @param minStartTimeFilter (optional) 
     * @param maxEndTimeFilter (optional) 
     * @param minEndTimeFilter (optional) 
     * @param maxUnitsConsumedFilter (optional) 
     * @param minUnitsConsumedFilter (optional) 
     * @param usageMetricMetricFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllByUsageMetric(usageMetricId: number | null | undefined, filter: string | null | undefined, referenceFilter: string | null | undefined, maxStartTimeFilter: moment.Moment | null | undefined, minStartTimeFilter: moment.Moment | null | undefined, maxEndTimeFilter: moment.Moment | null | undefined, minEndTimeFilter: moment.Moment | null | undefined, maxUnitsConsumedFilter: number | null | undefined, minUnitsConsumedFilter: number | null | undefined, usageMetricMetricFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetUsageMetricRecordForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/UsageMetricRecords/GetAllByUsageMetric?";
        if (usageMetricId !== undefined)
            url_ += "UsageMetricId=" + encodeURIComponent("" + usageMetricId) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (referenceFilter !== undefined)
            url_ += "ReferenceFilter=" + encodeURIComponent("" + referenceFilter) + "&"; 
        if (maxStartTimeFilter !== undefined)
            url_ += "MaxStartTimeFilter=" + encodeURIComponent(maxStartTimeFilter ? "" + maxStartTimeFilter.toJSON() : "") + "&"; 
        if (minStartTimeFilter !== undefined)
            url_ += "MinStartTimeFilter=" + encodeURIComponent(minStartTimeFilter ? "" + minStartTimeFilter.toJSON() : "") + "&"; 
        if (maxEndTimeFilter !== undefined)
            url_ += "MaxEndTimeFilter=" + encodeURIComponent(maxEndTimeFilter ? "" + maxEndTimeFilter.toJSON() : "") + "&"; 
        if (minEndTimeFilter !== undefined)
            url_ += "MinEndTimeFilter=" + encodeURIComponent(minEndTimeFilter ? "" + minEndTimeFilter.toJSON() : "") + "&"; 
        if (maxUnitsConsumedFilter !== undefined)
            url_ += "MaxUnitsConsumedFilter=" + encodeURIComponent("" + maxUnitsConsumedFilter) + "&"; 
        if (minUnitsConsumedFilter !== undefined)
            url_ += "MinUnitsConsumedFilter=" + encodeURIComponent("" + minUnitsConsumedFilter) + "&"; 
        if (usageMetricMetricFilter !== undefined)
            url_ += "UsageMetricMetricFilter=" + encodeURIComponent("" + usageMetricMetricFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllByUsageMetric(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllByUsageMetric(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetUsageMetricRecordForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetUsageMetricRecordForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllByUsageMetric(response: HttpResponseBase): Observable<PagedResultDtoOfGetUsageMetricRecordForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetUsageMetricRecordForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetUsageMetricRecordForViewDto>(<any>null);
    }

    /**
     * @param usageMetricId (optional) 
     * @return Success
     */
    getByUsageMetric(usageMetricId: number | null | undefined): Observable<GetUsageMetricRecordForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/UsageMetricRecords/GetByUsageMetric?";
        if (usageMetricId !== undefined)
            url_ += "usageMetricId=" + encodeURIComponent("" + usageMetricId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByUsageMetric(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByUsageMetric(<any>response_);
                } catch (e) {
                    return <Observable<GetUsageMetricRecordForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUsageMetricRecordForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetByUsageMetric(response: HttpResponseBase): Observable<GetUsageMetricRecordForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUsageMetricRecordForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUsageMetricRecordForViewDto>(<any>null);
    }
}

@Injectable()
export class UsageMetricsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param metricFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param leaseItemItemFilter (optional) 
     * @param assetReferenceFilter (optional) 
     * @param uomUnitOfMeasurementFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, metricFilter: string | null | undefined, descriptionFilter: string | null | undefined, leaseItemItemFilter: string | null | undefined, assetReferenceFilter: string | null | undefined, uomUnitOfMeasurementFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetUsageMetricForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/UsageMetrics/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (metricFilter !== undefined)
            url_ += "MetricFilter=" + encodeURIComponent("" + metricFilter) + "&"; 
        if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (leaseItemItemFilter !== undefined)
            url_ += "LeaseItemItemFilter=" + encodeURIComponent("" + leaseItemItemFilter) + "&"; 
        if (assetReferenceFilter !== undefined)
            url_ += "AssetReferenceFilter=" + encodeURIComponent("" + assetReferenceFilter) + "&"; 
        if (uomUnitOfMeasurementFilter !== undefined)
            url_ += "UomUnitOfMeasurementFilter=" + encodeURIComponent("" + uomUnitOfMeasurementFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetUsageMetricForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetUsageMetricForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetUsageMetricForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetUsageMetricForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetUsageMetricForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUsageMetricForView(id: number | null | undefined): Observable<GetUsageMetricForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/UsageMetrics/GetUsageMetricForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsageMetricForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsageMetricForView(<any>response_);
                } catch (e) {
                    return <Observable<GetUsageMetricForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUsageMetricForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsageMetricForView(response: HttpResponseBase): Observable<GetUsageMetricForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUsageMetricForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUsageMetricForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUsageMetricForEdit(id: number | null | undefined): Observable<GetUsageMetricForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/UsageMetrics/GetUsageMetricForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsageMetricForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsageMetricForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetUsageMetricForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUsageMetricForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsageMetricForEdit(response: HttpResponseBase): Observable<GetUsageMetricForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUsageMetricForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUsageMetricForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditUsageMetricDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UsageMetrics/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UsageMetrics/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param metricFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param leaseItemItemFilter (optional) 
     * @param assetReferenceFilter (optional) 
     * @param uomUnitOfMeasurementFilter (optional) 
     * @return Success
     */
    getUsageMetricsToExcel(filter: string | null | undefined, metricFilter: string | null | undefined, descriptionFilter: string | null | undefined, leaseItemItemFilter: string | null | undefined, assetReferenceFilter: string | null | undefined, uomUnitOfMeasurementFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/UsageMetrics/GetUsageMetricsToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (metricFilter !== undefined)
            url_ += "MetricFilter=" + encodeURIComponent("" + metricFilter) + "&"; 
        if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (leaseItemItemFilter !== undefined)
            url_ += "LeaseItemItemFilter=" + encodeURIComponent("" + leaseItemItemFilter) + "&"; 
        if (assetReferenceFilter !== undefined)
            url_ += "AssetReferenceFilter=" + encodeURIComponent("" + assetReferenceFilter) + "&"; 
        if (uomUnitOfMeasurementFilter !== undefined)
            url_ += "UomUnitOfMeasurementFilter=" + encodeURIComponent("" + uomUnitOfMeasurementFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsageMetricsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsageMetricsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsageMetricsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllLeaseItemForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfUsageMetricLeaseItemLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/UsageMetrics/GetAllLeaseItemForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllLeaseItemForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllLeaseItemForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUsageMetricLeaseItemLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfUsageMetricLeaseItemLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllLeaseItemForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfUsageMetricLeaseItemLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfUsageMetricLeaseItemLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUsageMetricLeaseItemLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllAssetForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfUsageMetricAssetLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/UsageMetrics/GetAllAssetForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAssetForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAssetForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUsageMetricAssetLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfUsageMetricAssetLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAssetForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfUsageMetricAssetLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfUsageMetricAssetLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUsageMetricAssetLookupTableDto>(<any>null);
    }

    /**
     * @param relatedEntity (optional) 
     * @param referenceId (optional) 
     * @return Success
     */
    getUsageMetrics(relatedEntity: string | null | undefined, referenceId: number | null | undefined): Observable<UsageMetricDto[]> {
        let url_ = this.baseUrl + "/api/services/app/UsageMetrics/GetUsageMetrics?";
        if (relatedEntity !== undefined)
            url_ += "RelatedEntity=" + encodeURIComponent("" + relatedEntity) + "&"; 
        if (referenceId !== undefined)
            url_ += "ReferenceId=" + encodeURIComponent("" + referenceId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsageMetrics(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsageMetrics(<any>response_);
                } catch (e) {
                    return <Observable<UsageMetricDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UsageMetricDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsageMetrics(response: HttpResponseBase): Observable<UsageMetricDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UsageMetricDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UsageMetricDto[]>(<any>null);
    }

    /**
     * @param relatedEntity (optional) 
     * @param referenceId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getSome(relatedEntity: string | null | undefined, referenceId: number | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetUsageMetricForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/UsageMetrics/GetSome?";
        if (relatedEntity !== undefined)
            url_ += "RelatedEntity=" + encodeURIComponent("" + relatedEntity) + "&"; 
        if (referenceId !== undefined)
            url_ += "ReferenceId=" + encodeURIComponent("" + referenceId) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSome(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSome(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetUsageMetricForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetUsageMetricForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetSome(response: HttpResponseBase): Observable<PagedResultDtoOfGetUsageMetricForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetUsageMetricForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetUsageMetricForViewDto>(<any>null);
    }
}

@Injectable()
export class UserServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param permissions (optional) 
     * @param role (optional) 
     * @param onlyLockedUsers (optional) 
     * @param sorting (optional) 
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @return Success
     */
    getUsers(filter: string | null | undefined, permissions: string[] | null | undefined, role: number | null | undefined, onlyLockedUsers: boolean | null | undefined, sorting: string | null | undefined, maxResultCount: number | null | undefined, skipCount: number | null | undefined): Observable<PagedResultDtoOfUserListDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUsers?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (permissions !== undefined)
            permissions && permissions.forEach(item => { url_ += "Permissions=" + encodeURIComponent("" + item) + "&"; });
        if (role !== undefined)
            url_ += "Role=" + encodeURIComponent("" + role) + "&"; 
        if (onlyLockedUsers !== undefined)
            url_ += "OnlyLockedUsers=" + encodeURIComponent("" + onlyLockedUsers) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfUserListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfUserListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsers(response: HttpResponseBase): Observable<PagedResultDtoOfUserListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfUserListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfUserListDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param permissions (optional) 
     * @param role (optional) 
     * @param onlyLockedUsers (optional) 
     * @param sorting (optional) 
     * @return Success
     */
    getUsersToExcel(filter: string | null | undefined, permissions: string[] | null | undefined, role: number | null | undefined, onlyLockedUsers: boolean | null | undefined, sorting: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUsersToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (permissions !== undefined)
            permissions && permissions.forEach(item => { url_ += "Permissions=" + encodeURIComponent("" + item) + "&"; });
        if (role !== undefined)
            url_ += "Role=" + encodeURIComponent("" + role) + "&"; 
        if (onlyLockedUsers !== undefined)
            url_ += "OnlyLockedUsers=" + encodeURIComponent("" + onlyLockedUsers) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsersToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsersToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsersToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUserForEdit(id: number | null | undefined): Observable<GetUserForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUserForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetUserForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserForEdit(response: HttpResponseBase): Observable<GetUserForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUserForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserForEditOutput>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getUserPermissionsForEdit(id: number | null | undefined): Observable<GetUserPermissionsForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/User/GetUserPermissionsForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserPermissionsForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserPermissionsForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetUserPermissionsForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetUserPermissionsForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserPermissionsForEdit(response: HttpResponseBase): Observable<GetUserPermissionsForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUserPermissionsForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetUserPermissionsForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    resetUserSpecificPermissions(input: EntityDtoOfInt64 | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/ResetUserSpecificPermissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetUserSpecificPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetUserSpecificPermissions(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processResetUserSpecificPermissions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    updateUserPermissions(input: UpdateUserPermissionsInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/UpdateUserPermissions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserPermissions(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUserPermissions(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrUpdateUser(input: CreateOrUpdateUserInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/CreateOrUpdateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrUpdateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrUpdateUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrUpdateUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deleteUser(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/DeleteUser?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    unlockUser(input: EntityDtoOfInt64 | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/User/UnlockUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnlockUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlockUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnlockUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class UserLinkServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    linkToUser(input: LinkToUserInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/LinkToUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLinkToUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLinkToUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processLinkToUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param maxResultCount (optional) 
     * @param skipCount (optional) 
     * @param sorting (optional) 
     * @return Success
     */
    getLinkedUsers(maxResultCount: number | null | undefined, skipCount: number | null | undefined, sorting: string | null | undefined): Observable<PagedResultDtoOfLinkedUserDto> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/GetLinkedUsers?";
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLinkedUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLinkedUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfLinkedUserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfLinkedUserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetLinkedUsers(response: HttpResponseBase): Observable<PagedResultDtoOfLinkedUserDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfLinkedUserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfLinkedUserDto>(<any>null);
    }

    /**
     * @return Success
     */
    getRecentlyUsedLinkedUsers(): Observable<ListResultDtoOfLinkedUserDto> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/GetRecentlyUsedLinkedUsers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentlyUsedLinkedUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentlyUsedLinkedUsers(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfLinkedUserDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfLinkedUserDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecentlyUsedLinkedUsers(response: HttpResponseBase): Observable<ListResultDtoOfLinkedUserDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfLinkedUserDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfLinkedUserDto>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    unlinkUser(input: UnlinkUserInput | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/UserLink/UnlinkUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnlinkUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnlinkUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUnlinkUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class UserLoginServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getRecentUserLoginAttempts(): Observable<ListResultDtoOfUserLoginAttemptDto> {
        let url_ = this.baseUrl + "/api/services/app/UserLogin/GetRecentUserLoginAttempts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentUserLoginAttempts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentUserLoginAttempts(<any>response_);
                } catch (e) {
                    return <Observable<ListResultDtoOfUserLoginAttemptDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ListResultDtoOfUserLoginAttemptDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecentUserLoginAttempts(response: HttpResponseBase): Observable<ListResultDtoOfUserLoginAttemptDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ListResultDtoOfUserLoginAttemptDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ListResultDtoOfUserLoginAttemptDto>(<any>null);
    }
}

@Injectable()
export class VendorChargeDetailsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param invoiceDetailFilter (optional) 
     * @param maxQuantityFilter (optional) 
     * @param minQuantityFilter (optional) 
     * @param maxUnitPriceFilter (optional) 
     * @param minUnitPriceFilter (optional) 
     * @param maxTaxFilter (optional) 
     * @param minTaxFilter (optional) 
     * @param maxSubTotalFilter (optional) 
     * @param minSubTotalFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, invoiceDetailFilter: string | null | undefined, maxQuantityFilter: number | null | undefined, minQuantityFilter: number | null | undefined, maxUnitPriceFilter: number | null | undefined, minUnitPriceFilter: number | null | undefined, maxTaxFilter: number | null | undefined, minTaxFilter: number | null | undefined, maxSubTotalFilter: number | null | undefined, minSubTotalFilter: number | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetVendorChargeDetailForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/VendorChargeDetails/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (invoiceDetailFilter !== undefined)
            url_ += "InvoiceDetailFilter=" + encodeURIComponent("" + invoiceDetailFilter) + "&"; 
        if (maxQuantityFilter !== undefined)
            url_ += "MaxQuantityFilter=" + encodeURIComponent("" + maxQuantityFilter) + "&"; 
        if (minQuantityFilter !== undefined)
            url_ += "MinQuantityFilter=" + encodeURIComponent("" + minQuantityFilter) + "&"; 
        if (maxUnitPriceFilter !== undefined)
            url_ += "MaxUnitPriceFilter=" + encodeURIComponent("" + maxUnitPriceFilter) + "&"; 
        if (minUnitPriceFilter !== undefined)
            url_ += "MinUnitPriceFilter=" + encodeURIComponent("" + minUnitPriceFilter) + "&"; 
        if (maxTaxFilter !== undefined)
            url_ += "MaxTaxFilter=" + encodeURIComponent("" + maxTaxFilter) + "&"; 
        if (minTaxFilter !== undefined)
            url_ += "MinTaxFilter=" + encodeURIComponent("" + minTaxFilter) + "&"; 
        if (maxSubTotalFilter !== undefined)
            url_ += "MaxSubTotalFilter=" + encodeURIComponent("" + maxSubTotalFilter) + "&"; 
        if (minSubTotalFilter !== undefined)
            url_ += "MinSubTotalFilter=" + encodeURIComponent("" + minSubTotalFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetVendorChargeDetailForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetVendorChargeDetailForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetVendorChargeDetailForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetVendorChargeDetailForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetVendorChargeDetailForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getVendorChargeDetailForView(id: number | null | undefined): Observable<GetVendorChargeDetailForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/VendorChargeDetails/GetVendorChargeDetailForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVendorChargeDetailForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVendorChargeDetailForView(<any>response_);
                } catch (e) {
                    return <Observable<GetVendorChargeDetailForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetVendorChargeDetailForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetVendorChargeDetailForView(response: HttpResponseBase): Observable<GetVendorChargeDetailForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetVendorChargeDetailForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetVendorChargeDetailForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getVendorChargeDetailForEdit(id: number | null | undefined): Observable<GetVendorChargeDetailForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/VendorChargeDetails/GetVendorChargeDetailForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVendorChargeDetailForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVendorChargeDetailForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetVendorChargeDetailForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetVendorChargeDetailForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetVendorChargeDetailForEdit(response: HttpResponseBase): Observable<GetVendorChargeDetailForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetVendorChargeDetailForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetVendorChargeDetailForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditVendorChargeDetailDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/VendorChargeDetails/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/VendorChargeDetails/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class VendorChargesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param referenceFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param maxDateIssuedFilter (optional) 
     * @param minDateIssuedFilter (optional) 
     * @param maxDateDueFilter (optional) 
     * @param minDateDueFilter (optional) 
     * @param maxTotalTaxFilter (optional) 
     * @param minTotalTaxFilter (optional) 
     * @param maxTotalPriceFilter (optional) 
     * @param minTotalPriceFilter (optional) 
     * @param vendorNameFilter (optional) 
     * @param supportContractTitleFilter (optional) 
     * @param workOrderSubjectFilter (optional) 
     * @param vendorChargeStatusStatusFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, referenceFilter: string | null | undefined, descriptionFilter: string | null | undefined, maxDateIssuedFilter: moment.Moment | null | undefined, minDateIssuedFilter: moment.Moment | null | undefined, maxDateDueFilter: moment.Moment | null | undefined, minDateDueFilter: moment.Moment | null | undefined, maxTotalTaxFilter: number | null | undefined, minTotalTaxFilter: number | null | undefined, maxTotalPriceFilter: number | null | undefined, minTotalPriceFilter: number | null | undefined, vendorNameFilter: string | null | undefined, supportContractTitleFilter: string | null | undefined, workOrderSubjectFilter: string | null | undefined, vendorChargeStatusStatusFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetVendorChargeForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/VendorCharges/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (referenceFilter !== undefined)
            url_ += "ReferenceFilter=" + encodeURIComponent("" + referenceFilter) + "&"; 
        if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (maxDateIssuedFilter !== undefined)
            url_ += "MaxDateIssuedFilter=" + encodeURIComponent(maxDateIssuedFilter ? "" + maxDateIssuedFilter.toJSON() : "") + "&"; 
        if (minDateIssuedFilter !== undefined)
            url_ += "MinDateIssuedFilter=" + encodeURIComponent(minDateIssuedFilter ? "" + minDateIssuedFilter.toJSON() : "") + "&"; 
        if (maxDateDueFilter !== undefined)
            url_ += "MaxDateDueFilter=" + encodeURIComponent(maxDateDueFilter ? "" + maxDateDueFilter.toJSON() : "") + "&"; 
        if (minDateDueFilter !== undefined)
            url_ += "MinDateDueFilter=" + encodeURIComponent(minDateDueFilter ? "" + minDateDueFilter.toJSON() : "") + "&"; 
        if (maxTotalTaxFilter !== undefined)
            url_ += "MaxTotalTaxFilter=" + encodeURIComponent("" + maxTotalTaxFilter) + "&"; 
        if (minTotalTaxFilter !== undefined)
            url_ += "MinTotalTaxFilter=" + encodeURIComponent("" + minTotalTaxFilter) + "&"; 
        if (maxTotalPriceFilter !== undefined)
            url_ += "MaxTotalPriceFilter=" + encodeURIComponent("" + maxTotalPriceFilter) + "&"; 
        if (minTotalPriceFilter !== undefined)
            url_ += "MinTotalPriceFilter=" + encodeURIComponent("" + minTotalPriceFilter) + "&"; 
        if (vendorNameFilter !== undefined)
            url_ += "VendorNameFilter=" + encodeURIComponent("" + vendorNameFilter) + "&"; 
        if (supportContractTitleFilter !== undefined)
            url_ += "SupportContractTitleFilter=" + encodeURIComponent("" + supportContractTitleFilter) + "&"; 
        if (workOrderSubjectFilter !== undefined)
            url_ += "WorkOrderSubjectFilter=" + encodeURIComponent("" + workOrderSubjectFilter) + "&"; 
        if (vendorChargeStatusStatusFilter !== undefined)
            url_ += "VendorChargeStatusStatusFilter=" + encodeURIComponent("" + vendorChargeStatusStatusFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetVendorChargeForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetVendorChargeForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetVendorChargeForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetVendorChargeForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetVendorChargeForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getVendorChargeForView(id: number | null | undefined): Observable<GetVendorChargeForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/VendorCharges/GetVendorChargeForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVendorChargeForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVendorChargeForView(<any>response_);
                } catch (e) {
                    return <Observable<GetVendorChargeForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetVendorChargeForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetVendorChargeForView(response: HttpResponseBase): Observable<GetVendorChargeForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetVendorChargeForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetVendorChargeForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getVendorChargeForEdit(id: number | null | undefined): Observable<GetVendorChargeForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/VendorCharges/GetVendorChargeForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVendorChargeForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVendorChargeForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetVendorChargeForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetVendorChargeForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetVendorChargeForEdit(response: HttpResponseBase): Observable<GetVendorChargeForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetVendorChargeForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetVendorChargeForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditVendorChargeDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/VendorCharges/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/VendorCharges/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param referenceFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param maxDateIssuedFilter (optional) 
     * @param minDateIssuedFilter (optional) 
     * @param maxDateDueFilter (optional) 
     * @param minDateDueFilter (optional) 
     * @param maxTotalTaxFilter (optional) 
     * @param minTotalTaxFilter (optional) 
     * @param maxTotalPriceFilter (optional) 
     * @param minTotalPriceFilter (optional) 
     * @param vendorNameFilter (optional) 
     * @param supportContractTitleFilter (optional) 
     * @param workOrderSubjectFilter (optional) 
     * @param vendorChargeStatusStatusFilter (optional) 
     * @return Success
     */
    getVendorChargesToExcel(filter: string | null | undefined, referenceFilter: string | null | undefined, descriptionFilter: string | null | undefined, maxDateIssuedFilter: moment.Moment | null | undefined, minDateIssuedFilter: moment.Moment | null | undefined, maxDateDueFilter: moment.Moment | null | undefined, minDateDueFilter: moment.Moment | null | undefined, maxTotalTaxFilter: number | null | undefined, minTotalTaxFilter: number | null | undefined, maxTotalPriceFilter: number | null | undefined, minTotalPriceFilter: number | null | undefined, vendorNameFilter: string | null | undefined, supportContractTitleFilter: string | null | undefined, workOrderSubjectFilter: string | null | undefined, vendorChargeStatusStatusFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/VendorCharges/GetVendorChargesToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (referenceFilter !== undefined)
            url_ += "ReferenceFilter=" + encodeURIComponent("" + referenceFilter) + "&"; 
        if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (maxDateIssuedFilter !== undefined)
            url_ += "MaxDateIssuedFilter=" + encodeURIComponent(maxDateIssuedFilter ? "" + maxDateIssuedFilter.toJSON() : "") + "&"; 
        if (minDateIssuedFilter !== undefined)
            url_ += "MinDateIssuedFilter=" + encodeURIComponent(minDateIssuedFilter ? "" + minDateIssuedFilter.toJSON() : "") + "&"; 
        if (maxDateDueFilter !== undefined)
            url_ += "MaxDateDueFilter=" + encodeURIComponent(maxDateDueFilter ? "" + maxDateDueFilter.toJSON() : "") + "&"; 
        if (minDateDueFilter !== undefined)
            url_ += "MinDateDueFilter=" + encodeURIComponent(minDateDueFilter ? "" + minDateDueFilter.toJSON() : "") + "&"; 
        if (maxTotalTaxFilter !== undefined)
            url_ += "MaxTotalTaxFilter=" + encodeURIComponent("" + maxTotalTaxFilter) + "&"; 
        if (minTotalTaxFilter !== undefined)
            url_ += "MinTotalTaxFilter=" + encodeURIComponent("" + minTotalTaxFilter) + "&"; 
        if (maxTotalPriceFilter !== undefined)
            url_ += "MaxTotalPriceFilter=" + encodeURIComponent("" + maxTotalPriceFilter) + "&"; 
        if (minTotalPriceFilter !== undefined)
            url_ += "MinTotalPriceFilter=" + encodeURIComponent("" + minTotalPriceFilter) + "&"; 
        if (vendorNameFilter !== undefined)
            url_ += "VendorNameFilter=" + encodeURIComponent("" + vendorNameFilter) + "&"; 
        if (supportContractTitleFilter !== undefined)
            url_ += "SupportContractTitleFilter=" + encodeURIComponent("" + supportContractTitleFilter) + "&"; 
        if (workOrderSubjectFilter !== undefined)
            url_ += "WorkOrderSubjectFilter=" + encodeURIComponent("" + workOrderSubjectFilter) + "&"; 
        if (vendorChargeStatusStatusFilter !== undefined)
            url_ += "VendorChargeStatusStatusFilter=" + encodeURIComponent("" + vendorChargeStatusStatusFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVendorChargesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVendorChargesToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetVendorChargesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllVendorForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfVendorChargeVendorLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/VendorCharges/GetAllVendorForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllVendorForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllVendorForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfVendorChargeVendorLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfVendorChargeVendorLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllVendorForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfVendorChargeVendorLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfVendorChargeVendorLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfVendorChargeVendorLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllSupportContractForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfVendorChargeSupportContractLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/VendorCharges/GetAllSupportContractForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSupportContractForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSupportContractForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfVendorChargeSupportContractLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfVendorChargeSupportContractLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSupportContractForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfVendorChargeSupportContractLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfVendorChargeSupportContractLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfVendorChargeSupportContractLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllWorkOrderForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfVendorChargeWorkOrderLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/VendorCharges/GetAllWorkOrderForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWorkOrderForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWorkOrderForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfVendorChargeWorkOrderLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfVendorChargeWorkOrderLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllWorkOrderForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfVendorChargeWorkOrderLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfVendorChargeWorkOrderLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfVendorChargeWorkOrderLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllVendorChargeStatusForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfVendorChargeVendorChargeStatusLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/VendorCharges/GetAllVendorChargeStatusForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllVendorChargeStatusForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllVendorChargeStatusForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfVendorChargeVendorChargeStatusLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfVendorChargeVendorChargeStatusLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllVendorChargeStatusForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfVendorChargeVendorChargeStatusLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfVendorChargeVendorChargeStatusLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfVendorChargeVendorChargeStatusLookupTableDto>(<any>null);
    }
}

@Injectable()
export class VendorChargeStatusesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param statusFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, statusFilter: string | null | undefined, descriptionFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetVendorChargeStatusForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/VendorChargeStatuses/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (statusFilter !== undefined)
            url_ += "StatusFilter=" + encodeURIComponent("" + statusFilter) + "&"; 
        if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetVendorChargeStatusForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetVendorChargeStatusForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetVendorChargeStatusForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetVendorChargeStatusForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetVendorChargeStatusForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getVendorChargeStatusForView(id: number | null | undefined): Observable<GetVendorChargeStatusForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/VendorChargeStatuses/GetVendorChargeStatusForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVendorChargeStatusForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVendorChargeStatusForView(<any>response_);
                } catch (e) {
                    return <Observable<GetVendorChargeStatusForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetVendorChargeStatusForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetVendorChargeStatusForView(response: HttpResponseBase): Observable<GetVendorChargeStatusForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetVendorChargeStatusForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetVendorChargeStatusForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getVendorChargeStatusForEdit(id: number | null | undefined): Observable<GetVendorChargeStatusForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/VendorChargeStatuses/GetVendorChargeStatusForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVendorChargeStatusForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVendorChargeStatusForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetVendorChargeStatusForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetVendorChargeStatusForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetVendorChargeStatusForEdit(response: HttpResponseBase): Observable<GetVendorChargeStatusForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetVendorChargeStatusForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetVendorChargeStatusForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditVendorChargeStatusDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/VendorChargeStatuses/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/VendorChargeStatuses/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param statusFilter (optional) 
     * @param descriptionFilter (optional) 
     * @return Success
     */
    getVendorChargeStatusesToExcel(filter: string | null | undefined, statusFilter: string | null | undefined, descriptionFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/VendorChargeStatuses/GetVendorChargeStatusesToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (statusFilter !== undefined)
            url_ += "StatusFilter=" + encodeURIComponent("" + statusFilter) + "&"; 
        if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVendorChargeStatusesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVendorChargeStatusesToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetVendorChargeStatusesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class VendorsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param referenceFilter (optional) 
     * @param nameFilter (optional) 
     * @param identifierFilter (optional) 
     * @param vendorLoc8GUIDFilter (optional) 
     * @param ssicCodeCodeFilter (optional) 
     * @param currencyCodeFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, referenceFilter: string | null | undefined, nameFilter: string | null | undefined, identifierFilter: string | null | undefined, vendorLoc8GUIDFilter: string | null | undefined, ssicCodeCodeFilter: string | null | undefined, currencyCodeFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetVendorForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Vendors/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (referenceFilter !== undefined)
            url_ += "ReferenceFilter=" + encodeURIComponent("" + referenceFilter) + "&"; 
        if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&"; 
        if (identifierFilter !== undefined)
            url_ += "IdentifierFilter=" + encodeURIComponent("" + identifierFilter) + "&"; 
        if (vendorLoc8GUIDFilter !== undefined)
            url_ += "VendorLoc8GUIDFilter=" + encodeURIComponent("" + vendorLoc8GUIDFilter) + "&"; 
        if (ssicCodeCodeFilter !== undefined)
            url_ += "SsicCodeCodeFilter=" + encodeURIComponent("" + ssicCodeCodeFilter) + "&"; 
        if (currencyCodeFilter !== undefined)
            url_ += "CurrencyCodeFilter=" + encodeURIComponent("" + currencyCodeFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetVendorForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetVendorForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetVendorForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetVendorForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetVendorForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getVendorForView(id: number | null | undefined): Observable<GetVendorForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Vendors/GetVendorForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVendorForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVendorForView(<any>response_);
                } catch (e) {
                    return <Observable<GetVendorForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetVendorForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetVendorForView(response: HttpResponseBase): Observable<GetVendorForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetVendorForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetVendorForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getVendorForEdit(id: number | null | undefined): Observable<GetVendorForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Vendors/GetVendorForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVendorForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVendorForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetVendorForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetVendorForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetVendorForEdit(response: HttpResponseBase): Observable<GetVendorForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetVendorForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetVendorForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditVendorDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Vendors/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Vendors/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param referenceFilter (optional) 
     * @param nameFilter (optional) 
     * @param identifierFilter (optional) 
     * @param vendorLoc8GUIDFilter (optional) 
     * @param ssicCodeCodeFilter (optional) 
     * @param currencyCodeFilter (optional) 
     * @return Success
     */
    getVendorsToExcel(filter: string | null | undefined, referenceFilter: string | null | undefined, nameFilter: string | null | undefined, identifierFilter: string | null | undefined, vendorLoc8GUIDFilter: string | null | undefined, ssicCodeCodeFilter: string | null | undefined, currencyCodeFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Vendors/GetVendorsToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (referenceFilter !== undefined)
            url_ += "ReferenceFilter=" + encodeURIComponent("" + referenceFilter) + "&"; 
        if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&"; 
        if (identifierFilter !== undefined)
            url_ += "IdentifierFilter=" + encodeURIComponent("" + identifierFilter) + "&"; 
        if (vendorLoc8GUIDFilter !== undefined)
            url_ += "VendorLoc8GUIDFilter=" + encodeURIComponent("" + vendorLoc8GUIDFilter) + "&"; 
        if (ssicCodeCodeFilter !== undefined)
            url_ += "SsicCodeCodeFilter=" + encodeURIComponent("" + ssicCodeCodeFilter) + "&"; 
        if (currencyCodeFilter !== undefined)
            url_ += "CurrencyCodeFilter=" + encodeURIComponent("" + currencyCodeFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetVendorsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetVendorsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetVendorsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllSsicCodeForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfVendorSsicCodeLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Vendors/GetAllSsicCodeForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSsicCodeForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSsicCodeForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfVendorSsicCodeLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfVendorSsicCodeLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSsicCodeForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfVendorSsicCodeLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfVendorSsicCodeLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfVendorSsicCodeLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllCurrencyForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfVendorCurrencyLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/Vendors/GetAllCurrencyForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCurrencyForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCurrencyForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfVendorCurrencyLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfVendorCurrencyLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCurrencyForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfVendorCurrencyLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfVendorCurrencyLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfVendorCurrencyLookupTableDto>(<any>null);
    }
}

@Injectable()
export class WarehousesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param addressLine1Filter (optional) 
     * @param addressLine2Filter (optional) 
     * @param postalCodeFilter (optional) 
     * @param cityFilter (optional) 
     * @param stateFilter (optional) 
     * @param countryFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, nameFilter: string | null | undefined, addressLine1Filter: string | null | undefined, addressLine2Filter: string | null | undefined, postalCodeFilter: string | null | undefined, cityFilter: string | null | undefined, stateFilter: string | null | undefined, countryFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetWarehouseForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Warehouses/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&"; 
        if (addressLine1Filter !== undefined)
            url_ += "AddressLine1Filter=" + encodeURIComponent("" + addressLine1Filter) + "&"; 
        if (addressLine2Filter !== undefined)
            url_ += "AddressLine2Filter=" + encodeURIComponent("" + addressLine2Filter) + "&"; 
        if (postalCodeFilter !== undefined)
            url_ += "PostalCodeFilter=" + encodeURIComponent("" + postalCodeFilter) + "&"; 
        if (cityFilter !== undefined)
            url_ += "CityFilter=" + encodeURIComponent("" + cityFilter) + "&"; 
        if (stateFilter !== undefined)
            url_ += "StateFilter=" + encodeURIComponent("" + stateFilter) + "&"; 
        if (countryFilter !== undefined)
            url_ += "CountryFilter=" + encodeURIComponent("" + countryFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetWarehouseForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetWarehouseForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetWarehouseForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetWarehouseForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetWarehouseForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getWarehouseForView(id: number | null | undefined): Observable<GetWarehouseForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/Warehouses/GetWarehouseForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWarehouseForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWarehouseForView(<any>response_);
                } catch (e) {
                    return <Observable<GetWarehouseForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetWarehouseForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWarehouseForView(response: HttpResponseBase): Observable<GetWarehouseForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetWarehouseForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetWarehouseForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getWarehouseForEdit(id: number | null | undefined): Observable<GetWarehouseForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/Warehouses/GetWarehouseForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWarehouseForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWarehouseForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetWarehouseForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetWarehouseForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetWarehouseForEdit(response: HttpResponseBase): Observable<GetWarehouseForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetWarehouseForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetWarehouseForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditWarehouseDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Warehouses/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/Warehouses/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param nameFilter (optional) 
     * @param addressLine1Filter (optional) 
     * @param addressLine2Filter (optional) 
     * @param postalCodeFilter (optional) 
     * @param cityFilter (optional) 
     * @param stateFilter (optional) 
     * @param countryFilter (optional) 
     * @return Success
     */
    getWarehousesToExcel(filter: string | null | undefined, nameFilter: string | null | undefined, addressLine1Filter: string | null | undefined, addressLine2Filter: string | null | undefined, postalCodeFilter: string | null | undefined, cityFilter: string | null | undefined, stateFilter: string | null | undefined, countryFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/Warehouses/GetWarehousesToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (nameFilter !== undefined)
            url_ += "NameFilter=" + encodeURIComponent("" + nameFilter) + "&"; 
        if (addressLine1Filter !== undefined)
            url_ += "AddressLine1Filter=" + encodeURIComponent("" + addressLine1Filter) + "&"; 
        if (addressLine2Filter !== undefined)
            url_ += "AddressLine2Filter=" + encodeURIComponent("" + addressLine2Filter) + "&"; 
        if (postalCodeFilter !== undefined)
            url_ += "PostalCodeFilter=" + encodeURIComponent("" + postalCodeFilter) + "&"; 
        if (cityFilter !== undefined)
            url_ += "CityFilter=" + encodeURIComponent("" + cityFilter) + "&"; 
        if (stateFilter !== undefined)
            url_ += "StateFilter=" + encodeURIComponent("" + stateFilter) + "&"; 
        if (countryFilter !== undefined)
            url_ += "CountryFilter=" + encodeURIComponent("" + countryFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWarehousesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWarehousesToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWarehousesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class WebLogServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getLatestWebLogs(): Observable<GetLatestWebLogsOutput> {
        let url_ = this.baseUrl + "/api/services/app/WebLog/GetLatestWebLogs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLatestWebLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLatestWebLogs(<any>response_);
                } catch (e) {
                    return <Observable<GetLatestWebLogsOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetLatestWebLogsOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetLatestWebLogs(response: HttpResponseBase): Observable<GetLatestWebLogsOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetLatestWebLogsOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetLatestWebLogsOutput>(<any>null);
    }

    /**
     * @return Success
     */
    downloadWebLogs(): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/WebLog/DownloadWebLogs";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDownloadWebLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDownloadWebLogs(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processDownloadWebLogs(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class WorkOrderActionsServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param actionFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, actionFilter: string | null | undefined, descriptionFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetWorkOrderActionForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkOrderActions/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (actionFilter !== undefined)
            url_ += "ActionFilter=" + encodeURIComponent("" + actionFilter) + "&"; 
        if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetWorkOrderActionForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetWorkOrderActionForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetWorkOrderActionForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetWorkOrderActionForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetWorkOrderActionForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getWorkOrderActionForView(id: number | null | undefined): Observable<GetWorkOrderActionForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkOrderActions/GetWorkOrderActionForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWorkOrderActionForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWorkOrderActionForView(<any>response_);
                } catch (e) {
                    return <Observable<GetWorkOrderActionForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetWorkOrderActionForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWorkOrderActionForView(response: HttpResponseBase): Observable<GetWorkOrderActionForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetWorkOrderActionForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetWorkOrderActionForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getWorkOrderActionForEdit(id: number | null | undefined): Observable<GetWorkOrderActionForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/WorkOrderActions/GetWorkOrderActionForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWorkOrderActionForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWorkOrderActionForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetWorkOrderActionForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetWorkOrderActionForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetWorkOrderActionForEdit(response: HttpResponseBase): Observable<GetWorkOrderActionForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetWorkOrderActionForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetWorkOrderActionForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditWorkOrderActionDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WorkOrderActions/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WorkOrderActions/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param actionFilter (optional) 
     * @param descriptionFilter (optional) 
     * @return Success
     */
    getWorkOrderActionsToExcel(filter: string | null | undefined, actionFilter: string | null | undefined, descriptionFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkOrderActions/GetWorkOrderActionsToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (actionFilter !== undefined)
            url_ += "ActionFilter=" + encodeURIComponent("" + actionFilter) + "&"; 
        if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWorkOrderActionsToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWorkOrderActionsToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWorkOrderActionsToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class WorkOrderPrioritiesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetWorkOrderPriorityForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkOrderPriorities/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetWorkOrderPriorityForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetWorkOrderPriorityForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetWorkOrderPriorityForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetWorkOrderPriorityForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetWorkOrderPriorityForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getWorkOrderPriorityForView(id: number | null | undefined): Observable<GetWorkOrderPriorityForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkOrderPriorities/GetWorkOrderPriorityForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWorkOrderPriorityForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWorkOrderPriorityForView(<any>response_);
                } catch (e) {
                    return <Observable<GetWorkOrderPriorityForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetWorkOrderPriorityForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWorkOrderPriorityForView(response: HttpResponseBase): Observable<GetWorkOrderPriorityForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetWorkOrderPriorityForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetWorkOrderPriorityForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getWorkOrderPriorityForEdit(id: number | null | undefined): Observable<GetWorkOrderPriorityForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/WorkOrderPriorities/GetWorkOrderPriorityForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWorkOrderPriorityForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWorkOrderPriorityForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetWorkOrderPriorityForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetWorkOrderPriorityForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetWorkOrderPriorityForEdit(response: HttpResponseBase): Observable<GetWorkOrderPriorityForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetWorkOrderPriorityForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetWorkOrderPriorityForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditWorkOrderPriorityDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WorkOrderPriorities/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WorkOrderPriorities/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @return Success
     */
    getWorkOrderPrioritiesToExcel(filter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkOrderPriorities/GetWorkOrderPrioritiesToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWorkOrderPrioritiesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWorkOrderPrioritiesToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWorkOrderPrioritiesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class WorkOrdersServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param loc8GUIDFilter (optional) 
     * @param subjectFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param locationFilter (optional) 
     * @param maxStartDateFilter (optional) 
     * @param minStartDateFilter (optional) 
     * @param maxEndDateFilter (optional) 
     * @param minEndDateFilter (optional) 
     * @param remarksFilter (optional) 
     * @param workOrderPriorityPriorityFilter (optional) 
     * @param workOrderTypeTypeFilter (optional) 
     * @param vendorNameFilter (optional) 
     * @param incidentDescriptionFilter (optional) 
     * @param supportItemDescriptionFilter (optional) 
     * @param userNameFilter (optional) 
     * @param customerNameFilter (optional) 
     * @param assetOwnershipAssetFkFilter (optional) 
     * @param workOrderStatusStatusFilter (optional) 
     * @param isCompleted (optional) 
     * @param isPreventative (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, loc8GUIDFilter: string | null | undefined, subjectFilter: string | null | undefined, descriptionFilter: string | null | undefined, locationFilter: string | null | undefined, maxStartDateFilter: moment.Moment | null | undefined, minStartDateFilter: moment.Moment | null | undefined, maxEndDateFilter: moment.Moment | null | undefined, minEndDateFilter: moment.Moment | null | undefined, remarksFilter: string | null | undefined, workOrderPriorityPriorityFilter: string | null | undefined, workOrderTypeTypeFilter: string | null | undefined, vendorNameFilter: string | null | undefined, incidentDescriptionFilter: string | null | undefined, supportItemDescriptionFilter: string | null | undefined, userNameFilter: string | null | undefined, customerNameFilter: string | null | undefined, assetOwnershipAssetFkFilter: string | null | undefined, workOrderStatusStatusFilter: string | null | undefined, isCompleted: boolean | null | undefined, isPreventative: boolean | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetWorkOrderForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkOrders/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (loc8GUIDFilter !== undefined)
            url_ += "Loc8GUIDFilter=" + encodeURIComponent("" + loc8GUIDFilter) + "&"; 
        if (subjectFilter !== undefined)
            url_ += "SubjectFilter=" + encodeURIComponent("" + subjectFilter) + "&"; 
        if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (locationFilter !== undefined)
            url_ += "LocationFilter=" + encodeURIComponent("" + locationFilter) + "&"; 
        if (maxStartDateFilter !== undefined)
            url_ += "MaxStartDateFilter=" + encodeURIComponent(maxStartDateFilter ? "" + maxStartDateFilter.toJSON() : "") + "&"; 
        if (minStartDateFilter !== undefined)
            url_ += "MinStartDateFilter=" + encodeURIComponent(minStartDateFilter ? "" + minStartDateFilter.toJSON() : "") + "&"; 
        if (maxEndDateFilter !== undefined)
            url_ += "MaxEndDateFilter=" + encodeURIComponent(maxEndDateFilter ? "" + maxEndDateFilter.toJSON() : "") + "&"; 
        if (minEndDateFilter !== undefined)
            url_ += "MinEndDateFilter=" + encodeURIComponent(minEndDateFilter ? "" + minEndDateFilter.toJSON() : "") + "&"; 
        if (remarksFilter !== undefined)
            url_ += "RemarksFilter=" + encodeURIComponent("" + remarksFilter) + "&"; 
        if (workOrderPriorityPriorityFilter !== undefined)
            url_ += "WorkOrderPriorityPriorityFilter=" + encodeURIComponent("" + workOrderPriorityPriorityFilter) + "&"; 
        if (workOrderTypeTypeFilter !== undefined)
            url_ += "WorkOrderTypeTypeFilter=" + encodeURIComponent("" + workOrderTypeTypeFilter) + "&"; 
        if (vendorNameFilter !== undefined)
            url_ += "VendorNameFilter=" + encodeURIComponent("" + vendorNameFilter) + "&"; 
        if (incidentDescriptionFilter !== undefined)
            url_ += "IncidentDescriptionFilter=" + encodeURIComponent("" + incidentDescriptionFilter) + "&"; 
        if (supportItemDescriptionFilter !== undefined)
            url_ += "SupportItemDescriptionFilter=" + encodeURIComponent("" + supportItemDescriptionFilter) + "&"; 
        if (userNameFilter !== undefined)
            url_ += "UserNameFilter=" + encodeURIComponent("" + userNameFilter) + "&"; 
        if (customerNameFilter !== undefined)
            url_ += "CustomerNameFilter=" + encodeURIComponent("" + customerNameFilter) + "&"; 
        if (assetOwnershipAssetFkFilter !== undefined)
            url_ += "AssetOwnershipAssetFkFilter=" + encodeURIComponent("" + assetOwnershipAssetFkFilter) + "&"; 
        if (workOrderStatusStatusFilter !== undefined)
            url_ += "WorkOrderStatusStatusFilter=" + encodeURIComponent("" + workOrderStatusStatusFilter) + "&"; 
        if (isCompleted !== undefined)
            url_ += "IsCompleted=" + encodeURIComponent("" + isCompleted) + "&"; 
        if (isPreventative !== undefined)
            url_ += "IsPreventative=" + encodeURIComponent("" + isPreventative) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetWorkOrderForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetWorkOrderForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetWorkOrderForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetWorkOrderForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetWorkOrderForViewDto>(<any>null);
    }

    /**
     * @param days (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getWorkorderItems(days: number | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<GetWorkorderItemsForViewDto[]> {
        let url_ = this.baseUrl + "/api/services/app/WorkOrders/GetWorkorderItems?";
        if (days !== undefined)
            url_ += "Days=" + encodeURIComponent("" + days) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWorkorderItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWorkorderItems(<any>response_);
                } catch (e) {
                    return <Observable<GetWorkorderItemsForViewDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetWorkorderItemsForViewDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetWorkorderItems(response: HttpResponseBase): Observable<GetWorkorderItemsForViewDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetWorkorderItemsForViewDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetWorkorderItemsForViewDto[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getWorkOrderForView(id: number | null | undefined): Observable<GetWorkOrderForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkOrders/GetWorkOrderForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWorkOrderForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWorkOrderForView(<any>response_);
                } catch (e) {
                    return <Observable<GetWorkOrderForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetWorkOrderForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWorkOrderForView(response: HttpResponseBase): Observable<GetWorkOrderForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetWorkOrderForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetWorkOrderForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getWorkOrderForEdit(id: number | null | undefined): Observable<GetWorkOrderForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/WorkOrders/GetWorkOrderForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWorkOrderForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWorkOrderForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetWorkOrderForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetWorkOrderForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetWorkOrderForEdit(response: HttpResponseBase): Observable<GetWorkOrderForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetWorkOrderForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetWorkOrderForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditWorkOrderDto | null | undefined): Observable<number> {
        let url_ = this.baseUrl + "/api/services/app/WorkOrders/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<number>><any>_observableThrow(e);
                }
            } else
                return <Observable<number>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<number> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<number>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    setWorkOrderStatusComplete(input: CreateOrEditWorkOrderDto | null | undefined): Observable<ErrorViewModel> {
        let url_ = this.baseUrl + "/api/services/app/WorkOrders/SetWorkOrderStatusComplete";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetWorkOrderStatusComplete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetWorkOrderStatusComplete(<any>response_);
                } catch (e) {
                    return <Observable<ErrorViewModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ErrorViewModel>><any>_observableThrow(response_);
        }));
    }

    protected processSetWorkOrderStatusComplete(response: HttpResponseBase): Observable<ErrorViewModel> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ErrorViewModel.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ErrorViewModel>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WorkOrders/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param loc8GUIDFilter (optional) 
     * @param subjectFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param locationFilter (optional) 
     * @param maxStartDateFilter (optional) 
     * @param minStartDateFilter (optional) 
     * @param maxEndDateFilter (optional) 
     * @param minEndDateFilter (optional) 
     * @param remarksFilter (optional) 
     * @param workOrderPriorityPriorityFilter (optional) 
     * @param workOrderTypeTypeFilter (optional) 
     * @param vendorNameFilter (optional) 
     * @param incidentDescriptionFilter (optional) 
     * @param supportItemDescriptionFilter (optional) 
     * @param userNameFilter (optional) 
     * @param customerNameFilter (optional) 
     * @param assetOwnershipAssetFkFilter (optional) 
     * @param workOrderStatusStatusFilter (optional) 
     * @param isCompleted (optional) 
     * @param isPreventative (optional) 
     * @return Success
     */
    getWorkOrdersToExcel(filter: string | null | undefined, loc8GUIDFilter: string | null | undefined, subjectFilter: string | null | undefined, descriptionFilter: string | null | undefined, locationFilter: string | null | undefined, maxStartDateFilter: moment.Moment | null | undefined, minStartDateFilter: moment.Moment | null | undefined, maxEndDateFilter: moment.Moment | null | undefined, minEndDateFilter: moment.Moment | null | undefined, remarksFilter: string | null | undefined, workOrderPriorityPriorityFilter: string | null | undefined, workOrderTypeTypeFilter: string | null | undefined, vendorNameFilter: string | null | undefined, incidentDescriptionFilter: string | null | undefined, supportItemDescriptionFilter: string | null | undefined, userNameFilter: string | null | undefined, customerNameFilter: string | null | undefined, assetOwnershipAssetFkFilter: string | null | undefined, workOrderStatusStatusFilter: string | null | undefined, isCompleted: boolean | null | undefined, isPreventative: boolean | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkOrders/GetWorkOrdersToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (loc8GUIDFilter !== undefined)
            url_ += "Loc8GUIDFilter=" + encodeURIComponent("" + loc8GUIDFilter) + "&"; 
        if (subjectFilter !== undefined)
            url_ += "SubjectFilter=" + encodeURIComponent("" + subjectFilter) + "&"; 
        if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (locationFilter !== undefined)
            url_ += "LocationFilter=" + encodeURIComponent("" + locationFilter) + "&"; 
        if (maxStartDateFilter !== undefined)
            url_ += "MaxStartDateFilter=" + encodeURIComponent(maxStartDateFilter ? "" + maxStartDateFilter.toJSON() : "") + "&"; 
        if (minStartDateFilter !== undefined)
            url_ += "MinStartDateFilter=" + encodeURIComponent(minStartDateFilter ? "" + minStartDateFilter.toJSON() : "") + "&"; 
        if (maxEndDateFilter !== undefined)
            url_ += "MaxEndDateFilter=" + encodeURIComponent(maxEndDateFilter ? "" + maxEndDateFilter.toJSON() : "") + "&"; 
        if (minEndDateFilter !== undefined)
            url_ += "MinEndDateFilter=" + encodeURIComponent(minEndDateFilter ? "" + minEndDateFilter.toJSON() : "") + "&"; 
        if (remarksFilter !== undefined)
            url_ += "RemarksFilter=" + encodeURIComponent("" + remarksFilter) + "&"; 
        if (workOrderPriorityPriorityFilter !== undefined)
            url_ += "WorkOrderPriorityPriorityFilter=" + encodeURIComponent("" + workOrderPriorityPriorityFilter) + "&"; 
        if (workOrderTypeTypeFilter !== undefined)
            url_ += "WorkOrderTypeTypeFilter=" + encodeURIComponent("" + workOrderTypeTypeFilter) + "&"; 
        if (vendorNameFilter !== undefined)
            url_ += "VendorNameFilter=" + encodeURIComponent("" + vendorNameFilter) + "&"; 
        if (incidentDescriptionFilter !== undefined)
            url_ += "IncidentDescriptionFilter=" + encodeURIComponent("" + incidentDescriptionFilter) + "&"; 
        if (supportItemDescriptionFilter !== undefined)
            url_ += "SupportItemDescriptionFilter=" + encodeURIComponent("" + supportItemDescriptionFilter) + "&"; 
        if (userNameFilter !== undefined)
            url_ += "UserNameFilter=" + encodeURIComponent("" + userNameFilter) + "&"; 
        if (customerNameFilter !== undefined)
            url_ += "CustomerNameFilter=" + encodeURIComponent("" + customerNameFilter) + "&"; 
        if (assetOwnershipAssetFkFilter !== undefined)
            url_ += "AssetOwnershipAssetFkFilter=" + encodeURIComponent("" + assetOwnershipAssetFkFilter) + "&"; 
        if (workOrderStatusStatusFilter !== undefined)
            url_ += "WorkOrderStatusStatusFilter=" + encodeURIComponent("" + workOrderStatusStatusFilter) + "&"; 
        if (isCompleted !== undefined)
            url_ += "IsCompleted=" + encodeURIComponent("" + isCompleted) + "&"; 
        if (isPreventative !== undefined)
            url_ += "IsPreventative=" + encodeURIComponent("" + isPreventative) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWorkOrdersToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWorkOrdersToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWorkOrdersToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllWorkOrderPriorityForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfWorkOrderWorkOrderPriorityLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkOrders/GetAllWorkOrderPriorityForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWorkOrderPriorityForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWorkOrderPriorityForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfWorkOrderWorkOrderPriorityLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfWorkOrderWorkOrderPriorityLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllWorkOrderPriorityForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfWorkOrderWorkOrderPriorityLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfWorkOrderWorkOrderPriorityLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfWorkOrderWorkOrderPriorityLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllWorkOrderTypeForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfWorkOrderWorkOrderTypeLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkOrders/GetAllWorkOrderTypeForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWorkOrderTypeForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWorkOrderTypeForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfWorkOrderWorkOrderTypeLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfWorkOrderWorkOrderTypeLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllWorkOrderTypeForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfWorkOrderWorkOrderTypeLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfWorkOrderWorkOrderTypeLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfWorkOrderWorkOrderTypeLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param filterId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllVendorForLookupTable(filter: string | null | undefined, filterId: number | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfWorkOrderVendorLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkOrders/GetAllVendorForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (filterId !== undefined)
            url_ += "FilterId=" + encodeURIComponent("" + filterId) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllVendorForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllVendorForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfWorkOrderVendorLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfWorkOrderVendorLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllVendorForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfWorkOrderVendorLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfWorkOrderVendorLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfWorkOrderVendorLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllIncidentForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfWorkOrderIncidentLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkOrders/GetAllIncidentForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllIncidentForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllIncidentForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfWorkOrderIncidentLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfWorkOrderIncidentLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllIncidentForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfWorkOrderIncidentLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfWorkOrderIncidentLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfWorkOrderIncidentLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param filterId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllSupportItemForLookupTable(filter: string | null | undefined, filterId: number | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfWorkOrderSupportItemLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkOrders/GetAllSupportItemForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (filterId !== undefined)
            url_ += "FilterId=" + encodeURIComponent("" + filterId) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSupportItemForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSupportItemForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfWorkOrderSupportItemLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfWorkOrderSupportItemLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSupportItemForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfWorkOrderSupportItemLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfWorkOrderSupportItemLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfWorkOrderSupportItemLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllUserForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfWorkOrderUserLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkOrders/GetAllUserForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllUserForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUserForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfWorkOrderUserLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfWorkOrderUserLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllUserForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfWorkOrderUserLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfWorkOrderUserLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfWorkOrderUserLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param filterId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllCustomerForLookupTable(filter: string | null | undefined, filterId: number | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfWorkOrderCustomerLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkOrders/GetAllCustomerForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (filterId !== undefined)
            url_ += "FilterId=" + encodeURIComponent("" + filterId) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCustomerForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCustomerForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfWorkOrderCustomerLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfWorkOrderCustomerLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCustomerForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfWorkOrderCustomerLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfWorkOrderCustomerLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfWorkOrderCustomerLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param filterId (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllAssetOwnershipForLookupTable(filter: string | null | undefined, filterId: number | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfWorkOrderAssetOwnershipLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkOrders/GetAllAssetOwnershipForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (filterId !== undefined)
            url_ += "FilterId=" + encodeURIComponent("" + filterId) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAssetOwnershipForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAssetOwnershipForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfWorkOrderAssetOwnershipLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfWorkOrderAssetOwnershipLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAssetOwnershipForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfWorkOrderAssetOwnershipLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfWorkOrderAssetOwnershipLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfWorkOrderAssetOwnershipLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllWorkOrderStatusForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfWorkOrderWorkOrderStatusLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkOrders/GetAllWorkOrderStatusForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWorkOrderStatusForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWorkOrderStatusForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfWorkOrderWorkOrderStatusLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfWorkOrderWorkOrderStatusLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllWorkOrderStatusForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfWorkOrderWorkOrderStatusLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfWorkOrderWorkOrderStatusLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfWorkOrderWorkOrderStatusLookupTableDto>(<any>null);
    }

    /**
     * @param incidentId (optional) 
     * @param assetOwnerShipId (optional) 
     * @return Success
     */
    getAssetFkList(incidentId: number | null | undefined, assetOwnerShipId: number | null | undefined): Observable<WorkOrderAssetFkListDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkOrders/GetAssetFkList?";
        if (incidentId !== undefined)
            url_ += "incidentId=" + encodeURIComponent("" + incidentId) + "&"; 
        if (assetOwnerShipId !== undefined)
            url_ += "assetOwnerShipId=" + encodeURIComponent("" + assetOwnerShipId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAssetFkList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAssetFkList(<any>response_);
                } catch (e) {
                    return <Observable<WorkOrderAssetFkListDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WorkOrderAssetFkListDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAssetFkList(response: HttpResponseBase): Observable<WorkOrderAssetFkListDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkOrderAssetFkListDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkOrderAssetFkListDto>(<any>null);
    }

    /**
     * @param workOrderTypeId (optional) 
     * @return Success
     */
    getWorkOrderPriorityByType(workOrderTypeId: number | null | undefined): Observable<WorkOrderWorkOrderPriorityLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkOrders/GetWorkOrderPriorityByType?";
        if (workOrderTypeId !== undefined)
            url_ += "workOrderTypeId=" + encodeURIComponent("" + workOrderTypeId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWorkOrderPriorityByType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWorkOrderPriorityByType(<any>response_);
                } catch (e) {
                    return <Observable<WorkOrderWorkOrderPriorityLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WorkOrderWorkOrderPriorityLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWorkOrderPriorityByType(response: HttpResponseBase): Observable<WorkOrderWorkOrderPriorityLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkOrderWorkOrderPriorityLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkOrderWorkOrderPriorityLookupTableDto>(<any>null);
    }

    /**
     * @return Success
     */
    getDefaultCreator(): Observable<WorkOrderUserLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkOrders/GetDefaultCreator";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDefaultCreator(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDefaultCreator(<any>response_);
                } catch (e) {
                    return <Observable<WorkOrderUserLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<WorkOrderUserLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetDefaultCreator(response: HttpResponseBase): Observable<WorkOrderUserLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = WorkOrderUserLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WorkOrderUserLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllLocationForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfLocationLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkOrders/GetAllLocationForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllLocationForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllLocationForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfLocationLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfLocationLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllLocationForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfLocationLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfLocationLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfLocationLookupTableDto>(<any>null);
    }
}

@Injectable()
export class WorkOrderStatusesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param statusFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, statusFilter: string | null | undefined, descriptionFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetWorkOrderStatusForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkOrderStatuses/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (statusFilter !== undefined)
            url_ += "StatusFilter=" + encodeURIComponent("" + statusFilter) + "&"; 
        if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetWorkOrderStatusForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetWorkOrderStatusForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetWorkOrderStatusForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetWorkOrderStatusForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetWorkOrderStatusForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getWorkOrderStatusForView(id: number | null | undefined): Observable<GetWorkOrderStatusForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkOrderStatuses/GetWorkOrderStatusForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWorkOrderStatusForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWorkOrderStatusForView(<any>response_);
                } catch (e) {
                    return <Observable<GetWorkOrderStatusForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetWorkOrderStatusForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWorkOrderStatusForView(response: HttpResponseBase): Observable<GetWorkOrderStatusForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetWorkOrderStatusForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetWorkOrderStatusForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getWorkOrderStatusForEdit(id: number | null | undefined): Observable<GetWorkOrderStatusForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/WorkOrderStatuses/GetWorkOrderStatusForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWorkOrderStatusForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWorkOrderStatusForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetWorkOrderStatusForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetWorkOrderStatusForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetWorkOrderStatusForEdit(response: HttpResponseBase): Observable<GetWorkOrderStatusForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetWorkOrderStatusForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetWorkOrderStatusForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditWorkOrderStatusDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WorkOrderStatuses/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WorkOrderStatuses/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param statusFilter (optional) 
     * @param descriptionFilter (optional) 
     * @return Success
     */
    getWorkOrderStatusesToExcel(filter: string | null | undefined, statusFilter: string | null | undefined, descriptionFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkOrderStatuses/GetWorkOrderStatusesToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (statusFilter !== undefined)
            url_ += "StatusFilter=" + encodeURIComponent("" + statusFilter) + "&"; 
        if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWorkOrderStatusesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWorkOrderStatusesToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWorkOrderStatusesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }
}

@Injectable()
export class WorkOrderTypesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param typeFilter (optional) 
     * @param descriptionFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, typeFilter: string | null | undefined, descriptionFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetWorkOrderTypeForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkOrderTypes/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (typeFilter !== undefined)
            url_ += "TypeFilter=" + encodeURIComponent("" + typeFilter) + "&"; 
        if (descriptionFilter !== undefined)
            url_ += "DescriptionFilter=" + encodeURIComponent("" + descriptionFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetWorkOrderTypeForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetWorkOrderTypeForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetWorkOrderTypeForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetWorkOrderTypeForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetWorkOrderTypeForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getWorkOrderTypeForView(id: number | null | undefined): Observable<GetWorkOrderTypeForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkOrderTypes/GetWorkOrderTypeForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWorkOrderTypeForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWorkOrderTypeForView(<any>response_);
                } catch (e) {
                    return <Observable<GetWorkOrderTypeForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetWorkOrderTypeForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWorkOrderTypeForView(response: HttpResponseBase): Observable<GetWorkOrderTypeForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetWorkOrderTypeForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetWorkOrderTypeForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getWorkOrderTypeForEdit(id: number | null | undefined): Observable<GetWorkOrderTypeForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/WorkOrderTypes/GetWorkOrderTypeForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWorkOrderTypeForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWorkOrderTypeForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetWorkOrderTypeForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetWorkOrderTypeForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetWorkOrderTypeForEdit(response: HttpResponseBase): Observable<GetWorkOrderTypeForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetWorkOrderTypeForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetWorkOrderTypeForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditWorkOrderTypeDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WorkOrderTypes/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WorkOrderTypes/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class WorkOrderUpdatesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param workOrderId (optional) 
     * @param filter (optional) 
     * @param workOrderSubjectFilter (optional) 
     * @param itemTypeTypeFilter (optional) 
     * @param workOrderActionActionFilter (optional) 
     * @param assetPartNameFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(workOrderId: number | null | undefined, filter: string | null | undefined, workOrderSubjectFilter: string | null | undefined, itemTypeTypeFilter: string | null | undefined, workOrderActionActionFilter: string | null | undefined, assetPartNameFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetWorkOrderUpdateForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkOrderUpdates/GetAll?";
        if (workOrderId !== undefined)
            url_ += "WorkOrderId=" + encodeURIComponent("" + workOrderId) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (workOrderSubjectFilter !== undefined)
            url_ += "WorkOrderSubjectFilter=" + encodeURIComponent("" + workOrderSubjectFilter) + "&"; 
        if (itemTypeTypeFilter !== undefined)
            url_ += "ItemTypeTypeFilter=" + encodeURIComponent("" + itemTypeTypeFilter) + "&"; 
        if (workOrderActionActionFilter !== undefined)
            url_ += "WorkOrderActionActionFilter=" + encodeURIComponent("" + workOrderActionActionFilter) + "&"; 
        if (assetPartNameFilter !== undefined)
            url_ += "AssetPartNameFilter=" + encodeURIComponent("" + assetPartNameFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetWorkOrderUpdateForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetWorkOrderUpdateForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetWorkOrderUpdateForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetWorkOrderUpdateForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetWorkOrderUpdateForViewDto>(<any>null);
    }

    /**
     * @param days (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getWorkorderItems(days: number | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<GetWorkorderUpdateItemsForViewDto[]> {
        let url_ = this.baseUrl + "/api/services/app/WorkOrderUpdates/GetWorkorderItems?";
        if (days !== undefined)
            url_ += "Days=" + encodeURIComponent("" + days) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWorkorderItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWorkorderItems(<any>response_);
                } catch (e) {
                    return <Observable<GetWorkorderUpdateItemsForViewDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetWorkorderUpdateItemsForViewDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetWorkorderItems(response: HttpResponseBase): Observable<GetWorkorderUpdateItemsForViewDto[]> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(GetWorkorderUpdateItemsForViewDto.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetWorkorderUpdateItemsForViewDto[]>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getWorkOrderUpdateForView(id: number | null | undefined): Observable<GetWorkOrderUpdateForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkOrderUpdates/GetWorkOrderUpdateForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWorkOrderUpdateForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWorkOrderUpdateForView(<any>response_);
                } catch (e) {
                    return <Observable<GetWorkOrderUpdateForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetWorkOrderUpdateForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWorkOrderUpdateForView(response: HttpResponseBase): Observable<GetWorkOrderUpdateForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetWorkOrderUpdateForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetWorkOrderUpdateForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getWorkOrderUpdateForEdit(id: number | null | undefined): Observable<GetWorkOrderUpdateForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/WorkOrderUpdates/GetWorkOrderUpdateForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWorkOrderUpdateForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWorkOrderUpdateForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetWorkOrderUpdateForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetWorkOrderUpdateForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetWorkOrderUpdateForEdit(response: HttpResponseBase): Observable<GetWorkOrderUpdateForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetWorkOrderUpdateForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetWorkOrderUpdateForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditWorkOrderUpdateDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WorkOrderUpdates/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WorkOrderUpdates/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param commentsFilter (optional) 
     * @param maxNumberFilter (optional) 
     * @param minNumberFilter (optional) 
     * @param workOrderSubjectFilter (optional) 
     * @param itemTypeTypeFilter (optional) 
     * @param workOrderActionActionFilter (optional) 
     * @param assetPartNameFilter (optional) 
     * @return Success
     */
    getWorkOrderUpdatesToExcel(filter: string | null | undefined, commentsFilter: string | null | undefined, maxNumberFilter: number | null | undefined, minNumberFilter: number | null | undefined, workOrderSubjectFilter: string | null | undefined, itemTypeTypeFilter: string | null | undefined, workOrderActionActionFilter: string | null | undefined, assetPartNameFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkOrderUpdates/GetWorkOrderUpdatesToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (commentsFilter !== undefined)
            url_ += "CommentsFilter=" + encodeURIComponent("" + commentsFilter) + "&"; 
        if (maxNumberFilter !== undefined)
            url_ += "MaxNumberFilter=" + encodeURIComponent("" + maxNumberFilter) + "&"; 
        if (minNumberFilter !== undefined)
            url_ += "MinNumberFilter=" + encodeURIComponent("" + minNumberFilter) + "&"; 
        if (workOrderSubjectFilter !== undefined)
            url_ += "WorkOrderSubjectFilter=" + encodeURIComponent("" + workOrderSubjectFilter) + "&"; 
        if (itemTypeTypeFilter !== undefined)
            url_ += "ItemTypeTypeFilter=" + encodeURIComponent("" + itemTypeTypeFilter) + "&"; 
        if (workOrderActionActionFilter !== undefined)
            url_ += "WorkOrderActionActionFilter=" + encodeURIComponent("" + workOrderActionActionFilter) + "&"; 
        if (assetPartNameFilter !== undefined)
            url_ += "AssetPartNameFilter=" + encodeURIComponent("" + assetPartNameFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetWorkOrderUpdatesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetWorkOrderUpdatesToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetWorkOrderUpdatesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    completeWorkOrderUpdate(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/WorkOrderUpdates/CompleteWorkOrderUpdate?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCompleteWorkOrderUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCompleteWorkOrderUpdate(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCompleteWorkOrderUpdate(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param warehouseId (optional) 
     * @param assetId (optional) 
     * @param forImportFromWarehouses (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllAssetPartForLookupTable(filter: string | null | undefined, warehouseId: number | null | undefined, assetId: number | null | undefined, forImportFromWarehouses: boolean | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfWorkOrderUpdateAssetPartLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkOrderUpdates/GetAllAssetPartForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (warehouseId !== undefined)
            url_ += "WarehouseId=" + encodeURIComponent("" + warehouseId) + "&"; 
        if (assetId !== undefined)
            url_ += "AssetId=" + encodeURIComponent("" + assetId) + "&"; 
        if (forImportFromWarehouses !== undefined)
            url_ += "ForImportFromWarehouses=" + encodeURIComponent("" + forImportFromWarehouses) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAssetPartForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAssetPartForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfWorkOrderUpdateAssetPartLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfWorkOrderUpdateAssetPartLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllAssetPartForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfWorkOrderUpdateAssetPartLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfWorkOrderUpdateAssetPartLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfWorkOrderUpdateAssetPartLookupTableDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllWorkOrderActionForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfWorkOrderUpdateWorkOrderActionLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/WorkOrderUpdates/GetAllWorkOrderActionForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllWorkOrderActionForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllWorkOrderActionForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfWorkOrderUpdateWorkOrderActionLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfWorkOrderUpdateWorkOrderActionLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllWorkOrderActionForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfWorkOrderUpdateWorkOrderActionLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfWorkOrderUpdateWorkOrderActionLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfWorkOrderUpdateWorkOrderActionLookupTableDto>(<any>null);
    }
}

@Injectable()
export class XeroInvoicesServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @param filter (optional) 
     * @param xeroInvoiceCreatedFilter (optional) 
     * @param apiResponseFilter (optional) 
     * @param failedFilter (optional) 
     * @param exceptionFilter (optional) 
     * @param xeroReferenceFilter (optional) 
     * @param customerInvoiceCustomerReferenceFilter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAll(filter: string | null | undefined, xeroInvoiceCreatedFilter: number | null | undefined, apiResponseFilter: string | null | undefined, failedFilter: number | null | undefined, exceptionFilter: string | null | undefined, xeroReferenceFilter: string | null | undefined, customerInvoiceCustomerReferenceFilter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfGetXeroInvoiceForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/XeroInvoices/GetAll?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (xeroInvoiceCreatedFilter !== undefined)
            url_ += "XeroInvoiceCreatedFilter=" + encodeURIComponent("" + xeroInvoiceCreatedFilter) + "&"; 
        if (apiResponseFilter !== undefined)
            url_ += "ApiResponseFilter=" + encodeURIComponent("" + apiResponseFilter) + "&"; 
        if (failedFilter !== undefined)
            url_ += "FailedFilter=" + encodeURIComponent("" + failedFilter) + "&"; 
        if (exceptionFilter !== undefined)
            url_ += "ExceptionFilter=" + encodeURIComponent("" + exceptionFilter) + "&"; 
        if (xeroReferenceFilter !== undefined)
            url_ += "XeroReferenceFilter=" + encodeURIComponent("" + xeroReferenceFilter) + "&"; 
        if (customerInvoiceCustomerReferenceFilter !== undefined)
            url_ += "CustomerInvoiceCustomerReferenceFilter=" + encodeURIComponent("" + customerInvoiceCustomerReferenceFilter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfGetXeroInvoiceForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfGetXeroInvoiceForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<PagedResultDtoOfGetXeroInvoiceForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfGetXeroInvoiceForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfGetXeroInvoiceForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getXeroInvoiceForView(id: number | null | undefined): Observable<GetXeroInvoiceForViewDto> {
        let url_ = this.baseUrl + "/api/services/app/XeroInvoices/GetXeroInvoiceForView?";
        if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetXeroInvoiceForView(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetXeroInvoiceForView(<any>response_);
                } catch (e) {
                    return <Observable<GetXeroInvoiceForViewDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetXeroInvoiceForViewDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetXeroInvoiceForView(response: HttpResponseBase): Observable<GetXeroInvoiceForViewDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetXeroInvoiceForViewDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetXeroInvoiceForViewDto>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getXeroInvoiceForEdit(id: number | null | undefined): Observable<GetXeroInvoiceForEditOutput> {
        let url_ = this.baseUrl + "/api/services/app/XeroInvoices/GetXeroInvoiceForEdit?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetXeroInvoiceForEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetXeroInvoiceForEdit(<any>response_);
                } catch (e) {
                    return <Observable<GetXeroInvoiceForEditOutput>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetXeroInvoiceForEditOutput>><any>_observableThrow(response_);
        }));
    }

    protected processGetXeroInvoiceForEdit(response: HttpResponseBase): Observable<GetXeroInvoiceForEditOutput> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetXeroInvoiceForEditOutput.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetXeroInvoiceForEditOutput>(<any>null);
    }

    /**
     * @param input (optional) 
     * @return Success
     */
    createOrEdit(input: CreateOrEditXeroInvoiceDto | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/XeroInvoices/CreateOrEdit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(input);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOrEdit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOrEdit(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOrEdit(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    delete(id: number | null | undefined): Observable<void> {
        let url_ = this.baseUrl + "/api/services/app/XeroInvoices/Delete?";
        if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param xeroInvoiceCreatedFilter (optional) 
     * @param apiResponseFilter (optional) 
     * @param failedFilter (optional) 
     * @param exceptionFilter (optional) 
     * @param xeroReferenceFilter (optional) 
     * @param customerInvoiceCustomerReferenceFilter (optional) 
     * @return Success
     */
    getXeroInvoicesToExcel(filter: string | null | undefined, xeroInvoiceCreatedFilter: number | null | undefined, apiResponseFilter: string | null | undefined, failedFilter: number | null | undefined, exceptionFilter: string | null | undefined, xeroReferenceFilter: string | null | undefined, customerInvoiceCustomerReferenceFilter: string | null | undefined): Observable<FileDto> {
        let url_ = this.baseUrl + "/api/services/app/XeroInvoices/GetXeroInvoicesToExcel?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (xeroInvoiceCreatedFilter !== undefined)
            url_ += "XeroInvoiceCreatedFilter=" + encodeURIComponent("" + xeroInvoiceCreatedFilter) + "&"; 
        if (apiResponseFilter !== undefined)
            url_ += "ApiResponseFilter=" + encodeURIComponent("" + apiResponseFilter) + "&"; 
        if (failedFilter !== undefined)
            url_ += "FailedFilter=" + encodeURIComponent("" + failedFilter) + "&"; 
        if (exceptionFilter !== undefined)
            url_ += "ExceptionFilter=" + encodeURIComponent("" + exceptionFilter) + "&"; 
        if (xeroReferenceFilter !== undefined)
            url_ += "XeroReferenceFilter=" + encodeURIComponent("" + xeroReferenceFilter) + "&"; 
        if (customerInvoiceCustomerReferenceFilter !== undefined)
            url_ += "CustomerInvoiceCustomerReferenceFilter=" + encodeURIComponent("" + customerInvoiceCustomerReferenceFilter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetXeroInvoicesToExcel(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetXeroInvoicesToExcel(<any>response_);
                } catch (e) {
                    return <Observable<FileDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetXeroInvoicesToExcel(response: HttpResponseBase): Observable<FileDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileDto>(<any>null);
    }

    /**
     * @param filter (optional) 
     * @param sorting (optional) 
     * @param skipCount (optional) 
     * @param maxResultCount (optional) 
     * @return Success
     */
    getAllCustomerInvoiceForLookupTable(filter: string | null | undefined, sorting: string | null | undefined, skipCount: number | null | undefined, maxResultCount: number | null | undefined): Observable<PagedResultDtoOfXeroInvoiceCustomerInvoiceLookupTableDto> {
        let url_ = this.baseUrl + "/api/services/app/XeroInvoices/GetAllCustomerInvoiceForLookupTable?";
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (sorting !== undefined)
            url_ += "Sorting=" + encodeURIComponent("" + sorting) + "&"; 
        if (skipCount !== undefined)
            url_ += "SkipCount=" + encodeURIComponent("" + skipCount) + "&"; 
        if (maxResultCount !== undefined)
            url_ += "MaxResultCount=" + encodeURIComponent("" + maxResultCount) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCustomerInvoiceForLookupTable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCustomerInvoiceForLookupTable(<any>response_);
                } catch (e) {
                    return <Observable<PagedResultDtoOfXeroInvoiceCustomerInvoiceLookupTableDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedResultDtoOfXeroInvoiceCustomerInvoiceLookupTableDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCustomerInvoiceForLookupTable(response: HttpResponseBase): Observable<PagedResultDtoOfXeroInvoiceCustomerInvoiceLookupTableDto> {
        const status = response.status;
        const responseBlob = 
            response instanceof HttpResponse ? response.body : 
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedResultDtoOfXeroInvoiceCustomerInvoiceLookupTableDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedResultDtoOfXeroInvoiceCustomerInvoiceLookupTableDto>(<any>null);
    }
}

export class IsTenantAvailableInput implements IIsTenantAvailableInput {
    tenancyName!: string;

    constructor(data?: IIsTenantAvailableInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
        }
    }

    static fromJS(data: any): IsTenantAvailableInput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        return data; 
    }
}

export interface IIsTenantAvailableInput {
    tenancyName: string;
}

export class IsTenantAvailableOutput implements IIsTenantAvailableOutput {
    state!: TenantAvailabilityState | undefined;
    tenantId!: number | undefined;
    serverRootAddress!: string | undefined;

    constructor(data?: IIsTenantAvailableOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.state = data["state"];
            this.tenantId = data["tenantId"];
            this.serverRootAddress = data["serverRootAddress"];
        }
    }

    static fromJS(data: any): IsTenantAvailableOutput {
        data = typeof data === 'object' ? data : {};
        let result = new IsTenantAvailableOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["state"] = this.state;
        data["tenantId"] = this.tenantId;
        data["serverRootAddress"] = this.serverRootAddress;
        return data; 
    }
}

export interface IIsTenantAvailableOutput {
    state: TenantAvailabilityState | undefined;
    tenantId: number | undefined;
    serverRootAddress: string | undefined;
}

export enum TenantAvailabilityState {
    Available = 1,
    InActive = 2,
    NotFound = 3,
}

export class ResolveTenantIdInput implements IResolveTenantIdInput {
    c!: string | undefined;

    constructor(data?: IResolveTenantIdInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.c = data["c"];
        }
    }

    static fromJS(data: any): ResolveTenantIdInput {
        data = typeof data === 'object' ? data : {};
        let result = new ResolveTenantIdInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["c"] = this.c;
        return data; 
    }
}

export interface IResolveTenantIdInput {
    c: string | undefined;
}

export class RegisterInput implements IRegisterInput {
    name!: string;
    surname!: string;
    userName!: string;
    emailAddress!: string;
    password!: string;
    captchaResponse!: string | undefined;

    constructor(data?: IRegisterInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.password = data["password"];
            this.captchaResponse = data["captchaResponse"];
        }
    }

    static fromJS(data: any): RegisterInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["password"] = this.password;
        data["captchaResponse"] = this.captchaResponse;
        return data; 
    }
}

export interface IRegisterInput {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    password: string;
    captchaResponse: string | undefined;
}

export class RegisterOutput implements IRegisterOutput {
    canLogin!: boolean | undefined;

    constructor(data?: IRegisterOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.canLogin = data["canLogin"];
        }
    }

    static fromJS(data: any): RegisterOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        return data; 
    }
}

export interface IRegisterOutput {
    canLogin: boolean | undefined;
}

export class SendPasswordResetCodeInput implements ISendPasswordResetCodeInput {
    emailAddress!: string;

    constructor(data?: ISendPasswordResetCodeInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.emailAddress = data["emailAddress"];
        }
    }

    static fromJS(data: any): SendPasswordResetCodeInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendPasswordResetCodeInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        return data; 
    }
}

export interface ISendPasswordResetCodeInput {
    emailAddress: string;
}

export class ResetPasswordInput implements IResetPasswordInput {
    userId!: number | undefined;
    resetCode!: string | undefined;
    password!: string | undefined;
    returnUrl!: string | undefined;
    singleSignIn!: string | undefined;
    c!: string | undefined;

    constructor(data?: IResetPasswordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.resetCode = data["resetCode"];
            this.password = data["password"];
            this.returnUrl = data["returnUrl"];
            this.singleSignIn = data["singleSignIn"];
            this.c = data["c"];
        }
    }

    static fromJS(data: any): ResetPasswordInput {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["resetCode"] = this.resetCode;
        data["password"] = this.password;
        data["returnUrl"] = this.returnUrl;
        data["singleSignIn"] = this.singleSignIn;
        data["c"] = this.c;
        return data; 
    }
}

export interface IResetPasswordInput {
    userId: number | undefined;
    resetCode: string | undefined;
    password: string | undefined;
    returnUrl: string | undefined;
    singleSignIn: string | undefined;
    c: string | undefined;
}

export class ResetPasswordOutput implements IResetPasswordOutput {
    canLogin!: boolean | undefined;
    userName!: string | undefined;

    constructor(data?: IResetPasswordOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.canLogin = data["canLogin"];
            this.userName = data["userName"];
        }
    }

    static fromJS(data: any): ResetPasswordOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["canLogin"] = this.canLogin;
        data["userName"] = this.userName;
        return data; 
    }
}

export interface IResetPasswordOutput {
    canLogin: boolean | undefined;
    userName: string | undefined;
}

export class SendEmailActivationLinkInput implements ISendEmailActivationLinkInput {
    emailAddress!: string;

    constructor(data?: ISendEmailActivationLinkInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.emailAddress = data["emailAddress"];
        }
    }

    static fromJS(data: any): SendEmailActivationLinkInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendEmailActivationLinkInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        return data; 
    }
}

export interface ISendEmailActivationLinkInput {
    emailAddress: string;
}

export class ActivateEmailInput implements IActivateEmailInput {
    userId!: number | undefined;
    confirmationCode!: string | undefined;
    c!: string | undefined;

    constructor(data?: IActivateEmailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.confirmationCode = data["confirmationCode"];
            this.c = data["c"];
        }
    }

    static fromJS(data: any): ActivateEmailInput {
        data = typeof data === 'object' ? data : {};
        let result = new ActivateEmailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["confirmationCode"] = this.confirmationCode;
        data["c"] = this.c;
        return data; 
    }
}

export interface IActivateEmailInput {
    userId: number | undefined;
    confirmationCode: string | undefined;
    c: string | undefined;
}

export class ImpersonateInput implements IImpersonateInput {
    tenantId!: number | undefined;
    userId!: number | undefined;

    constructor(data?: IImpersonateInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): ImpersonateInput {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonateInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data; 
    }
}

export interface IImpersonateInput {
    tenantId: number | undefined;
    userId: number | undefined;
}

export class ImpersonateOutput implements IImpersonateOutput {
    impersonationToken!: string | undefined;
    tenancyName!: string | undefined;

    constructor(data?: IImpersonateOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.impersonationToken = data["impersonationToken"];
            this.tenancyName = data["tenancyName"];
        }
    }

    static fromJS(data: any): ImpersonateOutput {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonateOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["impersonationToken"] = this.impersonationToken;
        data["tenancyName"] = this.tenancyName;
        return data; 
    }
}

export interface IImpersonateOutput {
    impersonationToken: string | undefined;
    tenancyName: string | undefined;
}

export class SwitchToLinkedAccountInput implements ISwitchToLinkedAccountInput {
    targetTenantId!: number | undefined;
    targetUserId!: number | undefined;

    constructor(data?: ISwitchToLinkedAccountInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.targetTenantId = data["targetTenantId"];
            this.targetUserId = data["targetUserId"];
        }
    }

    static fromJS(data: any): SwitchToLinkedAccountInput {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchToLinkedAccountInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["targetTenantId"] = this.targetTenantId;
        data["targetUserId"] = this.targetUserId;
        return data; 
    }
}

export interface ISwitchToLinkedAccountInput {
    targetTenantId: number | undefined;
    targetUserId: number | undefined;
}

export class SwitchToLinkedAccountOutput implements ISwitchToLinkedAccountOutput {
    switchAccountToken!: string | undefined;
    tenancyName!: string | undefined;

    constructor(data?: ISwitchToLinkedAccountOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.switchAccountToken = data["switchAccountToken"];
            this.tenancyName = data["tenancyName"];
        }
    }

    static fromJS(data: any): SwitchToLinkedAccountOutput {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchToLinkedAccountOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["switchAccountToken"] = this.switchAccountToken;
        data["tenancyName"] = this.tenancyName;
        return data; 
    }
}

export interface ISwitchToLinkedAccountOutput {
    switchAccountToken: string | undefined;
    tenancyName: string | undefined;
}

export class PagedResultDtoOfGetAddressForViewDto implements IPagedResultDtoOfGetAddressForViewDto {
    totalCount!: number | undefined;
    items!: GetAddressForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetAddressForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetAddressForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetAddressForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetAddressForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetAddressForViewDto {
    totalCount: number | undefined;
    items: GetAddressForViewDto[] | undefined;
}

export class GetAddressForViewDto implements IGetAddressForViewDto {
    address!: AddressDto | undefined;
    customerName!: string | undefined;
    assetOwnerName!: string | undefined;
    vendorName!: string | undefined;

    constructor(data?: IGetAddressForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.address = data["address"] ? AddressDto.fromJS(data["address"]) : <any>undefined;
            this.customerName = data["customerName"];
            this.assetOwnerName = data["assetOwnerName"];
            this.vendorName = data["vendorName"];
        }
    }

    static fromJS(data: any): GetAddressForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAddressForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["customerName"] = this.customerName;
        data["assetOwnerName"] = this.assetOwnerName;
        data["vendorName"] = this.vendorName;
        return data; 
    }
}

export interface IGetAddressForViewDto {
    address: AddressDto | undefined;
    customerName: string | undefined;
    assetOwnerName: string | undefined;
    vendorName: string | undefined;
}

export class AddressDto implements IAddressDto {
    addressEntryName!: string | undefined;
    isHeadOffice!: boolean | undefined;
    addressLine1!: string | undefined;
    addressLine2!: string | undefined;
    postalCode!: string | undefined;
    city!: string | undefined;
    state!: string | undefined;
    country!: string | undefined;
    addressLoc8GUID!: string | undefined;
    isDefaultForBilling!: boolean | undefined;
    isDefaultForShipping!: boolean | undefined;
    customerId!: number | undefined;
    assetOwnerId!: number | undefined;
    vendorId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IAddressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.addressEntryName = data["addressEntryName"];
            this.isHeadOffice = data["isHeadOffice"];
            this.addressLine1 = data["addressLine1"];
            this.addressLine2 = data["addressLine2"];
            this.postalCode = data["postalCode"];
            this.city = data["city"];
            this.state = data["state"];
            this.country = data["country"];
            this.addressLoc8GUID = data["addressLoc8GUID"];
            this.isDefaultForBilling = data["isDefaultForBilling"];
            this.isDefaultForShipping = data["isDefaultForShipping"];
            this.customerId = data["customerId"];
            this.assetOwnerId = data["assetOwnerId"];
            this.vendorId = data["vendorId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AddressDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["addressEntryName"] = this.addressEntryName;
        data["isHeadOffice"] = this.isHeadOffice;
        data["addressLine1"] = this.addressLine1;
        data["addressLine2"] = this.addressLine2;
        data["postalCode"] = this.postalCode;
        data["city"] = this.city;
        data["state"] = this.state;
        data["country"] = this.country;
        data["addressLoc8GUID"] = this.addressLoc8GUID;
        data["isDefaultForBilling"] = this.isDefaultForBilling;
        data["isDefaultForShipping"] = this.isDefaultForShipping;
        data["customerId"] = this.customerId;
        data["assetOwnerId"] = this.assetOwnerId;
        data["vendorId"] = this.vendorId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IAddressDto {
    addressEntryName: string | undefined;
    isHeadOffice: boolean | undefined;
    addressLine1: string | undefined;
    addressLine2: string | undefined;
    postalCode: string | undefined;
    city: string | undefined;
    state: string | undefined;
    country: string | undefined;
    addressLoc8GUID: string | undefined;
    isDefaultForBilling: boolean | undefined;
    isDefaultForShipping: boolean | undefined;
    customerId: number | undefined;
    assetOwnerId: number | undefined;
    vendorId: number | undefined;
    id: number | undefined;
}

export class GetAddressForEditOutput implements IGetAddressForEditOutput {
    address!: CreateOrEditAddressDto | undefined;
    customerName!: string | undefined;
    assetOwnerName!: string | undefined;
    vendorName!: string | undefined;

    constructor(data?: IGetAddressForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.address = data["address"] ? CreateOrEditAddressDto.fromJS(data["address"]) : <any>undefined;
            this.customerName = data["customerName"];
            this.assetOwnerName = data["assetOwnerName"];
            this.vendorName = data["vendorName"];
        }
    }

    static fromJS(data: any): GetAddressForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAddressForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["customerName"] = this.customerName;
        data["assetOwnerName"] = this.assetOwnerName;
        data["vendorName"] = this.vendorName;
        return data; 
    }
}

export interface IGetAddressForEditOutput {
    address: CreateOrEditAddressDto | undefined;
    customerName: string | undefined;
    assetOwnerName: string | undefined;
    vendorName: string | undefined;
}

export class CreateOrEditAddressDto implements ICreateOrEditAddressDto {
    addressEntryName!: string;
    isHeadOffice!: boolean | undefined;
    addressLine1!: string;
    addressLine2!: string | undefined;
    postalCode!: string | undefined;
    city!: string | undefined;
    state!: string | undefined;
    country!: string | undefined;
    addressLoc8GUID!: string | undefined;
    isDefaultForBilling!: boolean | undefined;
    isDefaultForShipping!: boolean | undefined;
    customerId!: number | undefined;
    assetOwnerId!: number | undefined;
    vendorId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditAddressDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.addressEntryName = data["addressEntryName"];
            this.isHeadOffice = data["isHeadOffice"];
            this.addressLine1 = data["addressLine1"];
            this.addressLine2 = data["addressLine2"];
            this.postalCode = data["postalCode"];
            this.city = data["city"];
            this.state = data["state"];
            this.country = data["country"];
            this.addressLoc8GUID = data["addressLoc8GUID"];
            this.isDefaultForBilling = data["isDefaultForBilling"];
            this.isDefaultForShipping = data["isDefaultForShipping"];
            this.customerId = data["customerId"];
            this.assetOwnerId = data["assetOwnerId"];
            this.vendorId = data["vendorId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditAddressDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditAddressDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["addressEntryName"] = this.addressEntryName;
        data["isHeadOffice"] = this.isHeadOffice;
        data["addressLine1"] = this.addressLine1;
        data["addressLine2"] = this.addressLine2;
        data["postalCode"] = this.postalCode;
        data["city"] = this.city;
        data["state"] = this.state;
        data["country"] = this.country;
        data["addressLoc8GUID"] = this.addressLoc8GUID;
        data["isDefaultForBilling"] = this.isDefaultForBilling;
        data["isDefaultForShipping"] = this.isDefaultForShipping;
        data["customerId"] = this.customerId;
        data["assetOwnerId"] = this.assetOwnerId;
        data["vendorId"] = this.vendorId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditAddressDto {
    addressEntryName: string;
    isHeadOffice: boolean | undefined;
    addressLine1: string;
    addressLine2: string | undefined;
    postalCode: string | undefined;
    city: string | undefined;
    state: string | undefined;
    country: string | undefined;
    addressLoc8GUID: string | undefined;
    isDefaultForBilling: boolean | undefined;
    isDefaultForShipping: boolean | undefined;
    customerId: number | undefined;
    assetOwnerId: number | undefined;
    vendorId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfAddressCustomerLookupTableDto implements IPagedResultDtoOfAddressCustomerLookupTableDto {
    totalCount!: number | undefined;
    items!: AddressCustomerLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAddressCustomerLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(AddressCustomerLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAddressCustomerLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAddressCustomerLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfAddressCustomerLookupTableDto {
    totalCount: number | undefined;
    items: AddressCustomerLookupTableDto[] | undefined;
}

export class AddressCustomerLookupTableDto implements IAddressCustomerLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IAddressCustomerLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): AddressCustomerLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddressCustomerLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IAddressCustomerLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfAddressAssetOwnerLookupTableDto implements IPagedResultDtoOfAddressAssetOwnerLookupTableDto {
    totalCount!: number | undefined;
    items!: AddressAssetOwnerLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAddressAssetOwnerLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(AddressAssetOwnerLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAddressAssetOwnerLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAddressAssetOwnerLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfAddressAssetOwnerLookupTableDto {
    totalCount: number | undefined;
    items: AddressAssetOwnerLookupTableDto[] | undefined;
}

export class AddressAssetOwnerLookupTableDto implements IAddressAssetOwnerLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IAddressAssetOwnerLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): AddressAssetOwnerLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddressAssetOwnerLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IAddressAssetOwnerLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfAddressVendorLookupTableDto implements IPagedResultDtoOfAddressVendorLookupTableDto {
    totalCount!: number | undefined;
    items!: AddressVendorLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAddressVendorLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(AddressVendorLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAddressVendorLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAddressVendorLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfAddressVendorLookupTableDto {
    totalCount: number | undefined;
    items: AddressVendorLookupTableDto[] | undefined;
}

export class AddressVendorLookupTableDto implements IAddressVendorLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IAddressVendorLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): AddressVendorLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new AddressVendorLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IAddressVendorLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetAgedReceivablesPeriodForViewDto implements IPagedResultDtoOfGetAgedReceivablesPeriodForViewDto {
    totalCount!: number | undefined;
    items!: GetAgedReceivablesPeriodForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetAgedReceivablesPeriodForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetAgedReceivablesPeriodForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetAgedReceivablesPeriodForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetAgedReceivablesPeriodForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetAgedReceivablesPeriodForViewDto {
    totalCount: number | undefined;
    items: GetAgedReceivablesPeriodForViewDto[] | undefined;
}

export class GetAgedReceivablesPeriodForViewDto implements IGetAgedReceivablesPeriodForViewDto {
    agedReceivablesPeriod!: AgedReceivablesPeriodDto | undefined;

    constructor(data?: IGetAgedReceivablesPeriodForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.agedReceivablesPeriod = data["agedReceivablesPeriod"] ? AgedReceivablesPeriodDto.fromJS(data["agedReceivablesPeriod"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAgedReceivablesPeriodForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAgedReceivablesPeriodForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["agedReceivablesPeriod"] = this.agedReceivablesPeriod ? this.agedReceivablesPeriod.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetAgedReceivablesPeriodForViewDto {
    agedReceivablesPeriod: AgedReceivablesPeriodDto | undefined;
}

export class AgedReceivablesPeriodDto implements IAgedReceivablesPeriodDto {
    period!: moment.Moment | undefined;
    current!: number | undefined;
    over30!: number | undefined;
    over60!: number | undefined;
    over90!: number | undefined;
    over120!: number | undefined;
    id!: number | undefined;

    constructor(data?: IAgedReceivablesPeriodDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.period = data["period"] ? moment(data["period"].toString()) : <any>undefined;
            this.current = data["current"];
            this.over30 = data["over30"];
            this.over60 = data["over60"];
            this.over90 = data["over90"];
            this.over120 = data["over120"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AgedReceivablesPeriodDto {
        data = typeof data === 'object' ? data : {};
        let result = new AgedReceivablesPeriodDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["period"] = this.period ? this.period.toISOString() : <any>undefined;
        data["current"] = this.current;
        data["over30"] = this.over30;
        data["over60"] = this.over60;
        data["over90"] = this.over90;
        data["over120"] = this.over120;
        data["id"] = this.id;
        return data; 
    }
}

export interface IAgedReceivablesPeriodDto {
    period: moment.Moment | undefined;
    current: number | undefined;
    over30: number | undefined;
    over60: number | undefined;
    over90: number | undefined;
    over120: number | undefined;
    id: number | undefined;
}

export class GetAgedReceivablesPeriodForEditOutput implements IGetAgedReceivablesPeriodForEditOutput {
    agedReceivablesPeriod!: CreateOrEditAgedReceivablesPeriodDto | undefined;

    constructor(data?: IGetAgedReceivablesPeriodForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.agedReceivablesPeriod = data["agedReceivablesPeriod"] ? CreateOrEditAgedReceivablesPeriodDto.fromJS(data["agedReceivablesPeriod"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAgedReceivablesPeriodForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAgedReceivablesPeriodForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["agedReceivablesPeriod"] = this.agedReceivablesPeriod ? this.agedReceivablesPeriod.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetAgedReceivablesPeriodForEditOutput {
    agedReceivablesPeriod: CreateOrEditAgedReceivablesPeriodDto | undefined;
}

export class CreateOrEditAgedReceivablesPeriodDto implements ICreateOrEditAgedReceivablesPeriodDto {
    period!: moment.Moment | undefined;
    current!: number | undefined;
    over30!: number | undefined;
    over60!: number | undefined;
    over90!: number | undefined;
    over120!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditAgedReceivablesPeriodDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.period = data["period"] ? moment(data["period"].toString()) : <any>undefined;
            this.current = data["current"];
            this.over30 = data["over30"];
            this.over60 = data["over60"];
            this.over90 = data["over90"];
            this.over120 = data["over120"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditAgedReceivablesPeriodDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditAgedReceivablesPeriodDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["period"] = this.period ? this.period.toISOString() : <any>undefined;
        data["current"] = this.current;
        data["over30"] = this.over30;
        data["over60"] = this.over60;
        data["over90"] = this.over90;
        data["over120"] = this.over120;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditAgedReceivablesPeriodDto {
    period: moment.Moment | undefined;
    current: number | undefined;
    over30: number | undefined;
    over60: number | undefined;
    over90: number | undefined;
    over120: number | undefined;
    id: number | undefined;
}

export class FileDto implements IFileDto {
    fileName!: string;
    fileType!: string | undefined;
    fileToken!: string;

    constructor(data?: IFileDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fileName = data["fileName"];
            this.fileType = data["fileType"];
            this.fileToken = data["fileToken"];
        }
    }

    static fromJS(data: any): FileDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["fileType"] = this.fileType;
        data["fileToken"] = this.fileToken;
        return data; 
    }
}

export interface IFileDto {
    fileName: string;
    fileType: string | undefined;
    fileToken: string;
}

export class PagedResultDtoOfGetAssetClassForViewDto implements IPagedResultDtoOfGetAssetClassForViewDto {
    totalCount!: number | undefined;
    items!: GetAssetClassForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetAssetClassForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetAssetClassForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetAssetClassForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetAssetClassForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetAssetClassForViewDto {
    totalCount: number | undefined;
    items: GetAssetClassForViewDto[] | undefined;
}

export class GetAssetClassForViewDto implements IGetAssetClassForViewDto {
    assetClass!: AssetClassDto | undefined;
    assetTypeType!: string | undefined;

    constructor(data?: IGetAssetClassForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assetClass = data["assetClass"] ? AssetClassDto.fromJS(data["assetClass"]) : <any>undefined;
            this.assetTypeType = data["assetTypeType"];
        }
    }

    static fromJS(data: any): GetAssetClassForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAssetClassForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assetClass"] = this.assetClass ? this.assetClass.toJSON() : <any>undefined;
        data["assetTypeType"] = this.assetTypeType;
        return data; 
    }
}

export interface IGetAssetClassForViewDto {
    assetClass: AssetClassDto | undefined;
    assetTypeType: string | undefined;
}

export class AssetClassDto implements IAssetClassDto {
    manufacturer!: string | undefined;
    model!: string | undefined;
    specification!: string | undefined;
    class!: string | undefined;
    assetTypeId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IAssetClassDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.manufacturer = data["manufacturer"];
            this.model = data["model"];
            this.specification = data["specification"];
            this.class = data["class"];
            this.assetTypeId = data["assetTypeId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AssetClassDto {
        data = typeof data === 'object' ? data : {};
        let result = new AssetClassDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["manufacturer"] = this.manufacturer;
        data["model"] = this.model;
        data["specification"] = this.specification;
        data["class"] = this.class;
        data["assetTypeId"] = this.assetTypeId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IAssetClassDto {
    manufacturer: string | undefined;
    model: string | undefined;
    specification: string | undefined;
    class: string | undefined;
    assetTypeId: number | undefined;
    id: number | undefined;
}

export class GetAssetClassForEditOutput implements IGetAssetClassForEditOutput {
    assetClass!: CreateOrEditAssetClassDto | undefined;
    assetTypeType!: string | undefined;

    constructor(data?: IGetAssetClassForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assetClass = data["assetClass"] ? CreateOrEditAssetClassDto.fromJS(data["assetClass"]) : <any>undefined;
            this.assetTypeType = data["assetTypeType"];
        }
    }

    static fromJS(data: any): GetAssetClassForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAssetClassForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assetClass"] = this.assetClass ? this.assetClass.toJSON() : <any>undefined;
        data["assetTypeType"] = this.assetTypeType;
        return data; 
    }
}

export interface IGetAssetClassForEditOutput {
    assetClass: CreateOrEditAssetClassDto | undefined;
    assetTypeType: string | undefined;
}

export class CreateOrEditAssetClassDto implements ICreateOrEditAssetClassDto {
    manufacturer!: string;
    model!: string | undefined;
    specification!: string | undefined;
    class!: string;
    assetTypeId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditAssetClassDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.manufacturer = data["manufacturer"];
            this.model = data["model"];
            this.specification = data["specification"];
            this.class = data["class"];
            this.assetTypeId = data["assetTypeId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditAssetClassDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditAssetClassDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["manufacturer"] = this.manufacturer;
        data["model"] = this.model;
        data["specification"] = this.specification;
        data["class"] = this.class;
        data["assetTypeId"] = this.assetTypeId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditAssetClassDto {
    manufacturer: string;
    model: string | undefined;
    specification: string | undefined;
    class: string;
    assetTypeId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfAssetClassAssetTypeLookupTableDto implements IPagedResultDtoOfAssetClassAssetTypeLookupTableDto {
    totalCount!: number | undefined;
    items!: AssetClassAssetTypeLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAssetClassAssetTypeLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(AssetClassAssetTypeLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAssetClassAssetTypeLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAssetClassAssetTypeLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfAssetClassAssetTypeLookupTableDto {
    totalCount: number | undefined;
    items: AssetClassAssetTypeLookupTableDto[] | undefined;
}

export class AssetClassAssetTypeLookupTableDto implements IAssetClassAssetTypeLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IAssetClassAssetTypeLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): AssetClassAssetTypeLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new AssetClassAssetTypeLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IAssetClassAssetTypeLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetAssetNotesForViewDto implements IPagedResultDtoOfGetAssetNotesForViewDto {
    totalCount!: number | undefined;
    items!: GetAssetNotesForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetAssetNotesForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetAssetNotesForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetAssetNotesForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetAssetNotesForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetAssetNotesForViewDto {
    totalCount: number | undefined;
    items: GetAssetNotesForViewDto[] | undefined;
}

export class GetAssetNotesForViewDto implements IGetAssetNotesForViewDto {
    assetNotes!: AssetNotesDto | undefined;
    username!: string | undefined;
    assetReference!: string | undefined;

    constructor(data?: IGetAssetNotesForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assetNotes = data["assetNotes"] ? AssetNotesDto.fromJS(data["assetNotes"]) : <any>undefined;
            this.username = data["username"];
            this.assetReference = data["assetReference"];
        }
    }

    static fromJS(data: any): GetAssetNotesForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAssetNotesForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assetNotes"] = this.assetNotes ? this.assetNotes.toJSON() : <any>undefined;
        data["username"] = this.username;
        data["assetReference"] = this.assetReference;
        return data; 
    }
}

export interface IGetAssetNotesForViewDto {
    assetNotes: AssetNotesDto | undefined;
    username: string | undefined;
    assetReference: string | undefined;
}

export class AssetNotesDto implements IAssetNotesDto {
    title!: string | undefined;
    notes!: string | undefined;
    assetId!: number | undefined;
    userId!: number | undefined;
    tenantId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IAssetNotesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.title = data["title"];
            this.notes = data["notes"];
            this.assetId = data["assetId"];
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AssetNotesDto {
        data = typeof data === 'object' ? data : {};
        let result = new AssetNotesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["notes"] = this.notes;
        data["assetId"] = this.assetId;
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IAssetNotesDto {
    title: string | undefined;
    notes: string | undefined;
    assetId: number | undefined;
    userId: number | undefined;
    tenantId: number | undefined;
    id: number | undefined;
}

export class GetAssetNotesForEditOutput implements IGetAssetNotesForEditOutput {
    assetNotes!: CreateOrEditAssetNotesDto | undefined;

    constructor(data?: IGetAssetNotesForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assetNotes = data["assetNotes"] ? CreateOrEditAssetNotesDto.fromJS(data["assetNotes"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAssetNotesForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAssetNotesForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assetNotes"] = this.assetNotes ? this.assetNotes.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetAssetNotesForEditOutput {
    assetNotes: CreateOrEditAssetNotesDto | undefined;
}

export class CreateOrEditAssetNotesDto implements ICreateOrEditAssetNotesDto {
    title!: string;
    notes!: string;
    userId!: number | undefined;
    assetId!: number | undefined;
    tenantId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditAssetNotesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.title = data["title"];
            this.notes = data["notes"];
            this.userId = data["userId"];
            this.assetId = data["assetId"];
            this.tenantId = data["tenantId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditAssetNotesDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditAssetNotesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["notes"] = this.notes;
        data["userId"] = this.userId;
        data["assetId"] = this.assetId;
        data["tenantId"] = this.tenantId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditAssetNotesDto {
    title: string;
    notes: string;
    userId: number | undefined;
    assetId: number | undefined;
    tenantId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfGetAssetOwnerForViewDto implements IPagedResultDtoOfGetAssetOwnerForViewDto {
    totalCount!: number | undefined;
    items!: GetAssetOwnerForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetAssetOwnerForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetAssetOwnerForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetAssetOwnerForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetAssetOwnerForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetAssetOwnerForViewDto {
    totalCount: number | undefined;
    items: GetAssetOwnerForViewDto[] | undefined;
}

export class GetAssetOwnerForViewDto implements IGetAssetOwnerForViewDto {
    assetOwner!: AssetOwnerDto | undefined;
    currencyCode!: string | undefined;
    ssicCodeCode!: string | undefined;

    constructor(data?: IGetAssetOwnerForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assetOwner = data["assetOwner"] ? AssetOwnerDto.fromJS(data["assetOwner"]) : <any>undefined;
            this.currencyCode = data["currencyCode"];
            this.ssicCodeCode = data["ssicCodeCode"];
        }
    }

    static fromJS(data: any): GetAssetOwnerForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAssetOwnerForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assetOwner"] = this.assetOwner ? this.assetOwner.toJSON() : <any>undefined;
        data["currencyCode"] = this.currencyCode;
        data["ssicCodeCode"] = this.ssicCodeCode;
        return data; 
    }
}

export interface IGetAssetOwnerForViewDto {
    assetOwner: AssetOwnerDto | undefined;
    currencyCode: string | undefined;
    ssicCodeCode: string | undefined;
}

export class AssetOwnerDto implements IAssetOwnerDto {
    reference!: string | undefined;
    name!: string | undefined;
    identifier!: string | undefined;
    logoUrl!: string | undefined;
    website!: string | undefined;
    currencyId!: number | undefined;
    ssicCodeId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IAssetOwnerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reference = data["reference"];
            this.name = data["name"];
            this.identifier = data["identifier"];
            this.logoUrl = data["logoUrl"];
            this.website = data["website"];
            this.currencyId = data["currencyId"];
            this.ssicCodeId = data["ssicCodeId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AssetOwnerDto {
        data = typeof data === 'object' ? data : {};
        let result = new AssetOwnerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reference"] = this.reference;
        data["name"] = this.name;
        data["identifier"] = this.identifier;
        data["logoUrl"] = this.logoUrl;
        data["website"] = this.website;
        data["currencyId"] = this.currencyId;
        data["ssicCodeId"] = this.ssicCodeId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IAssetOwnerDto {
    reference: string | undefined;
    name: string | undefined;
    identifier: string | undefined;
    logoUrl: string | undefined;
    website: string | undefined;
    currencyId: number | undefined;
    ssicCodeId: number | undefined;
    id: number | undefined;
}

export class GetAssetOwnerForEditOutput implements IGetAssetOwnerForEditOutput {
    assetOwner!: CreateOrEditAssetOwnerDto | undefined;
    currencyCode!: string | undefined;
    ssicCodeCode!: string | undefined;

    constructor(data?: IGetAssetOwnerForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assetOwner = data["assetOwner"] ? CreateOrEditAssetOwnerDto.fromJS(data["assetOwner"]) : <any>undefined;
            this.currencyCode = data["currencyCode"];
            this.ssicCodeCode = data["ssicCodeCode"];
        }
    }

    static fromJS(data: any): GetAssetOwnerForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAssetOwnerForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assetOwner"] = this.assetOwner ? this.assetOwner.toJSON() : <any>undefined;
        data["currencyCode"] = this.currencyCode;
        data["ssicCodeCode"] = this.ssicCodeCode;
        return data; 
    }
}

export interface IGetAssetOwnerForEditOutput {
    assetOwner: CreateOrEditAssetOwnerDto | undefined;
    currencyCode: string | undefined;
    ssicCodeCode: string | undefined;
}

export class CreateOrEditAssetOwnerDto implements ICreateOrEditAssetOwnerDto {
    reference!: string;
    name!: string;
    identifier!: string | undefined;
    logoUrl!: string | undefined;
    website!: string | undefined;
    currencyId!: number | undefined;
    ssicCodeId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditAssetOwnerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reference = data["reference"];
            this.name = data["name"];
            this.identifier = data["identifier"];
            this.logoUrl = data["logoUrl"];
            this.website = data["website"];
            this.currencyId = data["currencyId"];
            this.ssicCodeId = data["ssicCodeId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditAssetOwnerDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditAssetOwnerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reference"] = this.reference;
        data["name"] = this.name;
        data["identifier"] = this.identifier;
        data["logoUrl"] = this.logoUrl;
        data["website"] = this.website;
        data["currencyId"] = this.currencyId;
        data["ssicCodeId"] = this.ssicCodeId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditAssetOwnerDto {
    reference: string;
    name: string;
    identifier: string | undefined;
    logoUrl: string | undefined;
    website: string | undefined;
    currencyId: number | undefined;
    ssicCodeId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfAssetOwnerCurrencyLookupTableDto implements IPagedResultDtoOfAssetOwnerCurrencyLookupTableDto {
    totalCount!: number | undefined;
    items!: AssetOwnerCurrencyLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAssetOwnerCurrencyLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(AssetOwnerCurrencyLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAssetOwnerCurrencyLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAssetOwnerCurrencyLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfAssetOwnerCurrencyLookupTableDto {
    totalCount: number | undefined;
    items: AssetOwnerCurrencyLookupTableDto[] | undefined;
}

export class AssetOwnerCurrencyLookupTableDto implements IAssetOwnerCurrencyLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IAssetOwnerCurrencyLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): AssetOwnerCurrencyLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new AssetOwnerCurrencyLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IAssetOwnerCurrencyLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfAssetOwnerSsicCodeLookupTableDto implements IPagedResultDtoOfAssetOwnerSsicCodeLookupTableDto {
    totalCount!: number | undefined;
    items!: AssetOwnerSsicCodeLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAssetOwnerSsicCodeLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(AssetOwnerSsicCodeLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAssetOwnerSsicCodeLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAssetOwnerSsicCodeLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfAssetOwnerSsicCodeLookupTableDto {
    totalCount: number | undefined;
    items: AssetOwnerSsicCodeLookupTableDto[] | undefined;
}

export class AssetOwnerSsicCodeLookupTableDto implements IAssetOwnerSsicCodeLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IAssetOwnerSsicCodeLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): AssetOwnerSsicCodeLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new AssetOwnerSsicCodeLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IAssetOwnerSsicCodeLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetAssetOwnershipForViewDto implements IPagedResultDtoOfGetAssetOwnershipForViewDto {
    totalCount!: number | undefined;
    items!: GetAssetOwnershipForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetAssetOwnershipForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetAssetOwnershipForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetAssetOwnershipForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetAssetOwnershipForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetAssetOwnershipForViewDto {
    totalCount: number | undefined;
    items: GetAssetOwnershipForViewDto[] | undefined;
}

export class GetAssetOwnershipForViewDto implements IGetAssetOwnershipForViewDto {
    assetOwnership!: AssetOwnershipDto | undefined;
    assetReference!: string | undefined;
    assetOwnerName!: string | undefined;

    constructor(data?: IGetAssetOwnershipForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assetOwnership = data["assetOwnership"] ? AssetOwnershipDto.fromJS(data["assetOwnership"]) : <any>undefined;
            this.assetReference = data["assetReference"];
            this.assetOwnerName = data["assetOwnerName"];
        }
    }

    static fromJS(data: any): GetAssetOwnershipForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAssetOwnershipForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assetOwnership"] = this.assetOwnership ? this.assetOwnership.toJSON() : <any>undefined;
        data["assetReference"] = this.assetReference;
        data["assetOwnerName"] = this.assetOwnerName;
        return data; 
    }
}

export interface IGetAssetOwnershipForViewDto {
    assetOwnership: AssetOwnershipDto | undefined;
    assetReference: string | undefined;
    assetOwnerName: string | undefined;
}

export class AssetOwnershipDto implements IAssetOwnershipDto {
    startDate!: moment.Moment | undefined;
    finishDate!: moment.Moment | undefined;
    percentageOwnership!: number | undefined;
    assetId!: number | undefined;
    assetOwnerId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IAssetOwnershipDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.finishDate = data["finishDate"] ? moment(data["finishDate"].toString()) : <any>undefined;
            this.percentageOwnership = data["percentageOwnership"];
            this.assetId = data["assetId"];
            this.assetOwnerId = data["assetOwnerId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AssetOwnershipDto {
        data = typeof data === 'object' ? data : {};
        let result = new AssetOwnershipDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["finishDate"] = this.finishDate ? this.finishDate.toISOString() : <any>undefined;
        data["percentageOwnership"] = this.percentageOwnership;
        data["assetId"] = this.assetId;
        data["assetOwnerId"] = this.assetOwnerId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IAssetOwnershipDto {
    startDate: moment.Moment | undefined;
    finishDate: moment.Moment | undefined;
    percentageOwnership: number | undefined;
    assetId: number | undefined;
    assetOwnerId: number | undefined;
    id: number | undefined;
}

export class GetAssetOwnershipForEditOutput implements IGetAssetOwnershipForEditOutput {
    assetOwnership!: CreateOrEditAssetOwnershipDto | undefined;
    assetReference!: string | undefined;
    assetOwnerName!: string | undefined;

    constructor(data?: IGetAssetOwnershipForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assetOwnership = data["assetOwnership"] ? CreateOrEditAssetOwnershipDto.fromJS(data["assetOwnership"]) : <any>undefined;
            this.assetReference = data["assetReference"];
            this.assetOwnerName = data["assetOwnerName"];
        }
    }

    static fromJS(data: any): GetAssetOwnershipForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAssetOwnershipForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assetOwnership"] = this.assetOwnership ? this.assetOwnership.toJSON() : <any>undefined;
        data["assetReference"] = this.assetReference;
        data["assetOwnerName"] = this.assetOwnerName;
        return data; 
    }
}

export interface IGetAssetOwnershipForEditOutput {
    assetOwnership: CreateOrEditAssetOwnershipDto | undefined;
    assetReference: string | undefined;
    assetOwnerName: string | undefined;
}

export class CreateOrEditAssetOwnershipDto implements ICreateOrEditAssetOwnershipDto {
    startDate!: moment.Moment | undefined;
    finishDate!: moment.Moment | undefined;
    percentageOwnership!: number | undefined;
    assetId!: number | undefined;
    assetOwnerId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditAssetOwnershipDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.finishDate = data["finishDate"] ? moment(data["finishDate"].toString()) : <any>undefined;
            this.percentageOwnership = data["percentageOwnership"];
            this.assetId = data["assetId"];
            this.assetOwnerId = data["assetOwnerId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditAssetOwnershipDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditAssetOwnershipDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["finishDate"] = this.finishDate ? this.finishDate.toISOString() : <any>undefined;
        data["percentageOwnership"] = this.percentageOwnership;
        data["assetId"] = this.assetId;
        data["assetOwnerId"] = this.assetOwnerId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditAssetOwnershipDto {
    startDate: moment.Moment | undefined;
    finishDate: moment.Moment | undefined;
    percentageOwnership: number | undefined;
    assetId: number | undefined;
    assetOwnerId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfAssetOwnershipAssetLookupTableDto implements IPagedResultDtoOfAssetOwnershipAssetLookupTableDto {
    totalCount!: number | undefined;
    items!: AssetOwnershipAssetLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAssetOwnershipAssetLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(AssetOwnershipAssetLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAssetOwnershipAssetLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAssetOwnershipAssetLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfAssetOwnershipAssetLookupTableDto {
    totalCount: number | undefined;
    items: AssetOwnershipAssetLookupTableDto[] | undefined;
}

export class AssetOwnershipAssetLookupTableDto implements IAssetOwnershipAssetLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IAssetOwnershipAssetLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): AssetOwnershipAssetLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new AssetOwnershipAssetLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IAssetOwnershipAssetLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfAssetOwnershipAssetOwnerLookupTableDto implements IPagedResultDtoOfAssetOwnershipAssetOwnerLookupTableDto {
    totalCount!: number | undefined;
    items!: AssetOwnershipAssetOwnerLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAssetOwnershipAssetOwnerLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(AssetOwnershipAssetOwnerLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAssetOwnershipAssetOwnerLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAssetOwnershipAssetOwnerLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfAssetOwnershipAssetOwnerLookupTableDto {
    totalCount: number | undefined;
    items: AssetOwnershipAssetOwnerLookupTableDto[] | undefined;
}

export class AssetOwnershipAssetOwnerLookupTableDto implements IAssetOwnershipAssetOwnerLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IAssetOwnershipAssetOwnerLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): AssetOwnershipAssetOwnerLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new AssetOwnershipAssetOwnerLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IAssetOwnershipAssetOwnerLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class ListResultDtoOfAssetPartExtendedDto implements IListResultDtoOfAssetPartExtendedDto {
    items!: AssetPartExtendedDto[] | undefined;

    constructor(data?: IListResultDtoOfAssetPartExtendedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(AssetPartExtendedDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfAssetPartExtendedDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfAssetPartExtendedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfAssetPartExtendedDto {
    items: AssetPartExtendedDto[] | undefined;
}

export class AssetPartExtendedDto implements IAssetPartExtendedDto {
    assetPartStatus!: string | undefined;
    assetPartType!: string | undefined;
    assetReference!: string | undefined;
    itemType!: string | undefined;
    parentName!: string | undefined;
    warehouseName!: string | undefined;
    name!: string | undefined;
    description!: string | undefined;
    serialNumber!: string | undefined;
    installDate!: moment.Moment | undefined;
    code!: string | undefined;
    installed!: boolean | undefined;
    isItem!: boolean | undefined;
    qty!: number | undefined;
    assetPartTypeId!: number | undefined;
    parentId!: number | undefined;
    assetPartStatusId!: number | undefined;
    assetId!: number | undefined;
    itemTypeId!: number | undefined;
    warehouseId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IAssetPartExtendedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assetPartStatus = data["assetPartStatus"];
            this.assetPartType = data["assetPartType"];
            this.assetReference = data["assetReference"];
            this.itemType = data["itemType"];
            this.parentName = data["parentName"];
            this.warehouseName = data["warehouseName"];
            this.name = data["name"];
            this.description = data["description"];
            this.serialNumber = data["serialNumber"];
            this.installDate = data["installDate"] ? moment(data["installDate"].toString()) : <any>undefined;
            this.code = data["code"];
            this.installed = data["installed"];
            this.isItem = data["isItem"];
            this.qty = data["qty"];
            this.assetPartTypeId = data["assetPartTypeId"];
            this.parentId = data["parentId"];
            this.assetPartStatusId = data["assetPartStatusId"];
            this.assetId = data["assetId"];
            this.itemTypeId = data["itemTypeId"];
            this.warehouseId = data["warehouseId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AssetPartExtendedDto {
        data = typeof data === 'object' ? data : {};
        let result = new AssetPartExtendedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assetPartStatus"] = this.assetPartStatus;
        data["assetPartType"] = this.assetPartType;
        data["assetReference"] = this.assetReference;
        data["itemType"] = this.itemType;
        data["parentName"] = this.parentName;
        data["warehouseName"] = this.warehouseName;
        data["name"] = this.name;
        data["description"] = this.description;
        data["serialNumber"] = this.serialNumber;
        data["installDate"] = this.installDate ? this.installDate.toISOString() : <any>undefined;
        data["code"] = this.code;
        data["installed"] = this.installed;
        data["isItem"] = this.isItem;
        data["qty"] = this.qty;
        data["assetPartTypeId"] = this.assetPartTypeId;
        data["parentId"] = this.parentId;
        data["assetPartStatusId"] = this.assetPartStatusId;
        data["assetId"] = this.assetId;
        data["itemTypeId"] = this.itemTypeId;
        data["warehouseId"] = this.warehouseId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IAssetPartExtendedDto {
    assetPartStatus: string | undefined;
    assetPartType: string | undefined;
    assetReference: string | undefined;
    itemType: string | undefined;
    parentName: string | undefined;
    warehouseName: string | undefined;
    name: string | undefined;
    description: string | undefined;
    serialNumber: string | undefined;
    installDate: moment.Moment | undefined;
    code: string | undefined;
    installed: boolean | undefined;
    isItem: boolean | undefined;
    qty: number | undefined;
    assetPartTypeId: number | undefined;
    parentId: number | undefined;
    assetPartStatusId: number | undefined;
    assetId: number | undefined;
    itemTypeId: number | undefined;
    warehouseId: number | undefined;
    id: number | undefined;
}

export class MoveAssetPartInput implements IMoveAssetPartInput {
    id!: number | undefined;
    newParentId!: number | undefined;

    constructor(data?: IMoveAssetPartInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.newParentId = data["newParentId"];
        }
    }

    static fromJS(data: any): MoveAssetPartInput {
        data = typeof data === 'object' ? data : {};
        let result = new MoveAssetPartInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["newParentId"] = this.newParentId;
        return data; 
    }
}

export interface IMoveAssetPartInput {
    id: number | undefined;
    newParentId: number | undefined;
}

export class AssetPartDto implements IAssetPartDto {
    name!: string | undefined;
    description!: string | undefined;
    serialNumber!: string | undefined;
    installDate!: moment.Moment | undefined;
    code!: string | undefined;
    installed!: boolean | undefined;
    isItem!: boolean | undefined;
    qty!: number | undefined;
    assetPartTypeId!: number | undefined;
    parentId!: number | undefined;
    assetPartStatusId!: number | undefined;
    assetId!: number | undefined;
    itemTypeId!: number | undefined;
    warehouseId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IAssetPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.description = data["description"];
            this.serialNumber = data["serialNumber"];
            this.installDate = data["installDate"] ? moment(data["installDate"].toString()) : <any>undefined;
            this.code = data["code"];
            this.installed = data["installed"];
            this.isItem = data["isItem"];
            this.qty = data["qty"];
            this.assetPartTypeId = data["assetPartTypeId"];
            this.parentId = data["parentId"];
            this.assetPartStatusId = data["assetPartStatusId"];
            this.assetId = data["assetId"];
            this.itemTypeId = data["itemTypeId"];
            this.warehouseId = data["warehouseId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AssetPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new AssetPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["serialNumber"] = this.serialNumber;
        data["installDate"] = this.installDate ? this.installDate.toISOString() : <any>undefined;
        data["code"] = this.code;
        data["installed"] = this.installed;
        data["isItem"] = this.isItem;
        data["qty"] = this.qty;
        data["assetPartTypeId"] = this.assetPartTypeId;
        data["parentId"] = this.parentId;
        data["assetPartStatusId"] = this.assetPartStatusId;
        data["assetId"] = this.assetId;
        data["itemTypeId"] = this.itemTypeId;
        data["warehouseId"] = this.warehouseId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IAssetPartDto {
    name: string | undefined;
    description: string | undefined;
    serialNumber: string | undefined;
    installDate: moment.Moment | undefined;
    code: string | undefined;
    installed: boolean | undefined;
    isItem: boolean | undefined;
    qty: number | undefined;
    assetPartTypeId: number | undefined;
    parentId: number | undefined;
    assetPartStatusId: number | undefined;
    assetId: number | undefined;
    itemTypeId: number | undefined;
    warehouseId: number | undefined;
    id: number | undefined;
}

export class MoveAssetPartToAssetInput implements IMoveAssetPartToAssetInput {
    assetPartId!: number | undefined;
    assetPartParentId!: number | undefined;
    newAssetId!: number | undefined;
    importAssetPart!: boolean | undefined;
    newAssetPartParentId!: number | undefined;

    constructor(data?: IMoveAssetPartToAssetInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assetPartId = data["assetPartId"];
            this.assetPartParentId = data["assetPartParentId"];
            this.newAssetId = data["newAssetId"];
            this.importAssetPart = data["importAssetPart"];
            this.newAssetPartParentId = data["newAssetPartParentId"];
        }
    }

    static fromJS(data: any): MoveAssetPartToAssetInput {
        data = typeof data === 'object' ? data : {};
        let result = new MoveAssetPartToAssetInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assetPartId"] = this.assetPartId;
        data["assetPartParentId"] = this.assetPartParentId;
        data["newAssetId"] = this.newAssetId;
        data["importAssetPart"] = this.importAssetPart;
        data["newAssetPartParentId"] = this.newAssetPartParentId;
        return data; 
    }
}

export interface IMoveAssetPartToAssetInput {
    assetPartId: number | undefined;
    assetPartParentId: number | undefined;
    newAssetId: number | undefined;
    importAssetPart: boolean | undefined;
    newAssetPartParentId: number | undefined;
}

export class MoveAssetPartToWarehouseInput implements IMoveAssetPartToWarehouseInput {
    assetPartId!: number | undefined;
    newWarehouseId!: number | undefined;

    constructor(data?: IMoveAssetPartToWarehouseInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assetPartId = data["assetPartId"];
            this.newWarehouseId = data["newWarehouseId"];
        }
    }

    static fromJS(data: any): MoveAssetPartToWarehouseInput {
        data = typeof data === 'object' ? data : {};
        let result = new MoveAssetPartToWarehouseInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assetPartId"] = this.assetPartId;
        data["newWarehouseId"] = this.newWarehouseId;
        return data; 
    }
}

export interface IMoveAssetPartToWarehouseInput {
    assetPartId: number | undefined;
    newWarehouseId: number | undefined;
}

export class PagedResultDtoOfGetAssetPartForViewDto implements IPagedResultDtoOfGetAssetPartForViewDto {
    totalCount!: number | undefined;
    items!: GetAssetPartForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetAssetPartForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetAssetPartForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetAssetPartForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetAssetPartForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetAssetPartForViewDto {
    totalCount: number | undefined;
    items: GetAssetPartForViewDto[] | undefined;
}

export class GetAssetPartForViewDto implements IGetAssetPartForViewDto {
    assetPart!: AssetPartDto | undefined;
    assetPartTypeType!: string | undefined;
    assetPartName!: string | undefined;
    assetPartStatusStatus!: string | undefined;
    assetReference!: string | undefined;
    itemTypeType!: string | undefined;
    warehouseName!: string | undefined;

    constructor(data?: IGetAssetPartForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assetPart = data["assetPart"] ? AssetPartDto.fromJS(data["assetPart"]) : <any>undefined;
            this.assetPartTypeType = data["assetPartTypeType"];
            this.assetPartName = data["assetPartName"];
            this.assetPartStatusStatus = data["assetPartStatusStatus"];
            this.assetReference = data["assetReference"];
            this.itemTypeType = data["itemTypeType"];
            this.warehouseName = data["warehouseName"];
        }
    }

    static fromJS(data: any): GetAssetPartForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAssetPartForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assetPart"] = this.assetPart ? this.assetPart.toJSON() : <any>undefined;
        data["assetPartTypeType"] = this.assetPartTypeType;
        data["assetPartName"] = this.assetPartName;
        data["assetPartStatusStatus"] = this.assetPartStatusStatus;
        data["assetReference"] = this.assetReference;
        data["itemTypeType"] = this.itemTypeType;
        data["warehouseName"] = this.warehouseName;
        return data; 
    }
}

export interface IGetAssetPartForViewDto {
    assetPart: AssetPartDto | undefined;
    assetPartTypeType: string | undefined;
    assetPartName: string | undefined;
    assetPartStatusStatus: string | undefined;
    assetReference: string | undefined;
    itemTypeType: string | undefined;
    warehouseName: string | undefined;
}

export class GetAssetPartForEditOutput implements IGetAssetPartForEditOutput {
    assetPart!: CreateOrEditAssetPartDto | undefined;
    assetPartTypeType!: string | undefined;
    assetPartName!: string | undefined;
    assetPartStatusStatus!: string | undefined;
    assetReference!: string | undefined;
    itemTypeType!: string | undefined;
    warehouseName!: string | undefined;

    constructor(data?: IGetAssetPartForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assetPart = data["assetPart"] ? CreateOrEditAssetPartDto.fromJS(data["assetPart"]) : <any>undefined;
            this.assetPartTypeType = data["assetPartTypeType"];
            this.assetPartName = data["assetPartName"];
            this.assetPartStatusStatus = data["assetPartStatusStatus"];
            this.assetReference = data["assetReference"];
            this.itemTypeType = data["itemTypeType"];
            this.warehouseName = data["warehouseName"];
        }
    }

    static fromJS(data: any): GetAssetPartForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAssetPartForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assetPart"] = this.assetPart ? this.assetPart.toJSON() : <any>undefined;
        data["assetPartTypeType"] = this.assetPartTypeType;
        data["assetPartName"] = this.assetPartName;
        data["assetPartStatusStatus"] = this.assetPartStatusStatus;
        data["assetReference"] = this.assetReference;
        data["itemTypeType"] = this.itemTypeType;
        data["warehouseName"] = this.warehouseName;
        return data; 
    }
}

export interface IGetAssetPartForEditOutput {
    assetPart: CreateOrEditAssetPartDto | undefined;
    assetPartTypeType: string | undefined;
    assetPartName: string | undefined;
    assetPartStatusStatus: string | undefined;
    assetReference: string | undefined;
    itemTypeType: string | undefined;
    warehouseName: string | undefined;
}

export class CreateOrEditAssetPartDto implements ICreateOrEditAssetPartDto {
    name!: string;
    description!: string | undefined;
    serialNumber!: string | undefined;
    installDate!: moment.Moment | undefined;
    qty!: number | undefined;
    isItem!: boolean | undefined;
    code!: string;
    installed!: boolean | undefined;
    assetPartTypeId!: number | undefined;
    parentId!: number | undefined;
    assetPartStatusId!: number | undefined;
    assetId!: number | undefined;
    itemTypeId!: number | undefined;
    warehouseId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditAssetPartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.description = data["description"];
            this.serialNumber = data["serialNumber"];
            this.installDate = data["installDate"] ? moment(data["installDate"].toString()) : <any>undefined;
            this.qty = data["qty"];
            this.isItem = data["isItem"];
            this.code = data["code"];
            this.installed = data["installed"];
            this.assetPartTypeId = data["assetPartTypeId"];
            this.parentId = data["parentId"];
            this.assetPartStatusId = data["assetPartStatusId"];
            this.assetId = data["assetId"];
            this.itemTypeId = data["itemTypeId"];
            this.warehouseId = data["warehouseId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditAssetPartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditAssetPartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["serialNumber"] = this.serialNumber;
        data["installDate"] = this.installDate ? this.installDate.toISOString() : <any>undefined;
        data["qty"] = this.qty;
        data["isItem"] = this.isItem;
        data["code"] = this.code;
        data["installed"] = this.installed;
        data["assetPartTypeId"] = this.assetPartTypeId;
        data["parentId"] = this.parentId;
        data["assetPartStatusId"] = this.assetPartStatusId;
        data["assetId"] = this.assetId;
        data["itemTypeId"] = this.itemTypeId;
        data["warehouseId"] = this.warehouseId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditAssetPartDto {
    name: string;
    description: string | undefined;
    serialNumber: string | undefined;
    installDate: moment.Moment | undefined;
    qty: number | undefined;
    isItem: boolean | undefined;
    code: string;
    installed: boolean | undefined;
    assetPartTypeId: number | undefined;
    parentId: number | undefined;
    assetPartStatusId: number | undefined;
    assetId: number | undefined;
    itemTypeId: number | undefined;
    warehouseId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfAssetPartAssetPartTypeLookupTableDto implements IPagedResultDtoOfAssetPartAssetPartTypeLookupTableDto {
    totalCount!: number | undefined;
    items!: AssetPartAssetPartTypeLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAssetPartAssetPartTypeLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(AssetPartAssetPartTypeLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAssetPartAssetPartTypeLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAssetPartAssetPartTypeLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfAssetPartAssetPartTypeLookupTableDto {
    totalCount: number | undefined;
    items: AssetPartAssetPartTypeLookupTableDto[] | undefined;
}

export class AssetPartAssetPartTypeLookupTableDto implements IAssetPartAssetPartTypeLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IAssetPartAssetPartTypeLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): AssetPartAssetPartTypeLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new AssetPartAssetPartTypeLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IAssetPartAssetPartTypeLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfAssetPartAssetPartLookupTableDto implements IPagedResultDtoOfAssetPartAssetPartLookupTableDto {
    totalCount!: number | undefined;
    items!: AssetPartAssetPartLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAssetPartAssetPartLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(AssetPartAssetPartLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAssetPartAssetPartLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAssetPartAssetPartLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfAssetPartAssetPartLookupTableDto {
    totalCount: number | undefined;
    items: AssetPartAssetPartLookupTableDto[] | undefined;
}

export class AssetPartAssetPartLookupTableDto implements IAssetPartAssetPartLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IAssetPartAssetPartLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): AssetPartAssetPartLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new AssetPartAssetPartLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IAssetPartAssetPartLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfAssetPartAssetPartStatusLookupTableDto implements IPagedResultDtoOfAssetPartAssetPartStatusLookupTableDto {
    totalCount!: number | undefined;
    items!: AssetPartAssetPartStatusLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAssetPartAssetPartStatusLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(AssetPartAssetPartStatusLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAssetPartAssetPartStatusLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAssetPartAssetPartStatusLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfAssetPartAssetPartStatusLookupTableDto {
    totalCount: number | undefined;
    items: AssetPartAssetPartStatusLookupTableDto[] | undefined;
}

export class AssetPartAssetPartStatusLookupTableDto implements IAssetPartAssetPartStatusLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IAssetPartAssetPartStatusLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): AssetPartAssetPartStatusLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new AssetPartAssetPartStatusLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IAssetPartAssetPartStatusLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfAssetPartAssetLookupTableDto implements IPagedResultDtoOfAssetPartAssetLookupTableDto {
    totalCount!: number | undefined;
    items!: AssetPartAssetLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAssetPartAssetLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(AssetPartAssetLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAssetPartAssetLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAssetPartAssetLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfAssetPartAssetLookupTableDto {
    totalCount: number | undefined;
    items: AssetPartAssetLookupTableDto[] | undefined;
}

export class AssetPartAssetLookupTableDto implements IAssetPartAssetLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IAssetPartAssetLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): AssetPartAssetLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new AssetPartAssetLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IAssetPartAssetLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfAssetPartItemTypeLookupTableDto implements IPagedResultDtoOfAssetPartItemTypeLookupTableDto {
    totalCount!: number | undefined;
    items!: AssetPartItemTypeLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAssetPartItemTypeLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(AssetPartItemTypeLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAssetPartItemTypeLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAssetPartItemTypeLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfAssetPartItemTypeLookupTableDto {
    totalCount: number | undefined;
    items: AssetPartItemTypeLookupTableDto[] | undefined;
}

export class AssetPartItemTypeLookupTableDto implements IAssetPartItemTypeLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IAssetPartItemTypeLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): AssetPartItemTypeLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new AssetPartItemTypeLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IAssetPartItemTypeLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfAssetPartWarehouseLookupTableDto implements IPagedResultDtoOfAssetPartWarehouseLookupTableDto {
    totalCount!: number | undefined;
    items!: AssetPartWarehouseLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAssetPartWarehouseLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(AssetPartWarehouseLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAssetPartWarehouseLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAssetPartWarehouseLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfAssetPartWarehouseLookupTableDto {
    totalCount: number | undefined;
    items: AssetPartWarehouseLookupTableDto[] | undefined;
}

export class AssetPartWarehouseLookupTableDto implements IAssetPartWarehouseLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IAssetPartWarehouseLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): AssetPartWarehouseLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new AssetPartWarehouseLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IAssetPartWarehouseLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetAssetPartStatusForViewDto implements IPagedResultDtoOfGetAssetPartStatusForViewDto {
    totalCount!: number | undefined;
    items!: GetAssetPartStatusForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetAssetPartStatusForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetAssetPartStatusForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetAssetPartStatusForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetAssetPartStatusForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetAssetPartStatusForViewDto {
    totalCount: number | undefined;
    items: GetAssetPartStatusForViewDto[] | undefined;
}

export class GetAssetPartStatusForViewDto implements IGetAssetPartStatusForViewDto {
    assetPartStatus!: AssetPartStatusDto | undefined;

    constructor(data?: IGetAssetPartStatusForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assetPartStatus = data["assetPartStatus"] ? AssetPartStatusDto.fromJS(data["assetPartStatus"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAssetPartStatusForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAssetPartStatusForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assetPartStatus"] = this.assetPartStatus ? this.assetPartStatus.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetAssetPartStatusForViewDto {
    assetPartStatus: AssetPartStatusDto | undefined;
}

export class AssetPartStatusDto implements IAssetPartStatusDto {
    status!: string | undefined;
    description!: string | undefined;
    id!: number | undefined;

    constructor(data?: IAssetPartStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"];
            this.description = data["description"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AssetPartStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new AssetPartStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }
}

export interface IAssetPartStatusDto {
    status: string | undefined;
    description: string | undefined;
    id: number | undefined;
}

export class GetAssetPartStatusForEditOutput implements IGetAssetPartStatusForEditOutput {
    assetPartStatus!: CreateOrEditAssetPartStatusDto | undefined;

    constructor(data?: IGetAssetPartStatusForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assetPartStatus = data["assetPartStatus"] ? CreateOrEditAssetPartStatusDto.fromJS(data["assetPartStatus"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAssetPartStatusForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAssetPartStatusForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assetPartStatus"] = this.assetPartStatus ? this.assetPartStatus.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetAssetPartStatusForEditOutput {
    assetPartStatus: CreateOrEditAssetPartStatusDto | undefined;
}

export class CreateOrEditAssetPartStatusDto implements ICreateOrEditAssetPartStatusDto {
    status!: string;
    description!: string;
    id!: number | undefined;

    constructor(data?: ICreateOrEditAssetPartStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"];
            this.description = data["description"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditAssetPartStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditAssetPartStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditAssetPartStatusDto {
    status: string;
    description: string;
    id: number | undefined;
}

export class PagedResultDtoOfGetAssetPartTypeForViewDto implements IPagedResultDtoOfGetAssetPartTypeForViewDto {
    totalCount!: number | undefined;
    items!: GetAssetPartTypeForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetAssetPartTypeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetAssetPartTypeForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetAssetPartTypeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetAssetPartTypeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetAssetPartTypeForViewDto {
    totalCount: number | undefined;
    items: GetAssetPartTypeForViewDto[] | undefined;
}

export class GetAssetPartTypeForViewDto implements IGetAssetPartTypeForViewDto {
    assetPartType!: AssetPartTypeDto | undefined;

    constructor(data?: IGetAssetPartTypeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assetPartType = data["assetPartType"] ? AssetPartTypeDto.fromJS(data["assetPartType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAssetPartTypeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAssetPartTypeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assetPartType"] = this.assetPartType ? this.assetPartType.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetAssetPartTypeForViewDto {
    assetPartType: AssetPartTypeDto | undefined;
}

export class AssetPartTypeDto implements IAssetPartTypeDto {
    type!: string | undefined;
    description!: string | undefined;
    id!: number | undefined;

    constructor(data?: IAssetPartTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.type = data["type"];
            this.description = data["description"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AssetPartTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new AssetPartTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }
}

export interface IAssetPartTypeDto {
    type: string | undefined;
    description: string | undefined;
    id: number | undefined;
}

export class GetAssetPartTypeForEditOutput implements IGetAssetPartTypeForEditOutput {
    assetPartType!: CreateOrEditAssetPartTypeDto | undefined;

    constructor(data?: IGetAssetPartTypeForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assetPartType = data["assetPartType"] ? CreateOrEditAssetPartTypeDto.fromJS(data["assetPartType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAssetPartTypeForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAssetPartTypeForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assetPartType"] = this.assetPartType ? this.assetPartType.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetAssetPartTypeForEditOutput {
    assetPartType: CreateOrEditAssetPartTypeDto | undefined;
}

export class CreateOrEditAssetPartTypeDto implements ICreateOrEditAssetPartTypeDto {
    type!: string;
    description!: string;
    id!: number | undefined;

    constructor(data?: ICreateOrEditAssetPartTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.type = data["type"];
            this.description = data["description"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditAssetPartTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditAssetPartTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditAssetPartTypeDto {
    type: string;
    description: string;
    id: number | undefined;
}

export class PagedResultDtoOfGetAssetForViewDto implements IPagedResultDtoOfGetAssetForViewDto {
    totalCount!: number | undefined;
    items!: GetAssetForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetAssetForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetAssetForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetAssetForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetAssetForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetAssetForViewDto {
    totalCount: number | undefined;
    items: GetAssetForViewDto[] | undefined;
}

export class GetAssetForViewDto implements IGetAssetForViewDto {
    asset!: AssetDto | undefined;
    assetClassClass!: string | undefined;
    assetStatusStatus!: string | undefined;

    constructor(data?: IGetAssetForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.asset = data["asset"] ? AssetDto.fromJS(data["asset"]) : <any>undefined;
            this.assetClassClass = data["assetClassClass"];
            this.assetStatusStatus = data["assetStatusStatus"];
        }
    }

    static fromJS(data: any): GetAssetForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAssetForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["asset"] = this.asset ? this.asset.toJSON() : <any>undefined;
        data["assetClassClass"] = this.assetClassClass;
        data["assetStatusStatus"] = this.assetStatusStatus;
        return data; 
    }
}

export interface IGetAssetForViewDto {
    asset: AssetDto | undefined;
    assetClassClass: string | undefined;
    assetStatusStatus: string | undefined;
}

export class AssetDto implements IAssetDto {
    reference!: string | undefined;
    vehicleRegistrationNo!: string | undefined;
    isExternalAsset!: boolean | undefined;
    location!: string | undefined;
    serialNumber!: string | undefined;
    engineNo!: string | undefined;
    chassisNo!: string | undefined;
    description!: string | undefined;
    purchaseOrderNo!: string | undefined;
    purchaseDate!: moment.Moment | undefined;
    purchaseCost!: number | undefined;
    assetLoc8GUID!: string | undefined;
    assetClassId!: number | undefined;
    assetStatusId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IAssetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reference = data["reference"];
            this.vehicleRegistrationNo = data["vehicleRegistrationNo"];
            this.isExternalAsset = data["isExternalAsset"];
            this.location = data["location"];
            this.serialNumber = data["serialNumber"];
            this.engineNo = data["engineNo"];
            this.chassisNo = data["chassisNo"];
            this.description = data["description"];
            this.purchaseOrderNo = data["purchaseOrderNo"];
            this.purchaseDate = data["purchaseDate"] ? moment(data["purchaseDate"].toString()) : <any>undefined;
            this.purchaseCost = data["purchaseCost"];
            this.assetLoc8GUID = data["assetLoc8GUID"];
            this.assetClassId = data["assetClassId"];
            this.assetStatusId = data["assetStatusId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AssetDto {
        data = typeof data === 'object' ? data : {};
        let result = new AssetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reference"] = this.reference;
        data["vehicleRegistrationNo"] = this.vehicleRegistrationNo;
        data["isExternalAsset"] = this.isExternalAsset;
        data["location"] = this.location;
        data["serialNumber"] = this.serialNumber;
        data["engineNo"] = this.engineNo;
        data["chassisNo"] = this.chassisNo;
        data["description"] = this.description;
        data["purchaseOrderNo"] = this.purchaseOrderNo;
        data["purchaseDate"] = this.purchaseDate ? this.purchaseDate.toISOString() : <any>undefined;
        data["purchaseCost"] = this.purchaseCost;
        data["assetLoc8GUID"] = this.assetLoc8GUID;
        data["assetClassId"] = this.assetClassId;
        data["assetStatusId"] = this.assetStatusId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IAssetDto {
    reference: string | undefined;
    vehicleRegistrationNo: string | undefined;
    isExternalAsset: boolean | undefined;
    location: string | undefined;
    serialNumber: string | undefined;
    engineNo: string | undefined;
    chassisNo: string | undefined;
    description: string | undefined;
    purchaseOrderNo: string | undefined;
    purchaseDate: moment.Moment | undefined;
    purchaseCost: number | undefined;
    assetLoc8GUID: string | undefined;
    assetClassId: number | undefined;
    assetStatusId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfGetUsageMetricRecordForViewDto implements IPagedResultDtoOfGetUsageMetricRecordForViewDto {
    totalCount!: number | undefined;
    items!: GetUsageMetricRecordForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetUsageMetricRecordForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetUsageMetricRecordForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetUsageMetricRecordForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetUsageMetricRecordForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetUsageMetricRecordForViewDto {
    totalCount: number | undefined;
    items: GetUsageMetricRecordForViewDto[] | undefined;
}

export class GetUsageMetricRecordForViewDto implements IGetUsageMetricRecordForViewDto {
    usageMetricRecord!: UsageMetricRecordDto | undefined;
    usageMetricMetric!: string | undefined;

    constructor(data?: IGetUsageMetricRecordForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.usageMetricRecord = data["usageMetricRecord"] ? UsageMetricRecordDto.fromJS(data["usageMetricRecord"]) : <any>undefined;
            this.usageMetricMetric = data["usageMetricMetric"];
        }
    }

    static fromJS(data: any): GetUsageMetricRecordForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetUsageMetricRecordForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["usageMetricRecord"] = this.usageMetricRecord ? this.usageMetricRecord.toJSON() : <any>undefined;
        data["usageMetricMetric"] = this.usageMetricMetric;
        return data; 
    }
}

export interface IGetUsageMetricRecordForViewDto {
    usageMetricRecord: UsageMetricRecordDto | undefined;
    usageMetricMetric: string | undefined;
}

export class UsageMetricRecordDto implements IUsageMetricRecordDto {
    reference!: string | undefined;
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;
    unitsConsumed!: number | undefined;
    usageMetricId!: number | undefined;
    lastModificationTime!: moment.Moment | undefined;
    id!: number | undefined;

    constructor(data?: IUsageMetricRecordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reference = data["reference"];
            this.startTime = data["startTime"] ? moment(data["startTime"].toString()) : <any>undefined;
            this.endTime = data["endTime"] ? moment(data["endTime"].toString()) : <any>undefined;
            this.unitsConsumed = data["unitsConsumed"];
            this.usageMetricId = data["usageMetricId"];
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UsageMetricRecordDto {
        data = typeof data === 'object' ? data : {};
        let result = new UsageMetricRecordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reference"] = this.reference;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["unitsConsumed"] = this.unitsConsumed;
        data["usageMetricId"] = this.usageMetricId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUsageMetricRecordDto {
    reference: string | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    unitsConsumed: number | undefined;
    usageMetricId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    id: number | undefined;
}

export class GetAssetsWithWorkordersForViewDto implements IGetAssetsWithWorkordersForViewDto {
    asset!: AssetDto | undefined;
    workorders!: number | undefined;

    constructor(data?: IGetAssetsWithWorkordersForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.asset = data["asset"] ? AssetDto.fromJS(data["asset"]) : <any>undefined;
            this.workorders = data["workorders"];
        }
    }

    static fromJS(data: any): GetAssetsWithWorkordersForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAssetsWithWorkordersForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["asset"] = this.asset ? this.asset.toJSON() : <any>undefined;
        data["workorders"] = this.workorders;
        return data; 
    }
}

export interface IGetAssetsWithWorkordersForViewDto {
    asset: AssetDto | undefined;
    workorders: number | undefined;
}

export class GetAssetForEditOutput implements IGetAssetForEditOutput {
    asset!: CreateOrEditAssetDto | undefined;
    assetClassClass!: string | undefined;
    assetStatusStatus!: string | undefined;

    constructor(data?: IGetAssetForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.asset = data["asset"] ? CreateOrEditAssetDto.fromJS(data["asset"]) : <any>undefined;
            this.assetClassClass = data["assetClassClass"];
            this.assetStatusStatus = data["assetStatusStatus"];
        }
    }

    static fromJS(data: any): GetAssetForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAssetForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["asset"] = this.asset ? this.asset.toJSON() : <any>undefined;
        data["assetClassClass"] = this.assetClassClass;
        data["assetStatusStatus"] = this.assetStatusStatus;
        return data; 
    }
}

export interface IGetAssetForEditOutput {
    asset: CreateOrEditAssetDto | undefined;
    assetClassClass: string | undefined;
    assetStatusStatus: string | undefined;
}

export class CreateOrEditAssetDto implements ICreateOrEditAssetDto {
    reference!: string;
    vehicleRegistrationNo!: string | undefined;
    isExternalAsset!: boolean | undefined;
    location!: string | undefined;
    serialNumber!: string | undefined;
    engineNo!: string | undefined;
    chassisNo!: string | undefined;
    description!: string;
    purchaseOrderNo!: string | undefined;
    purchaseDate!: moment.Moment | undefined;
    purchaseCost!: number | undefined;
    assetLoc8GUID!: string | undefined;
    assetClassId!: number | undefined;
    assetStatusId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditAssetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reference = data["reference"];
            this.vehicleRegistrationNo = data["vehicleRegistrationNo"];
            this.isExternalAsset = data["isExternalAsset"];
            this.location = data["location"];
            this.serialNumber = data["serialNumber"];
            this.engineNo = data["engineNo"];
            this.chassisNo = data["chassisNo"];
            this.description = data["description"];
            this.purchaseOrderNo = data["purchaseOrderNo"];
            this.purchaseDate = data["purchaseDate"] ? moment(data["purchaseDate"].toString()) : <any>undefined;
            this.purchaseCost = data["purchaseCost"];
            this.assetLoc8GUID = data["assetLoc8GUID"];
            this.assetClassId = data["assetClassId"];
            this.assetStatusId = data["assetStatusId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditAssetDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditAssetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reference"] = this.reference;
        data["vehicleRegistrationNo"] = this.vehicleRegistrationNo;
        data["isExternalAsset"] = this.isExternalAsset;
        data["location"] = this.location;
        data["serialNumber"] = this.serialNumber;
        data["engineNo"] = this.engineNo;
        data["chassisNo"] = this.chassisNo;
        data["description"] = this.description;
        data["purchaseOrderNo"] = this.purchaseOrderNo;
        data["purchaseDate"] = this.purchaseDate ? this.purchaseDate.toISOString() : <any>undefined;
        data["purchaseCost"] = this.purchaseCost;
        data["assetLoc8GUID"] = this.assetLoc8GUID;
        data["assetClassId"] = this.assetClassId;
        data["assetStatusId"] = this.assetStatusId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditAssetDto {
    reference: string;
    vehicleRegistrationNo: string | undefined;
    isExternalAsset: boolean | undefined;
    location: string | undefined;
    serialNumber: string | undefined;
    engineNo: string | undefined;
    chassisNo: string | undefined;
    description: string;
    purchaseOrderNo: string | undefined;
    purchaseDate: moment.Moment | undefined;
    purchaseCost: number | undefined;
    assetLoc8GUID: string | undefined;
    assetClassId: number | undefined;
    assetStatusId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfAssetAssetClassLookupTableDto implements IPagedResultDtoOfAssetAssetClassLookupTableDto {
    totalCount!: number | undefined;
    items!: AssetAssetClassLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAssetAssetClassLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(AssetAssetClassLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAssetAssetClassLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAssetAssetClassLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfAssetAssetClassLookupTableDto {
    totalCount: number | undefined;
    items: AssetAssetClassLookupTableDto[] | undefined;
}

export class AssetAssetClassLookupTableDto implements IAssetAssetClassLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IAssetAssetClassLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): AssetAssetClassLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new AssetAssetClassLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IAssetAssetClassLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfAssetAssetStatusLookupTableDto implements IPagedResultDtoOfAssetAssetStatusLookupTableDto {
    totalCount!: number | undefined;
    items!: AssetAssetStatusLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAssetAssetStatusLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(AssetAssetStatusLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAssetAssetStatusLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAssetAssetStatusLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfAssetAssetStatusLookupTableDto {
    totalCount: number | undefined;
    items: AssetAssetStatusLookupTableDto[] | undefined;
}

export class AssetAssetStatusLookupTableDto implements IAssetAssetStatusLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IAssetAssetStatusLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): AssetAssetStatusLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new AssetAssetStatusLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IAssetAssetStatusLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfLocationLookupTableDto implements IPagedResultDtoOfLocationLookupTableDto {
    totalCount!: number | undefined;
    items!: LocationLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfLocationLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(LocationLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLocationLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfLocationLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfLocationLookupTableDto {
    totalCount: number | undefined;
    items: LocationLookupTableDto[] | undefined;
}

export class LocationLookupTableDto implements ILocationLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: ILocationLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): LocationLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocationLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface ILocationLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetLeaseItemForViewDto implements IPagedResultDtoOfGetLeaseItemForViewDto {
    totalCount!: number | undefined;
    items!: GetLeaseItemForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetLeaseItemForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetLeaseItemForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetLeaseItemForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetLeaseItemForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetLeaseItemForViewDto {
    totalCount: number | undefined;
    items: GetLeaseItemForViewDto[] | undefined;
}

export class GetLeaseItemForViewDto implements IGetLeaseItemForViewDto {
    leaseItem!: LeaseItemDto | undefined;
    assetClassClass!: string | undefined;
    assetReference!: string | undefined;
    leaseAgreementTitle!: string | undefined;
    depositUom!: string | undefined;
    rentalUom!: string | undefined;

    constructor(data?: IGetLeaseItemForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.leaseItem = data["leaseItem"] ? LeaseItemDto.fromJS(data["leaseItem"]) : <any>undefined;
            this.assetClassClass = data["assetClassClass"];
            this.assetReference = data["assetReference"];
            this.leaseAgreementTitle = data["leaseAgreementTitle"];
            this.depositUom = data["depositUom"];
            this.rentalUom = data["rentalUom"];
        }
    }

    static fromJS(data: any): GetLeaseItemForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetLeaseItemForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["leaseItem"] = this.leaseItem ? this.leaseItem.toJSON() : <any>undefined;
        data["assetClassClass"] = this.assetClassClass;
        data["assetReference"] = this.assetReference;
        data["leaseAgreementTitle"] = this.leaseAgreementTitle;
        data["depositUom"] = this.depositUom;
        data["rentalUom"] = this.rentalUom;
        return data; 
    }
}

export interface IGetLeaseItemForViewDto {
    leaseItem: LeaseItemDto | undefined;
    assetClassClass: string | undefined;
    assetReference: string | undefined;
    leaseAgreementTitle: string | undefined;
    depositUom: string | undefined;
    rentalUom: string | undefined;
}

export class LeaseItemDto implements ILeaseItemDto {
    dateAllocated!: moment.Moment | undefined;
    allocationPercentage!: number | undefined;
    terms!: string | undefined;
    unitRentalRate!: number | undefined;
    unitDepositRate!: number | undefined;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    rentalUomRefId!: number | undefined;
    depositUomRefId!: number | undefined;
    item!: string | undefined;
    description!: string | undefined;
    assetClassId!: number | undefined;
    assetId!: number | undefined;
    leaseAgreementId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ILeaseItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dateAllocated = data["dateAllocated"] ? moment(data["dateAllocated"].toString()) : <any>undefined;
            this.allocationPercentage = data["allocationPercentage"];
            this.terms = data["terms"];
            this.unitRentalRate = data["unitRentalRate"];
            this.unitDepositRate = data["unitDepositRate"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.rentalUomRefId = data["rentalUomRefId"];
            this.depositUomRefId = data["depositUomRefId"];
            this.item = data["item"];
            this.description = data["description"];
            this.assetClassId = data["assetClassId"];
            this.assetId = data["assetId"];
            this.leaseAgreementId = data["leaseAgreementId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): LeaseItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new LeaseItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dateAllocated"] = this.dateAllocated ? this.dateAllocated.toISOString() : <any>undefined;
        data["allocationPercentage"] = this.allocationPercentage;
        data["terms"] = this.terms;
        data["unitRentalRate"] = this.unitRentalRate;
        data["unitDepositRate"] = this.unitDepositRate;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["rentalUomRefId"] = this.rentalUomRefId;
        data["depositUomRefId"] = this.depositUomRefId;
        data["item"] = this.item;
        data["description"] = this.description;
        data["assetClassId"] = this.assetClassId;
        data["assetId"] = this.assetId;
        data["leaseAgreementId"] = this.leaseAgreementId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ILeaseItemDto {
    dateAllocated: moment.Moment | undefined;
    allocationPercentage: number | undefined;
    terms: string | undefined;
    unitRentalRate: number | undefined;
    unitDepositRate: number | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    rentalUomRefId: number | undefined;
    depositUomRefId: number | undefined;
    item: string | undefined;
    description: string | undefined;
    assetClassId: number | undefined;
    assetId: number | undefined;
    leaseAgreementId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfGetSupportItemForViewDto implements IPagedResultDtoOfGetSupportItemForViewDto {
    totalCount!: number | undefined;
    items!: GetSupportItemForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetSupportItemForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetSupportItemForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetSupportItemForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetSupportItemForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetSupportItemForViewDto {
    totalCount: number | undefined;
    items: GetSupportItemForViewDto[] | undefined;
}

export class GetSupportItemForViewDto implements IGetSupportItemForViewDto {
    supportItem!: SupportItemDto | undefined;
    assetReference!: string | undefined;
    assetClassClass!: string | undefined;
    uomUnitOfMeasurement!: string | undefined;
    supportContractTitle!: string | undefined;
    consumableTypeType!: string | undefined;
    supportTypeType!: string | undefined;

    constructor(data?: IGetSupportItemForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.supportItem = data["supportItem"] ? SupportItemDto.fromJS(data["supportItem"]) : <any>undefined;
            this.assetReference = data["assetReference"];
            this.assetClassClass = data["assetClassClass"];
            this.uomUnitOfMeasurement = data["uomUnitOfMeasurement"];
            this.supportContractTitle = data["supportContractTitle"];
            this.consumableTypeType = data["consumableTypeType"];
            this.supportTypeType = data["supportTypeType"];
        }
    }

    static fromJS(data: any): GetSupportItemForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetSupportItemForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["supportItem"] = this.supportItem ? this.supportItem.toJSON() : <any>undefined;
        data["assetReference"] = this.assetReference;
        data["assetClassClass"] = this.assetClassClass;
        data["uomUnitOfMeasurement"] = this.uomUnitOfMeasurement;
        data["supportContractTitle"] = this.supportContractTitle;
        data["consumableTypeType"] = this.consumableTypeType;
        data["supportTypeType"] = this.supportTypeType;
        return data; 
    }
}

export interface IGetSupportItemForViewDto {
    supportItem: SupportItemDto | undefined;
    assetReference: string | undefined;
    assetClassClass: string | undefined;
    uomUnitOfMeasurement: string | undefined;
    supportContractTitle: string | undefined;
    consumableTypeType: string | undefined;
    supportTypeType: string | undefined;
}

export class SupportItemDto implements ISupportItemDto {
    description!: string | undefined;
    unitPrice!: number | undefined;
    frequency!: number | undefined;
    isAdHoc!: boolean | undefined;
    isChargeable!: boolean | undefined;
    isStandbyReplacementUnit!: boolean | undefined;
    assetId!: number | undefined;
    assetClassId!: number | undefined;
    uomId!: number | undefined;
    supportContractId!: number | undefined;
    consumableTypeId!: number | undefined;
    supportTypeId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ISupportItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.description = data["description"];
            this.unitPrice = data["unitPrice"];
            this.frequency = data["frequency"];
            this.isAdHoc = data["isAdHoc"];
            this.isChargeable = data["isChargeable"];
            this.isStandbyReplacementUnit = data["isStandbyReplacementUnit"];
            this.assetId = data["assetId"];
            this.assetClassId = data["assetClassId"];
            this.uomId = data["uomId"];
            this.supportContractId = data["supportContractId"];
            this.consumableTypeId = data["consumableTypeId"];
            this.supportTypeId = data["supportTypeId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SupportItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new SupportItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["unitPrice"] = this.unitPrice;
        data["frequency"] = this.frequency;
        data["isAdHoc"] = this.isAdHoc;
        data["isChargeable"] = this.isChargeable;
        data["isStandbyReplacementUnit"] = this.isStandbyReplacementUnit;
        data["assetId"] = this.assetId;
        data["assetClassId"] = this.assetClassId;
        data["uomId"] = this.uomId;
        data["supportContractId"] = this.supportContractId;
        data["consumableTypeId"] = this.consumableTypeId;
        data["supportTypeId"] = this.supportTypeId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISupportItemDto {
    description: string | undefined;
    unitPrice: number | undefined;
    frequency: number | undefined;
    isAdHoc: boolean | undefined;
    isChargeable: boolean | undefined;
    isStandbyReplacementUnit: boolean | undefined;
    assetId: number | undefined;
    assetClassId: number | undefined;
    uomId: number | undefined;
    supportContractId: number | undefined;
    consumableTypeId: number | undefined;
    supportTypeId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfGetWorkOrderForViewDto implements IPagedResultDtoOfGetWorkOrderForViewDto {
    totalCount!: number | undefined;
    items!: GetWorkOrderForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetWorkOrderForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetWorkOrderForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetWorkOrderForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetWorkOrderForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetWorkOrderForViewDto {
    totalCount: number | undefined;
    items: GetWorkOrderForViewDto[] | undefined;
}

export class GetWorkOrderForViewDto implements IGetWorkOrderForViewDto {
    workOrder!: WorkOrderDto | undefined;
    workOrderPriorityPriority!: string | undefined;
    workOrderTypeType!: string | undefined;
    vendorName!: string | undefined;
    incidentDescription!: string | undefined;
    supportItemDescription!: string | undefined;
    userName!: string | undefined;
    customerName!: string | undefined;
    customerXeroContactId!: string | undefined;
    assetOwnershipAssetDisplayName!: string | undefined;
    workOrderStatusStatus!: string | undefined;
    assetId!: number | undefined;
    leaseItemId!: number | undefined;
    leaseItemName!: string | undefined;

    constructor(data?: IGetWorkOrderForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.workOrder = data["workOrder"] ? WorkOrderDto.fromJS(data["workOrder"]) : <any>undefined;
            this.workOrderPriorityPriority = data["workOrderPriorityPriority"];
            this.workOrderTypeType = data["workOrderTypeType"];
            this.vendorName = data["vendorName"];
            this.incidentDescription = data["incidentDescription"];
            this.supportItemDescription = data["supportItemDescription"];
            this.userName = data["userName"];
            this.customerName = data["customerName"];
            this.customerXeroContactId = data["customerXeroContactId"];
            this.assetOwnershipAssetDisplayName = data["assetOwnershipAssetDisplayName"];
            this.workOrderStatusStatus = data["workOrderStatusStatus"];
            this.assetId = data["assetId"];
            this.leaseItemId = data["leaseItemId"];
            this.leaseItemName = data["leaseItemName"];
        }
    }

    static fromJS(data: any): GetWorkOrderForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetWorkOrderForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workOrder"] = this.workOrder ? this.workOrder.toJSON() : <any>undefined;
        data["workOrderPriorityPriority"] = this.workOrderPriorityPriority;
        data["workOrderTypeType"] = this.workOrderTypeType;
        data["vendorName"] = this.vendorName;
        data["incidentDescription"] = this.incidentDescription;
        data["supportItemDescription"] = this.supportItemDescription;
        data["userName"] = this.userName;
        data["customerName"] = this.customerName;
        data["customerXeroContactId"] = this.customerXeroContactId;
        data["assetOwnershipAssetDisplayName"] = this.assetOwnershipAssetDisplayName;
        data["workOrderStatusStatus"] = this.workOrderStatusStatus;
        data["assetId"] = this.assetId;
        data["leaseItemId"] = this.leaseItemId;
        data["leaseItemName"] = this.leaseItemName;
        return data; 
    }
}

export interface IGetWorkOrderForViewDto {
    workOrder: WorkOrderDto | undefined;
    workOrderPriorityPriority: string | undefined;
    workOrderTypeType: string | undefined;
    vendorName: string | undefined;
    incidentDescription: string | undefined;
    supportItemDescription: string | undefined;
    userName: string | undefined;
    customerName: string | undefined;
    customerXeroContactId: string | undefined;
    assetOwnershipAssetDisplayName: string | undefined;
    workOrderStatusStatus: string | undefined;
    assetId: number | undefined;
    leaseItemId: number | undefined;
    leaseItemName: string | undefined;
}

export class WorkOrderDto implements IWorkOrderDto {
    loc8GUID!: string | undefined;
    subject!: string | undefined;
    description!: string | undefined;
    location!: string | undefined;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    remarks!: string | undefined;
    attachments!: string | undefined;
    workOrderPriorityId!: number | undefined;
    workOrderTypeId!: number | undefined;
    vendorId!: number | undefined;
    incidentId!: number | undefined;
    supportItemId!: number | undefined;
    userId!: number | undefined;
    customerId!: number | undefined;
    assetOwnershipId!: number | undefined;
    workOrderStatusId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IWorkOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.loc8GUID = data["loc8GUID"];
            this.subject = data["subject"];
            this.description = data["description"];
            this.location = data["location"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.remarks = data["remarks"];
            this.attachments = data["attachments"];
            this.workOrderPriorityId = data["workOrderPriorityId"];
            this.workOrderTypeId = data["workOrderTypeId"];
            this.vendorId = data["vendorId"];
            this.incidentId = data["incidentId"];
            this.supportItemId = data["supportItemId"];
            this.userId = data["userId"];
            this.customerId = data["customerId"];
            this.assetOwnershipId = data["assetOwnershipId"];
            this.workOrderStatusId = data["workOrderStatusId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): WorkOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["loc8GUID"] = this.loc8GUID;
        data["subject"] = this.subject;
        data["description"] = this.description;
        data["location"] = this.location;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["remarks"] = this.remarks;
        data["attachments"] = this.attachments;
        data["workOrderPriorityId"] = this.workOrderPriorityId;
        data["workOrderTypeId"] = this.workOrderTypeId;
        data["vendorId"] = this.vendorId;
        data["incidentId"] = this.incidentId;
        data["supportItemId"] = this.supportItemId;
        data["userId"] = this.userId;
        data["customerId"] = this.customerId;
        data["assetOwnershipId"] = this.assetOwnershipId;
        data["workOrderStatusId"] = this.workOrderStatusId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IWorkOrderDto {
    loc8GUID: string | undefined;
    subject: string | undefined;
    description: string | undefined;
    location: string | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    remarks: string | undefined;
    attachments: string | undefined;
    workOrderPriorityId: number | undefined;
    workOrderTypeId: number | undefined;
    vendorId: number | undefined;
    incidentId: number | undefined;
    supportItemId: number | undefined;
    userId: number | undefined;
    customerId: number | undefined;
    assetOwnershipId: number | undefined;
    workOrderStatusId: number | undefined;
    id: number | undefined;
}

export class UsageMetricsChartOutput implements IUsageMetricsChartOutput {
    chartInfo!: UsageMetricsChartInfo[] | undefined;
    chartData!: UsageMetricsChartData[] | undefined;

    constructor(data?: IUsageMetricsChartOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["chartInfo"])) {
                this.chartInfo = [] as any;
                for (let item of data["chartInfo"])
                    this.chartInfo!.push(UsageMetricsChartInfo.fromJS(item));
            }
            if (Array.isArray(data["chartData"])) {
                this.chartData = [] as any;
                for (let item of data["chartData"])
                    this.chartData!.push(UsageMetricsChartData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UsageMetricsChartOutput {
        data = typeof data === 'object' ? data : {};
        let result = new UsageMetricsChartOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.chartInfo)) {
            data["chartInfo"] = [];
            for (let item of this.chartInfo)
                data["chartInfo"].push(item.toJSON());
        }
        if (Array.isArray(this.chartData)) {
            data["chartData"] = [];
            for (let item of this.chartData)
                data["chartData"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUsageMetricsChartOutput {
    chartInfo: UsageMetricsChartInfo[] | undefined;
    chartData: UsageMetricsChartData[] | undefined;
}

export class UsageMetricsChartInfo implements IUsageMetricsChartInfo {
    usageMetricDto!: GetUsageMetricForViewDto | undefined;
    chartName!: string | undefined;
    total!: string | undefined;
    dailyAvg!: string | undefined;

    constructor(data?: IUsageMetricsChartInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.usageMetricDto = data["usageMetricDto"] ? GetUsageMetricForViewDto.fromJS(data["usageMetricDto"]) : <any>undefined;
            this.chartName = data["chartName"];
            this.total = data["total"];
            this.dailyAvg = data["dailyAvg"];
        }
    }

    static fromJS(data: any): UsageMetricsChartInfo {
        data = typeof data === 'object' ? data : {};
        let result = new UsageMetricsChartInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["usageMetricDto"] = this.usageMetricDto ? this.usageMetricDto.toJSON() : <any>undefined;
        data["chartName"] = this.chartName;
        data["total"] = this.total;
        data["dailyAvg"] = this.dailyAvg;
        return data; 
    }
}

export interface IUsageMetricsChartInfo {
    usageMetricDto: GetUsageMetricForViewDto | undefined;
    chartName: string | undefined;
    total: string | undefined;
    dailyAvg: string | undefined;
}

export class UsageMetricsChartData implements IUsageMetricsChartData {
    period!: string | undefined;
    value!: number | undefined;

    constructor(data?: IUsageMetricsChartData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.period = data["period"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): UsageMetricsChartData {
        data = typeof data === 'object' ? data : {};
        let result = new UsageMetricsChartData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["period"] = this.period;
        data["value"] = this.value;
        return data; 
    }
}

export interface IUsageMetricsChartData {
    period: string | undefined;
    value: number | undefined;
}

export class GetUsageMetricForViewDto implements IGetUsageMetricForViewDto {
    usageMetric!: UsageMetricDto | undefined;
    leaseItemItem!: string | undefined;
    assetReference!: string | undefined;
    uomUnitOfMeasurement!: string | undefined;
    needRecordUpdate!: boolean | undefined;

    constructor(data?: IGetUsageMetricForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.usageMetric = data["usageMetric"] ? UsageMetricDto.fromJS(data["usageMetric"]) : <any>undefined;
            this.leaseItemItem = data["leaseItemItem"];
            this.assetReference = data["assetReference"];
            this.uomUnitOfMeasurement = data["uomUnitOfMeasurement"];
            this.needRecordUpdate = data["needRecordUpdate"];
        }
    }

    static fromJS(data: any): GetUsageMetricForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetUsageMetricForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["usageMetric"] = this.usageMetric ? this.usageMetric.toJSON() : <any>undefined;
        data["leaseItemItem"] = this.leaseItemItem;
        data["assetReference"] = this.assetReference;
        data["uomUnitOfMeasurement"] = this.uomUnitOfMeasurement;
        data["needRecordUpdate"] = this.needRecordUpdate;
        return data; 
    }
}

export interface IGetUsageMetricForViewDto {
    usageMetric: UsageMetricDto | undefined;
    leaseItemItem: string | undefined;
    assetReference: string | undefined;
    uomUnitOfMeasurement: string | undefined;
    needRecordUpdate: boolean | undefined;
}

export class UsageMetricDto implements IUsageMetricDto {
    metric!: string | undefined;
    description!: string | undefined;
    leaseItemId!: number | undefined;
    assetId!: number | undefined;
    uomId!: number | undefined;
    lastModificationTime!: moment.Moment | undefined;
    id!: number | undefined;

    constructor(data?: IUsageMetricDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.metric = data["metric"];
            this.description = data["description"];
            this.leaseItemId = data["leaseItemId"];
            this.assetId = data["assetId"];
            this.uomId = data["uomId"];
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UsageMetricDto {
        data = typeof data === 'object' ? data : {};
        let result = new UsageMetricDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["metric"] = this.metric;
        data["description"] = this.description;
        data["leaseItemId"] = this.leaseItemId;
        data["assetId"] = this.assetId;
        data["uomId"] = this.uomId;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUsageMetricDto {
    metric: string | undefined;
    description: string | undefined;
    leaseItemId: number | undefined;
    assetId: number | undefined;
    uomId: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfGetAssetStatusForViewDto implements IPagedResultDtoOfGetAssetStatusForViewDto {
    totalCount!: number | undefined;
    items!: GetAssetStatusForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetAssetStatusForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetAssetStatusForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetAssetStatusForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetAssetStatusForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetAssetStatusForViewDto {
    totalCount: number | undefined;
    items: GetAssetStatusForViewDto[] | undefined;
}

export class GetAssetStatusForViewDto implements IGetAssetStatusForViewDto {
    assetStatus!: AssetStatusDto | undefined;

    constructor(data?: IGetAssetStatusForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assetStatus = data["assetStatus"] ? AssetStatusDto.fromJS(data["assetStatus"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAssetStatusForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAssetStatusForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assetStatus"] = this.assetStatus ? this.assetStatus.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetAssetStatusForViewDto {
    assetStatus: AssetStatusDto | undefined;
}

export class AssetStatusDto implements IAssetStatusDto {
    status!: string | undefined;
    description!: string | undefined;
    id!: number | undefined;

    constructor(data?: IAssetStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"];
            this.description = data["description"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AssetStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new AssetStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }
}

export interface IAssetStatusDto {
    status: string | undefined;
    description: string | undefined;
    id: number | undefined;
}

export class GetAssetStatusForEditOutput implements IGetAssetStatusForEditOutput {
    assetStatus!: CreateOrEditAssetStatusDto | undefined;

    constructor(data?: IGetAssetStatusForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assetStatus = data["assetStatus"] ? CreateOrEditAssetStatusDto.fromJS(data["assetStatus"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAssetStatusForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAssetStatusForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assetStatus"] = this.assetStatus ? this.assetStatus.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetAssetStatusForEditOutput {
    assetStatus: CreateOrEditAssetStatusDto | undefined;
}

export class CreateOrEditAssetStatusDto implements ICreateOrEditAssetStatusDto {
    status!: string;
    description!: string;
    id!: number | undefined;

    constructor(data?: ICreateOrEditAssetStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"];
            this.description = data["description"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditAssetStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditAssetStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditAssetStatusDto {
    status: string;
    description: string;
    id: number | undefined;
}

export class PagedResultDtoOfGetAssetTypeForViewDto implements IPagedResultDtoOfGetAssetTypeForViewDto {
    totalCount!: number | undefined;
    items!: GetAssetTypeForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetAssetTypeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetAssetTypeForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetAssetTypeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetAssetTypeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetAssetTypeForViewDto {
    totalCount: number | undefined;
    items: GetAssetTypeForViewDto[] | undefined;
}

export class GetAssetTypeForViewDto implements IGetAssetTypeForViewDto {
    assetType!: AssetTypeDto | undefined;

    constructor(data?: IGetAssetTypeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assetType = data["assetType"] ? AssetTypeDto.fromJS(data["assetType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAssetTypeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAssetTypeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assetType"] = this.assetType ? this.assetType.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetAssetTypeForViewDto {
    assetType: AssetTypeDto | undefined;
}

export class AssetTypeDto implements IAssetTypeDto {
    code!: string | undefined;
    type!: string | undefined;
    description!: string | undefined;
    sort!: number | undefined;
    id!: number | undefined;

    constructor(data?: IAssetTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.type = data["type"];
            this.description = data["description"];
            this.sort = data["sort"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AssetTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new AssetTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["type"] = this.type;
        data["description"] = this.description;
        data["sort"] = this.sort;
        data["id"] = this.id;
        return data; 
    }
}

export interface IAssetTypeDto {
    code: string | undefined;
    type: string | undefined;
    description: string | undefined;
    sort: number | undefined;
    id: number | undefined;
}

export class GetAssetTypeForEditOutput implements IGetAssetTypeForEditOutput {
    assetType!: CreateOrEditAssetTypeDto | undefined;

    constructor(data?: IGetAssetTypeForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assetType = data["assetType"] ? CreateOrEditAssetTypeDto.fromJS(data["assetType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAssetTypeForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAssetTypeForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assetType"] = this.assetType ? this.assetType.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetAssetTypeForEditOutput {
    assetType: CreateOrEditAssetTypeDto | undefined;
}

export class CreateOrEditAssetTypeDto implements ICreateOrEditAssetTypeDto {
    code!: string;
    type!: string;
    description!: string;
    sort!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditAssetTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.type = data["type"];
            this.description = data["description"];
            this.sort = data["sort"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditAssetTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditAssetTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["type"] = this.type;
        data["description"] = this.description;
        data["sort"] = this.sort;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditAssetTypeDto {
    code: string;
    type: string;
    description: string;
    sort: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfGetAttachmentForViewDto implements IPagedResultDtoOfGetAttachmentForViewDto {
    totalCount!: number | undefined;
    items!: GetAttachmentForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetAttachmentForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetAttachmentForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetAttachmentForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetAttachmentForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetAttachmentForViewDto {
    totalCount: number | undefined;
    items: GetAttachmentForViewDto[] | undefined;
}

export class GetAttachmentForViewDto implements IGetAttachmentForViewDto {
    attachment!: AttachmentDto | undefined;
    assetReference!: string | undefined;
    incidentDescription!: string | undefined;
    leaseAgreementReference!: string | undefined;
    quotationTitle!: string | undefined;
    supportContractTitle!: string | undefined;
    workOrderSubject!: string | undefined;
    customerInvoiceDescription!: string | undefined;
    uploadedByName!: string | undefined;

    constructor(data?: IGetAttachmentForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.attachment = data["attachment"] ? AttachmentDto.fromJS(data["attachment"]) : <any>undefined;
            this.assetReference = data["assetReference"];
            this.incidentDescription = data["incidentDescription"];
            this.leaseAgreementReference = data["leaseAgreementReference"];
            this.quotationTitle = data["quotationTitle"];
            this.supportContractTitle = data["supportContractTitle"];
            this.workOrderSubject = data["workOrderSubject"];
            this.customerInvoiceDescription = data["customerInvoiceDescription"];
            this.uploadedByName = data["uploadedByName"];
        }
    }

    static fromJS(data: any): GetAttachmentForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAttachmentForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["attachment"] = this.attachment ? this.attachment.toJSON() : <any>undefined;
        data["assetReference"] = this.assetReference;
        data["incidentDescription"] = this.incidentDescription;
        data["leaseAgreementReference"] = this.leaseAgreementReference;
        data["quotationTitle"] = this.quotationTitle;
        data["supportContractTitle"] = this.supportContractTitle;
        data["workOrderSubject"] = this.workOrderSubject;
        data["customerInvoiceDescription"] = this.customerInvoiceDescription;
        data["uploadedByName"] = this.uploadedByName;
        return data; 
    }
}

export interface IGetAttachmentForViewDto {
    attachment: AttachmentDto | undefined;
    assetReference: string | undefined;
    incidentDescription: string | undefined;
    leaseAgreementReference: string | undefined;
    quotationTitle: string | undefined;
    supportContractTitle: string | undefined;
    workOrderSubject: string | undefined;
    customerInvoiceDescription: string | undefined;
    uploadedByName: string | undefined;
}

export class AttachmentDto implements IAttachmentDto {
    filename!: string | undefined;
    description!: string | undefined;
    uploadedAt!: moment.Moment | undefined;
    uploadedBy!: number | undefined;
    blobFolder!: string | undefined;
    blobId!: string | undefined;
    assetId!: number | undefined;
    incidentId!: number | undefined;
    leaseAgreementId!: number | undefined;
    quotationId!: number | undefined;
    supportContractId!: number | undefined;
    workOrderId!: number | undefined;
    customerInvoiceId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IAttachmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.filename = data["filename"];
            this.description = data["description"];
            this.uploadedAt = data["uploadedAt"] ? moment(data["uploadedAt"].toString()) : <any>undefined;
            this.uploadedBy = data["uploadedBy"];
            this.blobFolder = data["blobFolder"];
            this.blobId = data["blobId"];
            this.assetId = data["assetId"];
            this.incidentId = data["incidentId"];
            this.leaseAgreementId = data["leaseAgreementId"];
            this.quotationId = data["quotationId"];
            this.supportContractId = data["supportContractId"];
            this.workOrderId = data["workOrderId"];
            this.customerInvoiceId = data["customerInvoiceId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AttachmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new AttachmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filename"] = this.filename;
        data["description"] = this.description;
        data["uploadedAt"] = this.uploadedAt ? this.uploadedAt.toISOString() : <any>undefined;
        data["uploadedBy"] = this.uploadedBy;
        data["blobFolder"] = this.blobFolder;
        data["blobId"] = this.blobId;
        data["assetId"] = this.assetId;
        data["incidentId"] = this.incidentId;
        data["leaseAgreementId"] = this.leaseAgreementId;
        data["quotationId"] = this.quotationId;
        data["supportContractId"] = this.supportContractId;
        data["workOrderId"] = this.workOrderId;
        data["customerInvoiceId"] = this.customerInvoiceId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IAttachmentDto {
    filename: string | undefined;
    description: string | undefined;
    uploadedAt: moment.Moment | undefined;
    uploadedBy: number | undefined;
    blobFolder: string | undefined;
    blobId: string | undefined;
    assetId: number | undefined;
    incidentId: number | undefined;
    leaseAgreementId: number | undefined;
    quotationId: number | undefined;
    supportContractId: number | undefined;
    workOrderId: number | undefined;
    customerInvoiceId: number | undefined;
    id: number | undefined;
}

export class GetAttachmentForEditOutput implements IGetAttachmentForEditOutput {
    attachment!: CreateOrEditAttachmentDto | undefined;
    assetReference!: string | undefined;
    incidentDescription!: string | undefined;
    leaseAgreementReference!: string | undefined;
    quotationTitle!: string | undefined;
    supportContractTitle!: string | undefined;
    workOrderSubject!: string | undefined;
    customerInvoiceDescription!: string | undefined;

    constructor(data?: IGetAttachmentForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.attachment = data["attachment"] ? CreateOrEditAttachmentDto.fromJS(data["attachment"]) : <any>undefined;
            this.assetReference = data["assetReference"];
            this.incidentDescription = data["incidentDescription"];
            this.leaseAgreementReference = data["leaseAgreementReference"];
            this.quotationTitle = data["quotationTitle"];
            this.supportContractTitle = data["supportContractTitle"];
            this.workOrderSubject = data["workOrderSubject"];
            this.customerInvoiceDescription = data["customerInvoiceDescription"];
        }
    }

    static fromJS(data: any): GetAttachmentForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAttachmentForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["attachment"] = this.attachment ? this.attachment.toJSON() : <any>undefined;
        data["assetReference"] = this.assetReference;
        data["incidentDescription"] = this.incidentDescription;
        data["leaseAgreementReference"] = this.leaseAgreementReference;
        data["quotationTitle"] = this.quotationTitle;
        data["supportContractTitle"] = this.supportContractTitle;
        data["workOrderSubject"] = this.workOrderSubject;
        data["customerInvoiceDescription"] = this.customerInvoiceDescription;
        return data; 
    }
}

export interface IGetAttachmentForEditOutput {
    attachment: CreateOrEditAttachmentDto | undefined;
    assetReference: string | undefined;
    incidentDescription: string | undefined;
    leaseAgreementReference: string | undefined;
    quotationTitle: string | undefined;
    supportContractTitle: string | undefined;
    workOrderSubject: string | undefined;
    customerInvoiceDescription: string | undefined;
}

export class CreateOrEditAttachmentDto implements ICreateOrEditAttachmentDto {
    filename!: string;
    description!: string | undefined;
    uploadedAt!: moment.Moment | undefined;
    uploadedBy!: number | undefined;
    blobFolder!: string | undefined;
    blobId!: string | undefined;
    assetId!: number | undefined;
    incidentId!: number | undefined;
    leaseAgreementId!: number | undefined;
    quotationId!: number | undefined;
    supportContractId!: number | undefined;
    workOrderId!: number | undefined;
    customerInvoiceId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditAttachmentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.filename = data["filename"];
            this.description = data["description"];
            this.uploadedAt = data["uploadedAt"] ? moment(data["uploadedAt"].toString()) : <any>undefined;
            this.uploadedBy = data["uploadedBy"];
            this.blobFolder = data["blobFolder"];
            this.blobId = data["blobId"];
            this.assetId = data["assetId"];
            this.incidentId = data["incidentId"];
            this.leaseAgreementId = data["leaseAgreementId"];
            this.quotationId = data["quotationId"];
            this.supportContractId = data["supportContractId"];
            this.workOrderId = data["workOrderId"];
            this.customerInvoiceId = data["customerInvoiceId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditAttachmentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditAttachmentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["filename"] = this.filename;
        data["description"] = this.description;
        data["uploadedAt"] = this.uploadedAt ? this.uploadedAt.toISOString() : <any>undefined;
        data["uploadedBy"] = this.uploadedBy;
        data["blobFolder"] = this.blobFolder;
        data["blobId"] = this.blobId;
        data["assetId"] = this.assetId;
        data["incidentId"] = this.incidentId;
        data["leaseAgreementId"] = this.leaseAgreementId;
        data["quotationId"] = this.quotationId;
        data["supportContractId"] = this.supportContractId;
        data["workOrderId"] = this.workOrderId;
        data["customerInvoiceId"] = this.customerInvoiceId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditAttachmentDto {
    filename: string;
    description: string | undefined;
    uploadedAt: moment.Moment | undefined;
    uploadedBy: number | undefined;
    blobFolder: string | undefined;
    blobId: string | undefined;
    assetId: number | undefined;
    incidentId: number | undefined;
    leaseAgreementId: number | undefined;
    quotationId: number | undefined;
    supportContractId: number | undefined;
    workOrderId: number | undefined;
    customerInvoiceId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfAttachmentAssetLookupTableDto implements IPagedResultDtoOfAttachmentAssetLookupTableDto {
    totalCount!: number | undefined;
    items!: AttachmentAssetLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAttachmentAssetLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(AttachmentAssetLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAttachmentAssetLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAttachmentAssetLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfAttachmentAssetLookupTableDto {
    totalCount: number | undefined;
    items: AttachmentAssetLookupTableDto[] | undefined;
}

export class AttachmentAssetLookupTableDto implements IAttachmentAssetLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IAttachmentAssetLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): AttachmentAssetLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new AttachmentAssetLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IAttachmentAssetLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfAttachmentIncidentLookupTableDto implements IPagedResultDtoOfAttachmentIncidentLookupTableDto {
    totalCount!: number | undefined;
    items!: AttachmentIncidentLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAttachmentIncidentLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(AttachmentIncidentLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAttachmentIncidentLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAttachmentIncidentLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfAttachmentIncidentLookupTableDto {
    totalCount: number | undefined;
    items: AttachmentIncidentLookupTableDto[] | undefined;
}

export class AttachmentIncidentLookupTableDto implements IAttachmentIncidentLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IAttachmentIncidentLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): AttachmentIncidentLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new AttachmentIncidentLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IAttachmentIncidentLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfAttachmentLeaseAgreementLookupTableDto implements IPagedResultDtoOfAttachmentLeaseAgreementLookupTableDto {
    totalCount!: number | undefined;
    items!: AttachmentLeaseAgreementLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAttachmentLeaseAgreementLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(AttachmentLeaseAgreementLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAttachmentLeaseAgreementLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAttachmentLeaseAgreementLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfAttachmentLeaseAgreementLookupTableDto {
    totalCount: number | undefined;
    items: AttachmentLeaseAgreementLookupTableDto[] | undefined;
}

export class AttachmentLeaseAgreementLookupTableDto implements IAttachmentLeaseAgreementLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IAttachmentLeaseAgreementLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): AttachmentLeaseAgreementLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new AttachmentLeaseAgreementLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IAttachmentLeaseAgreementLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfAttachmentQuotationLookupTableDto implements IPagedResultDtoOfAttachmentQuotationLookupTableDto {
    totalCount!: number | undefined;
    items!: AttachmentQuotationLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAttachmentQuotationLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(AttachmentQuotationLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAttachmentQuotationLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAttachmentQuotationLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfAttachmentQuotationLookupTableDto {
    totalCount: number | undefined;
    items: AttachmentQuotationLookupTableDto[] | undefined;
}

export class AttachmentQuotationLookupTableDto implements IAttachmentQuotationLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IAttachmentQuotationLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): AttachmentQuotationLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new AttachmentQuotationLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IAttachmentQuotationLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfAttachmentSupportContractLookupTableDto implements IPagedResultDtoOfAttachmentSupportContractLookupTableDto {
    totalCount!: number | undefined;
    items!: AttachmentSupportContractLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAttachmentSupportContractLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(AttachmentSupportContractLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAttachmentSupportContractLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAttachmentSupportContractLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfAttachmentSupportContractLookupTableDto {
    totalCount: number | undefined;
    items: AttachmentSupportContractLookupTableDto[] | undefined;
}

export class AttachmentSupportContractLookupTableDto implements IAttachmentSupportContractLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IAttachmentSupportContractLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): AttachmentSupportContractLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new AttachmentSupportContractLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IAttachmentSupportContractLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfAttachmentWorkOrderLookupTableDto implements IPagedResultDtoOfAttachmentWorkOrderLookupTableDto {
    totalCount!: number | undefined;
    items!: AttachmentWorkOrderLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAttachmentWorkOrderLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(AttachmentWorkOrderLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAttachmentWorkOrderLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAttachmentWorkOrderLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfAttachmentWorkOrderLookupTableDto {
    totalCount: number | undefined;
    items: AttachmentWorkOrderLookupTableDto[] | undefined;
}

export class AttachmentWorkOrderLookupTableDto implements IAttachmentWorkOrderLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IAttachmentWorkOrderLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): AttachmentWorkOrderLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new AttachmentWorkOrderLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IAttachmentWorkOrderLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfAttachmentCustomerInvoiceLookupTableDto implements IPagedResultDtoOfAttachmentCustomerInvoiceLookupTableDto {
    totalCount!: number | undefined;
    items!: AttachmentCustomerInvoiceLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAttachmentCustomerInvoiceLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(AttachmentCustomerInvoiceLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAttachmentCustomerInvoiceLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAttachmentCustomerInvoiceLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfAttachmentCustomerInvoiceLookupTableDto {
    totalCount: number | undefined;
    items: AttachmentCustomerInvoiceLookupTableDto[] | undefined;
}

export class AttachmentCustomerInvoiceLookupTableDto implements IAttachmentCustomerInvoiceLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IAttachmentCustomerInvoiceLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): AttachmentCustomerInvoiceLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new AttachmentCustomerInvoiceLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IAttachmentCustomerInvoiceLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfAuditLogListDto implements IPagedResultDtoOfAuditLogListDto {
    totalCount!: number | undefined;
    items!: AuditLogListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfAuditLogListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(AuditLogListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfAuditLogListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfAuditLogListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfAuditLogListDto {
    totalCount: number | undefined;
    items: AuditLogListDto[] | undefined;
}

export class AuditLogListDto implements IAuditLogListDto {
    userId!: number | undefined;
    userName!: string | undefined;
    impersonatorTenantId!: number | undefined;
    impersonatorUserId!: number | undefined;
    serviceName!: string | undefined;
    methodName!: string | undefined;
    parameters!: string | undefined;
    executionTime!: moment.Moment | undefined;
    executionDuration!: number | undefined;
    clientIpAddress!: string | undefined;
    clientName!: string | undefined;
    browserInfo!: string | undefined;
    exception!: string | undefined;
    customData!: string | undefined;
    id!: number | undefined;

    constructor(data?: IAuditLogListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.userName = data["userName"];
            this.impersonatorTenantId = data["impersonatorTenantId"];
            this.impersonatorUserId = data["impersonatorUserId"];
            this.serviceName = data["serviceName"];
            this.methodName = data["methodName"];
            this.parameters = data["parameters"];
            this.executionTime = data["executionTime"] ? moment(data["executionTime"].toString()) : <any>undefined;
            this.executionDuration = data["executionDuration"];
            this.clientIpAddress = data["clientIpAddress"];
            this.clientName = data["clientName"];
            this.browserInfo = data["browserInfo"];
            this.exception = data["exception"];
            this.customData = data["customData"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AuditLogListDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuditLogListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["impersonatorTenantId"] = this.impersonatorTenantId;
        data["impersonatorUserId"] = this.impersonatorUserId;
        data["serviceName"] = this.serviceName;
        data["methodName"] = this.methodName;
        data["parameters"] = this.parameters;
        data["executionTime"] = this.executionTime ? this.executionTime.toISOString() : <any>undefined;
        data["executionDuration"] = this.executionDuration;
        data["clientIpAddress"] = this.clientIpAddress;
        data["clientName"] = this.clientName;
        data["browserInfo"] = this.browserInfo;
        data["exception"] = this.exception;
        data["customData"] = this.customData;
        data["id"] = this.id;
        return data; 
    }
}

export interface IAuditLogListDto {
    userId: number | undefined;
    userName: string | undefined;
    impersonatorTenantId: number | undefined;
    impersonatorUserId: number | undefined;
    serviceName: string | undefined;
    methodName: string | undefined;
    parameters: string | undefined;
    executionTime: moment.Moment | undefined;
    executionDuration: number | undefined;
    clientIpAddress: string | undefined;
    clientName: string | undefined;
    browserInfo: string | undefined;
    exception: string | undefined;
    customData: string | undefined;
    id: number | undefined;
}

export class NameValueDto implements INameValueDto {
    name!: string | undefined;
    value!: string | undefined;

    constructor(data?: INameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): NameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }
}

export interface INameValueDto {
    name: string | undefined;
    value: string | undefined;
}

export class PagedResultDtoOfEntityChangeListDto implements IPagedResultDtoOfEntityChangeListDto {
    totalCount!: number | undefined;
    items!: EntityChangeListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfEntityChangeListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(EntityChangeListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfEntityChangeListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfEntityChangeListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfEntityChangeListDto {
    totalCount: number | undefined;
    items: EntityChangeListDto[] | undefined;
}

export class EntityChangeListDto implements IEntityChangeListDto {
    userId!: number | undefined;
    userName!: string | undefined;
    changeTime!: moment.Moment | undefined;
    entityTypeFullName!: string | undefined;
    changeType!: EntityChangeType | undefined;
    readonly changeTypeName!: string | undefined;
    entityChangeSetId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IEntityChangeListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.userName = data["userName"];
            this.changeTime = data["changeTime"] ? moment(data["changeTime"].toString()) : <any>undefined;
            this.entityTypeFullName = data["entityTypeFullName"];
            this.changeType = data["changeType"];
            (<any>this).changeTypeName = data["changeTypeName"];
            this.entityChangeSetId = data["entityChangeSetId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityChangeListDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityChangeListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["changeTime"] = this.changeTime ? this.changeTime.toISOString() : <any>undefined;
        data["entityTypeFullName"] = this.entityTypeFullName;
        data["changeType"] = this.changeType;
        data["changeTypeName"] = this.changeTypeName;
        data["entityChangeSetId"] = this.entityChangeSetId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IEntityChangeListDto {
    userId: number | undefined;
    userName: string | undefined;
    changeTime: moment.Moment | undefined;
    entityTypeFullName: string | undefined;
    changeType: EntityChangeType | undefined;
    changeTypeName: string | undefined;
    entityChangeSetId: number | undefined;
    id: number | undefined;
}

export enum EntityChangeType {
    Created = 0,
    Updated = 1,
    Deleted = 2,
}

export class EntityPropertyChangeDto implements IEntityPropertyChangeDto {
    entityChangeId!: number | undefined;
    newValue!: string | undefined;
    originalValue!: string | undefined;
    propertyName!: string | undefined;
    propertyTypeFullName!: string | undefined;
    tenantId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IEntityPropertyChangeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.entityChangeId = data["entityChangeId"];
            this.newValue = data["newValue"];
            this.originalValue = data["originalValue"];
            this.propertyName = data["propertyName"];
            this.propertyTypeFullName = data["propertyTypeFullName"];
            this.tenantId = data["tenantId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityPropertyChangeDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityPropertyChangeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityChangeId"] = this.entityChangeId;
        data["newValue"] = this.newValue;
        data["originalValue"] = this.originalValue;
        data["propertyName"] = this.propertyName;
        data["propertyTypeFullName"] = this.propertyTypeFullName;
        data["tenantId"] = this.tenantId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IEntityPropertyChangeDto {
    entityChangeId: number | undefined;
    newValue: string | undefined;
    originalValue: string | undefined;
    propertyName: string | undefined;
    propertyTypeFullName: string | undefined;
    tenantId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfGetAzureStorageConfigurationForViewDto implements IPagedResultDtoOfGetAzureStorageConfigurationForViewDto {
    totalCount!: number | undefined;
    items!: GetAzureStorageConfigurationForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetAzureStorageConfigurationForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetAzureStorageConfigurationForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetAzureStorageConfigurationForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetAzureStorageConfigurationForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetAzureStorageConfigurationForViewDto {
    totalCount: number | undefined;
    items: GetAzureStorageConfigurationForViewDto[] | undefined;
}

export class GetAzureStorageConfigurationForViewDto implements IGetAzureStorageConfigurationForViewDto {
    azureStorageConfiguration!: AzureStorageConfigurationDto | undefined;

    constructor(data?: IGetAzureStorageConfigurationForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.azureStorageConfiguration = data["azureStorageConfiguration"] ? AzureStorageConfigurationDto.fromJS(data["azureStorageConfiguration"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAzureStorageConfigurationForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetAzureStorageConfigurationForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["azureStorageConfiguration"] = this.azureStorageConfiguration ? this.azureStorageConfiguration.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetAzureStorageConfigurationForViewDto {
    azureStorageConfiguration: AzureStorageConfigurationDto | undefined;
}

export class AzureStorageConfigurationDto implements IAzureStorageConfigurationDto {
    service!: string | undefined;
    accountName!: string | undefined;
    keyValue!: string | undefined;
    blobStorageEndpoint!: string | undefined;
    containerName!: string | undefined;
    id!: number | undefined;

    constructor(data?: IAzureStorageConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.service = data["service"];
            this.accountName = data["accountName"];
            this.keyValue = data["keyValue"];
            this.blobStorageEndpoint = data["blobStorageEndpoint"];
            this.containerName = data["containerName"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AzureStorageConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new AzureStorageConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["service"] = this.service;
        data["accountName"] = this.accountName;
        data["keyValue"] = this.keyValue;
        data["blobStorageEndpoint"] = this.blobStorageEndpoint;
        data["containerName"] = this.containerName;
        data["id"] = this.id;
        return data; 
    }
}

export interface IAzureStorageConfigurationDto {
    service: string | undefined;
    accountName: string | undefined;
    keyValue: string | undefined;
    blobStorageEndpoint: string | undefined;
    containerName: string | undefined;
    id: number | undefined;
}

export class GetAzureStorageConfigurationForEditOutput implements IGetAzureStorageConfigurationForEditOutput {
    azureStorageConfiguration!: CreateOrEditAzureStorageConfigurationDto | undefined;

    constructor(data?: IGetAzureStorageConfigurationForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.azureStorageConfiguration = data["azureStorageConfiguration"] ? CreateOrEditAzureStorageConfigurationDto.fromJS(data["azureStorageConfiguration"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetAzureStorageConfigurationForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAzureStorageConfigurationForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["azureStorageConfiguration"] = this.azureStorageConfiguration ? this.azureStorageConfiguration.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetAzureStorageConfigurationForEditOutput {
    azureStorageConfiguration: CreateOrEditAzureStorageConfigurationDto | undefined;
}

export class CreateOrEditAzureStorageConfigurationDto implements ICreateOrEditAzureStorageConfigurationDto {
    service!: string;
    accountName!: string;
    keyValue!: string;
    blobStorageEndpoint!: string;
    containerName!: string;
    id!: number | undefined;

    constructor(data?: ICreateOrEditAzureStorageConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.service = data["service"];
            this.accountName = data["accountName"];
            this.keyValue = data["keyValue"];
            this.blobStorageEndpoint = data["blobStorageEndpoint"];
            this.containerName = data["containerName"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditAzureStorageConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditAzureStorageConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["service"] = this.service;
        data["accountName"] = this.accountName;
        data["keyValue"] = this.keyValue;
        data["blobStorageEndpoint"] = this.blobStorageEndpoint;
        data["containerName"] = this.containerName;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditAzureStorageConfigurationDto {
    service: string;
    accountName: string;
    keyValue: string;
    blobStorageEndpoint: string;
    containerName: string;
    id: number | undefined;
}

export class PagedResultDtoOfGetBillingEventDetailForViewDto implements IPagedResultDtoOfGetBillingEventDetailForViewDto {
    totalCount!: number | undefined;
    items!: GetBillingEventDetailForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetBillingEventDetailForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetBillingEventDetailForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetBillingEventDetailForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetBillingEventDetailForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetBillingEventDetailForViewDto {
    totalCount: number | undefined;
    items: GetBillingEventDetailForViewDto[] | undefined;
}

export class GetBillingEventDetailForViewDto implements IGetBillingEventDetailForViewDto {
    billingEventDetail!: BillingEventDetailDto | undefined;
    billingRuleName!: string | undefined;
    leaseItemItem!: string | undefined;
    billingEventPurpose!: string | undefined;

    constructor(data?: IGetBillingEventDetailForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.billingEventDetail = data["billingEventDetail"] ? BillingEventDetailDto.fromJS(data["billingEventDetail"]) : <any>undefined;
            this.billingRuleName = data["billingRuleName"];
            this.leaseItemItem = data["leaseItemItem"];
            this.billingEventPurpose = data["billingEventPurpose"];
        }
    }

    static fromJS(data: any): GetBillingEventDetailForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetBillingEventDetailForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["billingEventDetail"] = this.billingEventDetail ? this.billingEventDetail.toJSON() : <any>undefined;
        data["billingRuleName"] = this.billingRuleName;
        data["leaseItemItem"] = this.leaseItemItem;
        data["billingEventPurpose"] = this.billingEventPurpose;
        return data; 
    }
}

export interface IGetBillingEventDetailForViewDto {
    billingEventDetail: BillingEventDetailDto | undefined;
    billingRuleName: string | undefined;
    leaseItemItem: string | undefined;
    billingEventPurpose: string | undefined;
}

export class BillingEventDetailDto implements IBillingEventDetailDto {
    ruleExecutedSuccessfully!: boolean | undefined;
    exception!: string | undefined;
    billingRuleId!: number | undefined;
    leaseItemId!: number | undefined;
    billingEventId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IBillingEventDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ruleExecutedSuccessfully = data["ruleExecutedSuccessfully"];
            this.exception = data["exception"];
            this.billingRuleId = data["billingRuleId"];
            this.leaseItemId = data["leaseItemId"];
            this.billingEventId = data["billingEventId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): BillingEventDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new BillingEventDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ruleExecutedSuccessfully"] = this.ruleExecutedSuccessfully;
        data["exception"] = this.exception;
        data["billingRuleId"] = this.billingRuleId;
        data["leaseItemId"] = this.leaseItemId;
        data["billingEventId"] = this.billingEventId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IBillingEventDetailDto {
    ruleExecutedSuccessfully: boolean | undefined;
    exception: string | undefined;
    billingRuleId: number | undefined;
    leaseItemId: number | undefined;
    billingEventId: number | undefined;
    id: number | undefined;
}

export class GetBillingEventDetailForEditOutput implements IGetBillingEventDetailForEditOutput {
    billingEventDetail!: CreateOrEditBillingEventDetailDto | undefined;
    billingRuleName!: string | undefined;
    leaseItemItem!: string | undefined;
    billingEventPurpose!: string | undefined;

    constructor(data?: IGetBillingEventDetailForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.billingEventDetail = data["billingEventDetail"] ? CreateOrEditBillingEventDetailDto.fromJS(data["billingEventDetail"]) : <any>undefined;
            this.billingRuleName = data["billingRuleName"];
            this.leaseItemItem = data["leaseItemItem"];
            this.billingEventPurpose = data["billingEventPurpose"];
        }
    }

    static fromJS(data: any): GetBillingEventDetailForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetBillingEventDetailForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["billingEventDetail"] = this.billingEventDetail ? this.billingEventDetail.toJSON() : <any>undefined;
        data["billingRuleName"] = this.billingRuleName;
        data["leaseItemItem"] = this.leaseItemItem;
        data["billingEventPurpose"] = this.billingEventPurpose;
        return data; 
    }
}

export interface IGetBillingEventDetailForEditOutput {
    billingEventDetail: CreateOrEditBillingEventDetailDto | undefined;
    billingRuleName: string | undefined;
    leaseItemItem: string | undefined;
    billingEventPurpose: string | undefined;
}

export class CreateOrEditBillingEventDetailDto implements ICreateOrEditBillingEventDetailDto {
    ruleExecutedSuccessfully!: boolean | undefined;
    exception!: string | undefined;
    billingRuleId!: number | undefined;
    leaseItemId!: number | undefined;
    billingEventId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditBillingEventDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ruleExecutedSuccessfully = data["ruleExecutedSuccessfully"];
            this.exception = data["exception"];
            this.billingRuleId = data["billingRuleId"];
            this.leaseItemId = data["leaseItemId"];
            this.billingEventId = data["billingEventId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditBillingEventDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditBillingEventDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ruleExecutedSuccessfully"] = this.ruleExecutedSuccessfully;
        data["exception"] = this.exception;
        data["billingRuleId"] = this.billingRuleId;
        data["leaseItemId"] = this.leaseItemId;
        data["billingEventId"] = this.billingEventId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditBillingEventDetailDto {
    ruleExecutedSuccessfully: boolean | undefined;
    exception: string | undefined;
    billingRuleId: number | undefined;
    leaseItemId: number | undefined;
    billingEventId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfBillingEventDetailBillingRuleLookupTableDto implements IPagedResultDtoOfBillingEventDetailBillingRuleLookupTableDto {
    totalCount!: number | undefined;
    items!: BillingEventDetailBillingRuleLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfBillingEventDetailBillingRuleLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(BillingEventDetailBillingRuleLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfBillingEventDetailBillingRuleLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfBillingEventDetailBillingRuleLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfBillingEventDetailBillingRuleLookupTableDto {
    totalCount: number | undefined;
    items: BillingEventDetailBillingRuleLookupTableDto[] | undefined;
}

export class BillingEventDetailBillingRuleLookupTableDto implements IBillingEventDetailBillingRuleLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IBillingEventDetailBillingRuleLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): BillingEventDetailBillingRuleLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new BillingEventDetailBillingRuleLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IBillingEventDetailBillingRuleLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfBillingEventDetailLeaseItemLookupTableDto implements IPagedResultDtoOfBillingEventDetailLeaseItemLookupTableDto {
    totalCount!: number | undefined;
    items!: BillingEventDetailLeaseItemLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfBillingEventDetailLeaseItemLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(BillingEventDetailLeaseItemLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfBillingEventDetailLeaseItemLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfBillingEventDetailLeaseItemLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfBillingEventDetailLeaseItemLookupTableDto {
    totalCount: number | undefined;
    items: BillingEventDetailLeaseItemLookupTableDto[] | undefined;
}

export class BillingEventDetailLeaseItemLookupTableDto implements IBillingEventDetailLeaseItemLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IBillingEventDetailLeaseItemLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): BillingEventDetailLeaseItemLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new BillingEventDetailLeaseItemLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IBillingEventDetailLeaseItemLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfBillingEventDetailBillingEventLookupTableDto implements IPagedResultDtoOfBillingEventDetailBillingEventLookupTableDto {
    totalCount!: number | undefined;
    items!: BillingEventDetailBillingEventLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfBillingEventDetailBillingEventLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(BillingEventDetailBillingEventLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfBillingEventDetailBillingEventLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfBillingEventDetailBillingEventLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfBillingEventDetailBillingEventLookupTableDto {
    totalCount: number | undefined;
    items: BillingEventDetailBillingEventLookupTableDto[] | undefined;
}

export class BillingEventDetailBillingEventLookupTableDto implements IBillingEventDetailBillingEventLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IBillingEventDetailBillingEventLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): BillingEventDetailBillingEventLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new BillingEventDetailBillingEventLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IBillingEventDetailBillingEventLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetBillingEventForViewDto implements IPagedResultDtoOfGetBillingEventForViewDto {
    totalCount!: number | undefined;
    items!: GetBillingEventForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetBillingEventForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetBillingEventForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetBillingEventForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetBillingEventForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetBillingEventForViewDto {
    totalCount: number | undefined;
    items: GetBillingEventForViewDto[] | undefined;
}

export class GetBillingEventForViewDto implements IGetBillingEventForViewDto {
    billingEvent!: BillingEventDto | undefined;
    leaseAgreementTitle!: string | undefined;
    vendorChargeReference!: string | undefined;
    billingEventTypeType!: string | undefined;

    constructor(data?: IGetBillingEventForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.billingEvent = data["billingEvent"] ? BillingEventDto.fromJS(data["billingEvent"]) : <any>undefined;
            this.leaseAgreementTitle = data["leaseAgreementTitle"];
            this.vendorChargeReference = data["vendorChargeReference"];
            this.billingEventTypeType = data["billingEventTypeType"];
        }
    }

    static fromJS(data: any): GetBillingEventForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetBillingEventForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["billingEvent"] = this.billingEvent ? this.billingEvent.toJSON() : <any>undefined;
        data["leaseAgreementTitle"] = this.leaseAgreementTitle;
        data["vendorChargeReference"] = this.vendorChargeReference;
        data["billingEventTypeType"] = this.billingEventTypeType;
        return data; 
    }
}

export interface IGetBillingEventForViewDto {
    billingEvent: BillingEventDto | undefined;
    leaseAgreementTitle: string | undefined;
    vendorChargeReference: string | undefined;
    billingEventTypeType: string | undefined;
}

export class BillingEventDto implements IBillingEventDto {
    billingEventDate!: moment.Moment | undefined;
    triggeredBy!: string | undefined;
    purpose!: string | undefined;
    wasInvoiceGenerated!: boolean | undefined;
    leaseAgreementId!: number | undefined;
    vendorChargeId!: number | undefined;
    billingEventTypeId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IBillingEventDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.billingEventDate = data["billingEventDate"] ? moment(data["billingEventDate"].toString()) : <any>undefined;
            this.triggeredBy = data["triggeredBy"];
            this.purpose = data["purpose"];
            this.wasInvoiceGenerated = data["wasInvoiceGenerated"];
            this.leaseAgreementId = data["leaseAgreementId"];
            this.vendorChargeId = data["vendorChargeId"];
            this.billingEventTypeId = data["billingEventTypeId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): BillingEventDto {
        data = typeof data === 'object' ? data : {};
        let result = new BillingEventDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["billingEventDate"] = this.billingEventDate ? this.billingEventDate.toISOString() : <any>undefined;
        data["triggeredBy"] = this.triggeredBy;
        data["purpose"] = this.purpose;
        data["wasInvoiceGenerated"] = this.wasInvoiceGenerated;
        data["leaseAgreementId"] = this.leaseAgreementId;
        data["vendorChargeId"] = this.vendorChargeId;
        data["billingEventTypeId"] = this.billingEventTypeId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IBillingEventDto {
    billingEventDate: moment.Moment | undefined;
    triggeredBy: string | undefined;
    purpose: string | undefined;
    wasInvoiceGenerated: boolean | undefined;
    leaseAgreementId: number | undefined;
    vendorChargeId: number | undefined;
    billingEventTypeId: number | undefined;
    id: number | undefined;
}

export class GetBillingEventForEditOutput implements IGetBillingEventForEditOutput {
    billingEvent!: CreateOrEditBillingEventDto | undefined;
    leaseAgreementTitle!: string | undefined;
    vendorChargeReference!: string | undefined;
    billingEventTypeType!: string | undefined;

    constructor(data?: IGetBillingEventForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.billingEvent = data["billingEvent"] ? CreateOrEditBillingEventDto.fromJS(data["billingEvent"]) : <any>undefined;
            this.leaseAgreementTitle = data["leaseAgreementTitle"];
            this.vendorChargeReference = data["vendorChargeReference"];
            this.billingEventTypeType = data["billingEventTypeType"];
        }
    }

    static fromJS(data: any): GetBillingEventForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetBillingEventForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["billingEvent"] = this.billingEvent ? this.billingEvent.toJSON() : <any>undefined;
        data["leaseAgreementTitle"] = this.leaseAgreementTitle;
        data["vendorChargeReference"] = this.vendorChargeReference;
        data["billingEventTypeType"] = this.billingEventTypeType;
        return data; 
    }
}

export interface IGetBillingEventForEditOutput {
    billingEvent: CreateOrEditBillingEventDto | undefined;
    leaseAgreementTitle: string | undefined;
    vendorChargeReference: string | undefined;
    billingEventTypeType: string | undefined;
}

export class CreateOrEditBillingEventDto implements ICreateOrEditBillingEventDto {
    billingEventDate!: moment.Moment | undefined;
    triggeredBy!: string | undefined;
    purpose!: string | undefined;
    wasInvoiceGenerated!: boolean | undefined;
    leaseAgreementId!: number | undefined;
    vendorChargeId!: number | undefined;
    billingEventTypeId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditBillingEventDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.billingEventDate = data["billingEventDate"] ? moment(data["billingEventDate"].toString()) : <any>undefined;
            this.triggeredBy = data["triggeredBy"];
            this.purpose = data["purpose"];
            this.wasInvoiceGenerated = data["wasInvoiceGenerated"];
            this.leaseAgreementId = data["leaseAgreementId"];
            this.vendorChargeId = data["vendorChargeId"];
            this.billingEventTypeId = data["billingEventTypeId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditBillingEventDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditBillingEventDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["billingEventDate"] = this.billingEventDate ? this.billingEventDate.toISOString() : <any>undefined;
        data["triggeredBy"] = this.triggeredBy;
        data["purpose"] = this.purpose;
        data["wasInvoiceGenerated"] = this.wasInvoiceGenerated;
        data["leaseAgreementId"] = this.leaseAgreementId;
        data["vendorChargeId"] = this.vendorChargeId;
        data["billingEventTypeId"] = this.billingEventTypeId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditBillingEventDto {
    billingEventDate: moment.Moment | undefined;
    triggeredBy: string | undefined;
    purpose: string | undefined;
    wasInvoiceGenerated: boolean | undefined;
    leaseAgreementId: number | undefined;
    vendorChargeId: number | undefined;
    billingEventTypeId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfBillingEventLeaseAgreementLookupTableDto implements IPagedResultDtoOfBillingEventLeaseAgreementLookupTableDto {
    totalCount!: number | undefined;
    items!: BillingEventLeaseAgreementLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfBillingEventLeaseAgreementLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(BillingEventLeaseAgreementLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfBillingEventLeaseAgreementLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfBillingEventLeaseAgreementLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfBillingEventLeaseAgreementLookupTableDto {
    totalCount: number | undefined;
    items: BillingEventLeaseAgreementLookupTableDto[] | undefined;
}

export class BillingEventLeaseAgreementLookupTableDto implements IBillingEventLeaseAgreementLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IBillingEventLeaseAgreementLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): BillingEventLeaseAgreementLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new BillingEventLeaseAgreementLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IBillingEventLeaseAgreementLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfBillingEventVendorChargeLookupTableDto implements IPagedResultDtoOfBillingEventVendorChargeLookupTableDto {
    totalCount!: number | undefined;
    items!: BillingEventVendorChargeLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfBillingEventVendorChargeLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(BillingEventVendorChargeLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfBillingEventVendorChargeLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfBillingEventVendorChargeLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfBillingEventVendorChargeLookupTableDto {
    totalCount: number | undefined;
    items: BillingEventVendorChargeLookupTableDto[] | undefined;
}

export class BillingEventVendorChargeLookupTableDto implements IBillingEventVendorChargeLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IBillingEventVendorChargeLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): BillingEventVendorChargeLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new BillingEventVendorChargeLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IBillingEventVendorChargeLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfBillingEventBillingEventTypeLookupTableDto implements IPagedResultDtoOfBillingEventBillingEventTypeLookupTableDto {
    totalCount!: number | undefined;
    items!: BillingEventBillingEventTypeLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfBillingEventBillingEventTypeLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(BillingEventBillingEventTypeLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfBillingEventBillingEventTypeLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfBillingEventBillingEventTypeLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfBillingEventBillingEventTypeLookupTableDto {
    totalCount: number | undefined;
    items: BillingEventBillingEventTypeLookupTableDto[] | undefined;
}

export class BillingEventBillingEventTypeLookupTableDto implements IBillingEventBillingEventTypeLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IBillingEventBillingEventTypeLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): BillingEventBillingEventTypeLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new BillingEventBillingEventTypeLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IBillingEventBillingEventTypeLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetBillingEventTypeForViewDto implements IPagedResultDtoOfGetBillingEventTypeForViewDto {
    totalCount!: number | undefined;
    items!: GetBillingEventTypeForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetBillingEventTypeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetBillingEventTypeForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetBillingEventTypeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetBillingEventTypeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetBillingEventTypeForViewDto {
    totalCount: number | undefined;
    items: GetBillingEventTypeForViewDto[] | undefined;
}

export class GetBillingEventTypeForViewDto implements IGetBillingEventTypeForViewDto {
    billingEventType!: BillingEventTypeDto | undefined;

    constructor(data?: IGetBillingEventTypeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.billingEventType = data["billingEventType"] ? BillingEventTypeDto.fromJS(data["billingEventType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetBillingEventTypeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetBillingEventTypeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["billingEventType"] = this.billingEventType ? this.billingEventType.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetBillingEventTypeForViewDto {
    billingEventType: BillingEventTypeDto | undefined;
}

export class BillingEventTypeDto implements IBillingEventTypeDto {
    type!: string | undefined;
    description!: string | undefined;
    id!: number | undefined;

    constructor(data?: IBillingEventTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.type = data["type"];
            this.description = data["description"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): BillingEventTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new BillingEventTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }
}

export interface IBillingEventTypeDto {
    type: string | undefined;
    description: string | undefined;
    id: number | undefined;
}

export class GetBillingEventTypeForEditOutput implements IGetBillingEventTypeForEditOutput {
    billingEventType!: CreateOrEditBillingEventTypeDto | undefined;

    constructor(data?: IGetBillingEventTypeForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.billingEventType = data["billingEventType"] ? CreateOrEditBillingEventTypeDto.fromJS(data["billingEventType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetBillingEventTypeForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetBillingEventTypeForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["billingEventType"] = this.billingEventType ? this.billingEventType.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetBillingEventTypeForEditOutput {
    billingEventType: CreateOrEditBillingEventTypeDto | undefined;
}

export class CreateOrEditBillingEventTypeDto implements ICreateOrEditBillingEventTypeDto {
    type!: string;
    description!: string;
    id!: number | undefined;

    constructor(data?: ICreateOrEditBillingEventTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.type = data["type"];
            this.description = data["description"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditBillingEventTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditBillingEventTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditBillingEventTypeDto {
    type: string;
    description: string;
    id: number | undefined;
}

export class PagedResultDtoOfGetBillingRuleForViewDto implements IPagedResultDtoOfGetBillingRuleForViewDto {
    totalCount!: number | undefined;
    items!: GetBillingRuleForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetBillingRuleForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetBillingRuleForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetBillingRuleForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetBillingRuleForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetBillingRuleForViewDto {
    totalCount: number | undefined;
    items: GetBillingRuleForViewDto[] | undefined;
}

export class GetBillingRuleForViewDto implements IGetBillingRuleForViewDto {
    billingRule!: BillingRuleDto | undefined;
    billingRuleTypeType!: string | undefined;
    usageMetricMetric!: string | undefined;
    leaseAgreementTitle!: string | undefined;
    vendorName!: string | undefined;
    leaseItemItem!: string | undefined;
    currencyCode!: string | undefined;

    constructor(data?: IGetBillingRuleForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.billingRule = data["billingRule"] ? BillingRuleDto.fromJS(data["billingRule"]) : <any>undefined;
            this.billingRuleTypeType = data["billingRuleTypeType"];
            this.usageMetricMetric = data["usageMetricMetric"];
            this.leaseAgreementTitle = data["leaseAgreementTitle"];
            this.vendorName = data["vendorName"];
            this.leaseItemItem = data["leaseItemItem"];
            this.currencyCode = data["currencyCode"];
        }
    }

    static fromJS(data: any): GetBillingRuleForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetBillingRuleForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["billingRule"] = this.billingRule ? this.billingRule.toJSON() : <any>undefined;
        data["billingRuleTypeType"] = this.billingRuleTypeType;
        data["usageMetricMetric"] = this.usageMetricMetric;
        data["leaseAgreementTitle"] = this.leaseAgreementTitle;
        data["vendorName"] = this.vendorName;
        data["leaseItemItem"] = this.leaseItemItem;
        data["currencyCode"] = this.currencyCode;
        return data; 
    }
}

export interface IGetBillingRuleForViewDto {
    billingRule: BillingRuleDto | undefined;
    billingRuleTypeType: string | undefined;
    usageMetricMetric: string | undefined;
    leaseAgreementTitle: string | undefined;
    vendorName: string | undefined;
    leaseItemItem: string | undefined;
    currencyCode: string | undefined;
}

export class BillingRuleDto implements IBillingRuleDto {
    name!: string | undefined;
    isParent!: boolean | undefined;
    parentBillingRuleRefId!: number | undefined;
    chargePerUnit!: number | undefined;
    defaultInvoiceDescription!: string | undefined;
    billingRuleTypeId!: number | undefined;
    usageMetricId!: number | undefined;
    leaseAgreementId!: number | undefined;
    vendorId!: number | undefined;
    leaseItemId!: number | undefined;
    currencyId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IBillingRuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.isParent = data["isParent"];
            this.parentBillingRuleRefId = data["parentBillingRuleRefId"];
            this.chargePerUnit = data["chargePerUnit"];
            this.defaultInvoiceDescription = data["defaultInvoiceDescription"];
            this.billingRuleTypeId = data["billingRuleTypeId"];
            this.usageMetricId = data["usageMetricId"];
            this.leaseAgreementId = data["leaseAgreementId"];
            this.vendorId = data["vendorId"];
            this.leaseItemId = data["leaseItemId"];
            this.currencyId = data["currencyId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): BillingRuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new BillingRuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isParent"] = this.isParent;
        data["parentBillingRuleRefId"] = this.parentBillingRuleRefId;
        data["chargePerUnit"] = this.chargePerUnit;
        data["defaultInvoiceDescription"] = this.defaultInvoiceDescription;
        data["billingRuleTypeId"] = this.billingRuleTypeId;
        data["usageMetricId"] = this.usageMetricId;
        data["leaseAgreementId"] = this.leaseAgreementId;
        data["vendorId"] = this.vendorId;
        data["leaseItemId"] = this.leaseItemId;
        data["currencyId"] = this.currencyId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IBillingRuleDto {
    name: string | undefined;
    isParent: boolean | undefined;
    parentBillingRuleRefId: number | undefined;
    chargePerUnit: number | undefined;
    defaultInvoiceDescription: string | undefined;
    billingRuleTypeId: number | undefined;
    usageMetricId: number | undefined;
    leaseAgreementId: number | undefined;
    vendorId: number | undefined;
    leaseItemId: number | undefined;
    currencyId: number | undefined;
    id: number | undefined;
}

export class GetBillingRuleForEditOutput implements IGetBillingRuleForEditOutput {
    billingRule!: CreateOrEditBillingRuleDto | undefined;
    billingRuleTypeType!: string | undefined;
    usageMetricMetric!: string | undefined;
    leaseAgreementTitle!: string | undefined;
    vendorName!: string | undefined;
    leaseItemItem!: string | undefined;
    currencyCode!: string | undefined;

    constructor(data?: IGetBillingRuleForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.billingRule = data["billingRule"] ? CreateOrEditBillingRuleDto.fromJS(data["billingRule"]) : <any>undefined;
            this.billingRuleTypeType = data["billingRuleTypeType"];
            this.usageMetricMetric = data["usageMetricMetric"];
            this.leaseAgreementTitle = data["leaseAgreementTitle"];
            this.vendorName = data["vendorName"];
            this.leaseItemItem = data["leaseItemItem"];
            this.currencyCode = data["currencyCode"];
        }
    }

    static fromJS(data: any): GetBillingRuleForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetBillingRuleForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["billingRule"] = this.billingRule ? this.billingRule.toJSON() : <any>undefined;
        data["billingRuleTypeType"] = this.billingRuleTypeType;
        data["usageMetricMetric"] = this.usageMetricMetric;
        data["leaseAgreementTitle"] = this.leaseAgreementTitle;
        data["vendorName"] = this.vendorName;
        data["leaseItemItem"] = this.leaseItemItem;
        data["currencyCode"] = this.currencyCode;
        return data; 
    }
}

export interface IGetBillingRuleForEditOutput {
    billingRule: CreateOrEditBillingRuleDto | undefined;
    billingRuleTypeType: string | undefined;
    usageMetricMetric: string | undefined;
    leaseAgreementTitle: string | undefined;
    vendorName: string | undefined;
    leaseItemItem: string | undefined;
    currencyCode: string | undefined;
}

export class CreateOrEditBillingRuleDto implements ICreateOrEditBillingRuleDto {
    name!: string;
    isParent!: boolean | undefined;
    parentBillingRuleRefId!: number | undefined;
    chargePerUnit!: number | undefined;
    defaultInvoiceDescription!: string | undefined;
    billingRuleTypeId!: number | undefined;
    usageMetricId!: number | undefined;
    leaseAgreementId!: number | undefined;
    vendorId!: number | undefined;
    leaseItemId!: number | undefined;
    currencyId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditBillingRuleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.isParent = data["isParent"];
            this.parentBillingRuleRefId = data["parentBillingRuleRefId"];
            this.chargePerUnit = data["chargePerUnit"];
            this.defaultInvoiceDescription = data["defaultInvoiceDescription"];
            this.billingRuleTypeId = data["billingRuleTypeId"];
            this.usageMetricId = data["usageMetricId"];
            this.leaseAgreementId = data["leaseAgreementId"];
            this.vendorId = data["vendorId"];
            this.leaseItemId = data["leaseItemId"];
            this.currencyId = data["currencyId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditBillingRuleDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditBillingRuleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isParent"] = this.isParent;
        data["parentBillingRuleRefId"] = this.parentBillingRuleRefId;
        data["chargePerUnit"] = this.chargePerUnit;
        data["defaultInvoiceDescription"] = this.defaultInvoiceDescription;
        data["billingRuleTypeId"] = this.billingRuleTypeId;
        data["usageMetricId"] = this.usageMetricId;
        data["leaseAgreementId"] = this.leaseAgreementId;
        data["vendorId"] = this.vendorId;
        data["leaseItemId"] = this.leaseItemId;
        data["currencyId"] = this.currencyId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditBillingRuleDto {
    name: string;
    isParent: boolean | undefined;
    parentBillingRuleRefId: number | undefined;
    chargePerUnit: number | undefined;
    defaultInvoiceDescription: string | undefined;
    billingRuleTypeId: number | undefined;
    usageMetricId: number | undefined;
    leaseAgreementId: number | undefined;
    vendorId: number | undefined;
    leaseItemId: number | undefined;
    currencyId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfBillingRuleBillingRuleTypeLookupTableDto implements IPagedResultDtoOfBillingRuleBillingRuleTypeLookupTableDto {
    totalCount!: number | undefined;
    items!: BillingRuleBillingRuleTypeLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfBillingRuleBillingRuleTypeLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(BillingRuleBillingRuleTypeLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfBillingRuleBillingRuleTypeLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfBillingRuleBillingRuleTypeLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfBillingRuleBillingRuleTypeLookupTableDto {
    totalCount: number | undefined;
    items: BillingRuleBillingRuleTypeLookupTableDto[] | undefined;
}

export class BillingRuleBillingRuleTypeLookupTableDto implements IBillingRuleBillingRuleTypeLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IBillingRuleBillingRuleTypeLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): BillingRuleBillingRuleTypeLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new BillingRuleBillingRuleTypeLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IBillingRuleBillingRuleTypeLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfBillingRuleUsageMetricLookupTableDto implements IPagedResultDtoOfBillingRuleUsageMetricLookupTableDto {
    totalCount!: number | undefined;
    items!: BillingRuleUsageMetricLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfBillingRuleUsageMetricLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(BillingRuleUsageMetricLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfBillingRuleUsageMetricLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfBillingRuleUsageMetricLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfBillingRuleUsageMetricLookupTableDto {
    totalCount: number | undefined;
    items: BillingRuleUsageMetricLookupTableDto[] | undefined;
}

export class BillingRuleUsageMetricLookupTableDto implements IBillingRuleUsageMetricLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IBillingRuleUsageMetricLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): BillingRuleUsageMetricLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new BillingRuleUsageMetricLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IBillingRuleUsageMetricLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfBillingRuleLeaseAgreementLookupTableDto implements IPagedResultDtoOfBillingRuleLeaseAgreementLookupTableDto {
    totalCount!: number | undefined;
    items!: BillingRuleLeaseAgreementLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfBillingRuleLeaseAgreementLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(BillingRuleLeaseAgreementLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfBillingRuleLeaseAgreementLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfBillingRuleLeaseAgreementLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfBillingRuleLeaseAgreementLookupTableDto {
    totalCount: number | undefined;
    items: BillingRuleLeaseAgreementLookupTableDto[] | undefined;
}

export class BillingRuleLeaseAgreementLookupTableDto implements IBillingRuleLeaseAgreementLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IBillingRuleLeaseAgreementLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): BillingRuleLeaseAgreementLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new BillingRuleLeaseAgreementLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IBillingRuleLeaseAgreementLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfBillingRuleVendorLookupTableDto implements IPagedResultDtoOfBillingRuleVendorLookupTableDto {
    totalCount!: number | undefined;
    items!: BillingRuleVendorLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfBillingRuleVendorLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(BillingRuleVendorLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfBillingRuleVendorLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfBillingRuleVendorLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfBillingRuleVendorLookupTableDto {
    totalCount: number | undefined;
    items: BillingRuleVendorLookupTableDto[] | undefined;
}

export class BillingRuleVendorLookupTableDto implements IBillingRuleVendorLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IBillingRuleVendorLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): BillingRuleVendorLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new BillingRuleVendorLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IBillingRuleVendorLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfBillingRuleLeaseItemLookupTableDto implements IPagedResultDtoOfBillingRuleLeaseItemLookupTableDto {
    totalCount!: number | undefined;
    items!: BillingRuleLeaseItemLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfBillingRuleLeaseItemLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(BillingRuleLeaseItemLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfBillingRuleLeaseItemLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfBillingRuleLeaseItemLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfBillingRuleLeaseItemLookupTableDto {
    totalCount: number | undefined;
    items: BillingRuleLeaseItemLookupTableDto[] | undefined;
}

export class BillingRuleLeaseItemLookupTableDto implements IBillingRuleLeaseItemLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IBillingRuleLeaseItemLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): BillingRuleLeaseItemLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new BillingRuleLeaseItemLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IBillingRuleLeaseItemLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfBillingRuleCurrencyLookupTableDto implements IPagedResultDtoOfBillingRuleCurrencyLookupTableDto {
    totalCount!: number | undefined;
    items!: BillingRuleCurrencyLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfBillingRuleCurrencyLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(BillingRuleCurrencyLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfBillingRuleCurrencyLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfBillingRuleCurrencyLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfBillingRuleCurrencyLookupTableDto {
    totalCount: number | undefined;
    items: BillingRuleCurrencyLookupTableDto[] | undefined;
}

export class BillingRuleCurrencyLookupTableDto implements IBillingRuleCurrencyLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IBillingRuleCurrencyLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): BillingRuleCurrencyLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new BillingRuleCurrencyLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IBillingRuleCurrencyLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetBillingRuleTypeForViewDto implements IPagedResultDtoOfGetBillingRuleTypeForViewDto {
    totalCount!: number | undefined;
    items!: GetBillingRuleTypeForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetBillingRuleTypeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetBillingRuleTypeForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetBillingRuleTypeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetBillingRuleTypeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetBillingRuleTypeForViewDto {
    totalCount: number | undefined;
    items: GetBillingRuleTypeForViewDto[] | undefined;
}

export class GetBillingRuleTypeForViewDto implements IGetBillingRuleTypeForViewDto {
    billingRuleType!: BillingRuleTypeDto | undefined;

    constructor(data?: IGetBillingRuleTypeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.billingRuleType = data["billingRuleType"] ? BillingRuleTypeDto.fromJS(data["billingRuleType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetBillingRuleTypeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetBillingRuleTypeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["billingRuleType"] = this.billingRuleType ? this.billingRuleType.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetBillingRuleTypeForViewDto {
    billingRuleType: BillingRuleTypeDto | undefined;
}

export class BillingRuleTypeDto implements IBillingRuleTypeDto {
    type!: string | undefined;
    description!: string | undefined;
    id!: number | undefined;

    constructor(data?: IBillingRuleTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.type = data["type"];
            this.description = data["description"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): BillingRuleTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new BillingRuleTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }
}

export interface IBillingRuleTypeDto {
    type: string | undefined;
    description: string | undefined;
    id: number | undefined;
}

export class GetBillingRuleTypeForEditOutput implements IGetBillingRuleTypeForEditOutput {
    billingRuleType!: CreateOrEditBillingRuleTypeDto | undefined;

    constructor(data?: IGetBillingRuleTypeForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.billingRuleType = data["billingRuleType"] ? CreateOrEditBillingRuleTypeDto.fromJS(data["billingRuleType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetBillingRuleTypeForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetBillingRuleTypeForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["billingRuleType"] = this.billingRuleType ? this.billingRuleType.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetBillingRuleTypeForEditOutput {
    billingRuleType: CreateOrEditBillingRuleTypeDto | undefined;
}

export class CreateOrEditBillingRuleTypeDto implements ICreateOrEditBillingRuleTypeDto {
    type!: string;
    description!: string;
    id!: number | undefined;

    constructor(data?: ICreateOrEditBillingRuleTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.type = data["type"];
            this.description = data["description"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditBillingRuleTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditBillingRuleTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditBillingRuleTypeDto {
    type: string;
    description: string;
    id: number | undefined;
}

export class ListResultDtoOfCacheDto implements IListResultDtoOfCacheDto {
    items!: CacheDto[] | undefined;

    constructor(data?: IListResultDtoOfCacheDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(CacheDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfCacheDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfCacheDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfCacheDto {
    items: CacheDto[] | undefined;
}

export class CacheDto implements ICacheDto {
    name!: string | undefined;

    constructor(data?: ICacheDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): CacheDto {
        data = typeof data === 'object' ? data : {};
        let result = new CacheDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface ICacheDto {
    name: string | undefined;
}

export class EntityDtoOfString implements IEntityDtoOfString {
    id!: string | undefined;

    constructor(data?: IEntityDtoOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityDtoOfString {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDtoOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IEntityDtoOfString {
    id: string | undefined;
}

export class GetUserChatFriendsWithSettingsOutput implements IGetUserChatFriendsWithSettingsOutput {
    serverTime!: moment.Moment | undefined;
    friends!: FriendDto[] | undefined;

    constructor(data?: IGetUserChatFriendsWithSettingsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.serverTime = data["serverTime"] ? moment(data["serverTime"].toString()) : <any>undefined;
            if (Array.isArray(data["friends"])) {
                this.friends = [] as any;
                for (let item of data["friends"])
                    this.friends!.push(FriendDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetUserChatFriendsWithSettingsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserChatFriendsWithSettingsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["serverTime"] = this.serverTime ? this.serverTime.toISOString() : <any>undefined;
        if (Array.isArray(this.friends)) {
            data["friends"] = [];
            for (let item of this.friends)
                data["friends"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetUserChatFriendsWithSettingsOutput {
    serverTime: moment.Moment | undefined;
    friends: FriendDto[] | undefined;
}

export class FriendDto implements IFriendDto {
    friendUserId!: number | undefined;
    friendTenantId!: number | undefined;
    friendUserName!: string | undefined;
    friendTenancyName!: string | undefined;
    friendProfilePictureId!: string | undefined;
    unreadMessageCount!: number | undefined;
    isOnline!: boolean | undefined;
    state!: FriendshipState | undefined;

    constructor(data?: IFriendDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.friendUserId = data["friendUserId"];
            this.friendTenantId = data["friendTenantId"];
            this.friendUserName = data["friendUserName"];
            this.friendTenancyName = data["friendTenancyName"];
            this.friendProfilePictureId = data["friendProfilePictureId"];
            this.unreadMessageCount = data["unreadMessageCount"];
            this.isOnline = data["isOnline"];
            this.state = data["state"];
        }
    }

    static fromJS(data: any): FriendDto {
        data = typeof data === 'object' ? data : {};
        let result = new FriendDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["friendUserId"] = this.friendUserId;
        data["friendTenantId"] = this.friendTenantId;
        data["friendUserName"] = this.friendUserName;
        data["friendTenancyName"] = this.friendTenancyName;
        data["friendProfilePictureId"] = this.friendProfilePictureId;
        data["unreadMessageCount"] = this.unreadMessageCount;
        data["isOnline"] = this.isOnline;
        data["state"] = this.state;
        return data; 
    }
}

export interface IFriendDto {
    friendUserId: number | undefined;
    friendTenantId: number | undefined;
    friendUserName: string | undefined;
    friendTenancyName: string | undefined;
    friendProfilePictureId: string | undefined;
    unreadMessageCount: number | undefined;
    isOnline: boolean | undefined;
    state: FriendshipState | undefined;
}

export enum FriendshipState {
    Accepted = 1,
    Blocked = 2,
}

export class ListResultDtoOfChatMessageDto implements IListResultDtoOfChatMessageDto {
    items!: ChatMessageDto[] | undefined;

    constructor(data?: IListResultDtoOfChatMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ChatMessageDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfChatMessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfChatMessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfChatMessageDto {
    items: ChatMessageDto[] | undefined;
}

export class ChatMessageDto implements IChatMessageDto {
    userId!: number | undefined;
    tenantId!: number | undefined;
    targetUserId!: number | undefined;
    targetTenantId!: number | undefined;
    side!: ChatSide | undefined;
    readState!: ChatMessageReadState | undefined;
    receiverReadState!: ChatMessageReadState | undefined;
    message!: string | undefined;
    creationTime!: moment.Moment | undefined;
    sharedMessageId!: string | undefined;
    id!: number | undefined;

    constructor(data?: IChatMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
            this.targetUserId = data["targetUserId"];
            this.targetTenantId = data["targetTenantId"];
            this.side = data["side"];
            this.readState = data["readState"];
            this.receiverReadState = data["receiverReadState"];
            this.message = data["message"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.sharedMessageId = data["sharedMessageId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ChatMessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChatMessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        data["targetUserId"] = this.targetUserId;
        data["targetTenantId"] = this.targetTenantId;
        data["side"] = this.side;
        data["readState"] = this.readState;
        data["receiverReadState"] = this.receiverReadState;
        data["message"] = this.message;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["sharedMessageId"] = this.sharedMessageId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IChatMessageDto {
    userId: number | undefined;
    tenantId: number | undefined;
    targetUserId: number | undefined;
    targetTenantId: number | undefined;
    side: ChatSide | undefined;
    readState: ChatMessageReadState | undefined;
    receiverReadState: ChatMessageReadState | undefined;
    message: string | undefined;
    creationTime: moment.Moment | undefined;
    sharedMessageId: string | undefined;
    id: number | undefined;
}

export enum ChatSide {
    Sender = 1,
    Receiver = 2,
}

export enum ChatMessageReadState {
    Unread = 1,
    Read = 2,
}

export class MarkAllUnreadMessagesOfUserAsReadInput implements IMarkAllUnreadMessagesOfUserAsReadInput {
    tenantId!: number | undefined;
    userId!: number | undefined;

    constructor(data?: IMarkAllUnreadMessagesOfUserAsReadInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): MarkAllUnreadMessagesOfUserAsReadInput {
        data = typeof data === 'object' ? data : {};
        let result = new MarkAllUnreadMessagesOfUserAsReadInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data; 
    }
}

export interface IMarkAllUnreadMessagesOfUserAsReadInput {
    tenantId: number | undefined;
    userId: number | undefined;
}

export class ListResultDtoOfSubscribableEditionComboboxItemDto implements IListResultDtoOfSubscribableEditionComboboxItemDto {
    items!: SubscribableEditionComboboxItemDto[] | undefined;

    constructor(data?: IListResultDtoOfSubscribableEditionComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(SubscribableEditionComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfSubscribableEditionComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfSubscribableEditionComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfSubscribableEditionComboboxItemDto {
    items: SubscribableEditionComboboxItemDto[] | undefined;
}

export class SubscribableEditionComboboxItemDto implements ISubscribableEditionComboboxItemDto {
    isFree!: boolean | undefined;
    value!: string | undefined;
    displayText!: string | undefined;
    isSelected!: boolean | undefined;

    constructor(data?: ISubscribableEditionComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isFree = data["isFree"];
            this.value = data["value"];
            this.displayText = data["displayText"];
            this.isSelected = data["isSelected"];
        }
    }

    static fromJS(data: any): SubscribableEditionComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubscribableEditionComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isFree"] = this.isFree;
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        data["isSelected"] = this.isSelected;
        return data; 
    }
}

export interface ISubscribableEditionComboboxItemDto {
    isFree: boolean | undefined;
    value: string | undefined;
    displayText: string | undefined;
    isSelected: boolean | undefined;
}

export class FindUsersInput implements IFindUsersInput {
    tenantId!: number | undefined;
    maxResultCount!: number | undefined;
    skipCount!: number | undefined;
    filter!: string | undefined;

    constructor(data?: IFindUsersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
            this.filter = data["filter"];
        }
    }

    static fromJS(data: any): FindUsersInput {
        data = typeof data === 'object' ? data : {};
        let result = new FindUsersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data; 
    }
}

export interface IFindUsersInput {
    tenantId: number | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
    filter: string | undefined;
}

export class PagedResultDtoOfNameValueDto implements IPagedResultDtoOfNameValueDto {
    totalCount!: number | undefined;
    items!: NameValueDto[] | undefined;

    constructor(data?: IPagedResultDtoOfNameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfNameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfNameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfNameValueDto {
    totalCount: number | undefined;
    items: NameValueDto[] | undefined;
}

export class GetDefaultEditionNameOutput implements IGetDefaultEditionNameOutput {
    name!: string | undefined;

    constructor(data?: IGetDefaultEditionNameOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): GetDefaultEditionNameOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDefaultEditionNameOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface IGetDefaultEditionNameOutput {
    name: string | undefined;
}

export class PagedResultDtoOfGetConsumableTypeForViewDto implements IPagedResultDtoOfGetConsumableTypeForViewDto {
    totalCount!: number | undefined;
    items!: GetConsumableTypeForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetConsumableTypeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetConsumableTypeForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetConsumableTypeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetConsumableTypeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetConsumableTypeForViewDto {
    totalCount: number | undefined;
    items: GetConsumableTypeForViewDto[] | undefined;
}

export class GetConsumableTypeForViewDto implements IGetConsumableTypeForViewDto {
    consumableType!: ConsumableTypeDto | undefined;

    constructor(data?: IGetConsumableTypeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.consumableType = data["consumableType"] ? ConsumableTypeDto.fromJS(data["consumableType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetConsumableTypeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetConsumableTypeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["consumableType"] = this.consumableType ? this.consumableType.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetConsumableTypeForViewDto {
    consumableType: ConsumableTypeDto | undefined;
}

export class ConsumableTypeDto implements IConsumableTypeDto {
    type!: string | undefined;
    description!: string | undefined;
    id!: number | undefined;

    constructor(data?: IConsumableTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.type = data["type"];
            this.description = data["description"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ConsumableTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ConsumableTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }
}

export interface IConsumableTypeDto {
    type: string | undefined;
    description: string | undefined;
    id: number | undefined;
}

export class GetConsumableTypeForEditOutput implements IGetConsumableTypeForEditOutput {
    consumableType!: CreateOrEditConsumableTypeDto | undefined;

    constructor(data?: IGetConsumableTypeForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.consumableType = data["consumableType"] ? CreateOrEditConsumableTypeDto.fromJS(data["consumableType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetConsumableTypeForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetConsumableTypeForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["consumableType"] = this.consumableType ? this.consumableType.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetConsumableTypeForEditOutput {
    consumableType: CreateOrEditConsumableTypeDto | undefined;
}

export class CreateOrEditConsumableTypeDto implements ICreateOrEditConsumableTypeDto {
    type!: string;
    description!: string;
    id!: number | undefined;

    constructor(data?: ICreateOrEditConsumableTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.type = data["type"];
            this.description = data["description"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditConsumableTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditConsumableTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditConsumableTypeDto {
    type: string;
    description: string;
    id: number | undefined;
}

export class PagedResultDtoOfGetContactForViewDto implements IPagedResultDtoOfGetContactForViewDto {
    totalCount!: number | undefined;
    items!: GetContactForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetContactForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetContactForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetContactForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetContactForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetContactForViewDto {
    totalCount: number | undefined;
    items: GetContactForViewDto[] | undefined;
}

export class GetContactForViewDto implements IGetContactForViewDto {
    contact!: ContactDto | undefined;
    userName!: string | undefined;
    vendorName!: string | undefined;
    assetOwnerName!: string | undefined;
    customerName!: string | undefined;

    constructor(data?: IGetContactForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contact = data["contact"] ? ContactDto.fromJS(data["contact"]) : <any>undefined;
            this.userName = data["userName"];
            this.vendorName = data["vendorName"];
            this.assetOwnerName = data["assetOwnerName"];
            this.customerName = data["customerName"];
        }
    }

    static fromJS(data: any): GetContactForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetContactForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contact"] = this.contact ? this.contact.toJSON() : <any>undefined;
        data["userName"] = this.userName;
        data["vendorName"] = this.vendorName;
        data["assetOwnerName"] = this.assetOwnerName;
        data["customerName"] = this.customerName;
        return data; 
    }
}

export interface IGetContactForViewDto {
    contact: ContactDto | undefined;
    userName: string | undefined;
    vendorName: string | undefined;
    assetOwnerName: string | undefined;
    customerName: string | undefined;
}

export class ContactDto implements IContactDto {
    headOfficeContact!: boolean | undefined;
    contactName!: string | undefined;
    phoneOffice!: string | undefined;
    phoneMobile!: string | undefined;
    fax!: string | undefined;
    address!: string | undefined;
    emailAddress!: string | undefined;
    position!: string | undefined;
    department!: string | undefined;
    contactLoc8GUID!: string | undefined;
    userId!: number | undefined;
    vendorId!: number | undefined;
    assetOwnerId!: number | undefined;
    customerId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IContactDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.headOfficeContact = data["headOfficeContact"];
            this.contactName = data["contactName"];
            this.phoneOffice = data["phoneOffice"];
            this.phoneMobile = data["phoneMobile"];
            this.fax = data["fax"];
            this.address = data["address"];
            this.emailAddress = data["emailAddress"];
            this.position = data["position"];
            this.department = data["department"];
            this.contactLoc8GUID = data["contactLoc8GUID"];
            this.userId = data["userId"];
            this.vendorId = data["vendorId"];
            this.assetOwnerId = data["assetOwnerId"];
            this.customerId = data["customerId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ContactDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["headOfficeContact"] = this.headOfficeContact;
        data["contactName"] = this.contactName;
        data["phoneOffice"] = this.phoneOffice;
        data["phoneMobile"] = this.phoneMobile;
        data["fax"] = this.fax;
        data["address"] = this.address;
        data["emailAddress"] = this.emailAddress;
        data["position"] = this.position;
        data["department"] = this.department;
        data["contactLoc8GUID"] = this.contactLoc8GUID;
        data["userId"] = this.userId;
        data["vendorId"] = this.vendorId;
        data["assetOwnerId"] = this.assetOwnerId;
        data["customerId"] = this.customerId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IContactDto {
    headOfficeContact: boolean | undefined;
    contactName: string | undefined;
    phoneOffice: string | undefined;
    phoneMobile: string | undefined;
    fax: string | undefined;
    address: string | undefined;
    emailAddress: string | undefined;
    position: string | undefined;
    department: string | undefined;
    contactLoc8GUID: string | undefined;
    userId: number | undefined;
    vendorId: number | undefined;
    assetOwnerId: number | undefined;
    customerId: number | undefined;
    id: number | undefined;
}

export class GetContactForEditOutput implements IGetContactForEditOutput {
    contact!: CreateOrEditContactDto | undefined;
    userName!: string | undefined;
    vendorName!: string | undefined;
    assetOwnerName!: string | undefined;
    customerName!: string | undefined;

    constructor(data?: IGetContactForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.contact = data["contact"] ? CreateOrEditContactDto.fromJS(data["contact"]) : <any>undefined;
            this.userName = data["userName"];
            this.vendorName = data["vendorName"];
            this.assetOwnerName = data["assetOwnerName"];
            this.customerName = data["customerName"];
        }
    }

    static fromJS(data: any): GetContactForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetContactForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["contact"] = this.contact ? this.contact.toJSON() : <any>undefined;
        data["userName"] = this.userName;
        data["vendorName"] = this.vendorName;
        data["assetOwnerName"] = this.assetOwnerName;
        data["customerName"] = this.customerName;
        return data; 
    }
}

export interface IGetContactForEditOutput {
    contact: CreateOrEditContactDto | undefined;
    userName: string | undefined;
    vendorName: string | undefined;
    assetOwnerName: string | undefined;
    customerName: string | undefined;
}

export class CreateOrEditContactDto implements ICreateOrEditContactDto {
    headOfficeContact!: boolean | undefined;
    contactName!: string | undefined;
    phoneOffice!: string | undefined;
    phoneMobile!: string | undefined;
    fax!: string | undefined;
    address!: string | undefined;
    emailAddress!: string | undefined;
    position!: string | undefined;
    department!: string | undefined;
    contactLoc8GUID!: string | undefined;
    userId!: number | undefined;
    vendorId!: number | undefined;
    assetOwnerId!: number | undefined;
    customerId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditContactDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.headOfficeContact = data["headOfficeContact"];
            this.contactName = data["contactName"];
            this.phoneOffice = data["phoneOffice"];
            this.phoneMobile = data["phoneMobile"];
            this.fax = data["fax"];
            this.address = data["address"];
            this.emailAddress = data["emailAddress"];
            this.position = data["position"];
            this.department = data["department"];
            this.contactLoc8GUID = data["contactLoc8GUID"];
            this.userId = data["userId"];
            this.vendorId = data["vendorId"];
            this.assetOwnerId = data["assetOwnerId"];
            this.customerId = data["customerId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditContactDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditContactDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["headOfficeContact"] = this.headOfficeContact;
        data["contactName"] = this.contactName;
        data["phoneOffice"] = this.phoneOffice;
        data["phoneMobile"] = this.phoneMobile;
        data["fax"] = this.fax;
        data["address"] = this.address;
        data["emailAddress"] = this.emailAddress;
        data["position"] = this.position;
        data["department"] = this.department;
        data["contactLoc8GUID"] = this.contactLoc8GUID;
        data["userId"] = this.userId;
        data["vendorId"] = this.vendorId;
        data["assetOwnerId"] = this.assetOwnerId;
        data["customerId"] = this.customerId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditContactDto {
    headOfficeContact: boolean | undefined;
    contactName: string | undefined;
    phoneOffice: string | undefined;
    phoneMobile: string | undefined;
    fax: string | undefined;
    address: string | undefined;
    emailAddress: string | undefined;
    position: string | undefined;
    department: string | undefined;
    contactLoc8GUID: string | undefined;
    userId: number | undefined;
    vendorId: number | undefined;
    assetOwnerId: number | undefined;
    customerId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfContactUserLookupTableDto implements IPagedResultDtoOfContactUserLookupTableDto {
    totalCount!: number | undefined;
    items!: ContactUserLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfContactUserLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ContactUserLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfContactUserLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfContactUserLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfContactUserLookupTableDto {
    totalCount: number | undefined;
    items: ContactUserLookupTableDto[] | undefined;
}

export class ContactUserLookupTableDto implements IContactUserLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IContactUserLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): ContactUserLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactUserLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IContactUserLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfContactVendorLookupTableDto implements IPagedResultDtoOfContactVendorLookupTableDto {
    totalCount!: number | undefined;
    items!: ContactVendorLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfContactVendorLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ContactVendorLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfContactVendorLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfContactVendorLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfContactVendorLookupTableDto {
    totalCount: number | undefined;
    items: ContactVendorLookupTableDto[] | undefined;
}

export class ContactVendorLookupTableDto implements IContactVendorLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IContactVendorLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): ContactVendorLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactVendorLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IContactVendorLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfContactAssetOwnerLookupTableDto implements IPagedResultDtoOfContactAssetOwnerLookupTableDto {
    totalCount!: number | undefined;
    items!: ContactAssetOwnerLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfContactAssetOwnerLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ContactAssetOwnerLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfContactAssetOwnerLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfContactAssetOwnerLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfContactAssetOwnerLookupTableDto {
    totalCount: number | undefined;
    items: ContactAssetOwnerLookupTableDto[] | undefined;
}

export class ContactAssetOwnerLookupTableDto implements IContactAssetOwnerLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IContactAssetOwnerLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): ContactAssetOwnerLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactAssetOwnerLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IContactAssetOwnerLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfContactCustomerLookupTableDto implements IPagedResultDtoOfContactCustomerLookupTableDto {
    totalCount!: number | undefined;
    items!: ContactCustomerLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfContactCustomerLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ContactCustomerLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfContactCustomerLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfContactCustomerLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfContactCustomerLookupTableDto {
    totalCount: number | undefined;
    items: ContactCustomerLookupTableDto[] | undefined;
}

export class ContactCustomerLookupTableDto implements IContactCustomerLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IContactCustomerLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): ContactCustomerLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ContactCustomerLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IContactCustomerLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetCrossTenantPermissionForViewDto implements IPagedResultDtoOfGetCrossTenantPermissionForViewDto {
    totalCount!: number | undefined;
    items!: GetCrossTenantPermissionForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetCrossTenantPermissionForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetCrossTenantPermissionForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetCrossTenantPermissionForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetCrossTenantPermissionForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetCrossTenantPermissionForViewDto {
    totalCount: number | undefined;
    items: GetCrossTenantPermissionForViewDto[] | undefined;
}

export class GetCrossTenantPermissionForViewDto implements IGetCrossTenantPermissionForViewDto {
    crossTenantPermission!: CrossTenantPermissionDto | undefined;

    constructor(data?: IGetCrossTenantPermissionForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.crossTenantPermission = data["crossTenantPermission"] ? CrossTenantPermissionDto.fromJS(data["crossTenantPermission"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCrossTenantPermissionForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetCrossTenantPermissionForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["crossTenantPermission"] = this.crossTenantPermission ? this.crossTenantPermission.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetCrossTenantPermissionForViewDto {
    crossTenantPermission: CrossTenantPermissionDto | undefined;
}

export class CrossTenantPermissionDto implements ICrossTenantPermissionDto {
    tenantRefId!: number | undefined;
    entityType!: string | undefined;
    tenants!: string | undefined;
    tenantType!: string | undefined;
    id!: number | undefined;

    constructor(data?: ICrossTenantPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantRefId = data["tenantRefId"];
            this.entityType = data["entityType"];
            this.tenants = data["tenants"];
            this.tenantType = data["tenantType"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CrossTenantPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CrossTenantPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantRefId"] = this.tenantRefId;
        data["entityType"] = this.entityType;
        data["tenants"] = this.tenants;
        data["tenantType"] = this.tenantType;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICrossTenantPermissionDto {
    tenantRefId: number | undefined;
    entityType: string | undefined;
    tenants: string | undefined;
    tenantType: string | undefined;
    id: number | undefined;
}

export class GetCrossTenantPermissionForEditOutput implements IGetCrossTenantPermissionForEditOutput {
    crossTenantPermission!: CreateOrEditCrossTenantPermissionDto | undefined;

    constructor(data?: IGetCrossTenantPermissionForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.crossTenantPermission = data["crossTenantPermission"] ? CreateOrEditCrossTenantPermissionDto.fromJS(data["crossTenantPermission"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCrossTenantPermissionForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCrossTenantPermissionForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["crossTenantPermission"] = this.crossTenantPermission ? this.crossTenantPermission.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetCrossTenantPermissionForEditOutput {
    crossTenantPermission: CreateOrEditCrossTenantPermissionDto | undefined;
}

export class CreateOrEditCrossTenantPermissionDto implements ICreateOrEditCrossTenantPermissionDto {
    tenantRefId!: number | undefined;
    entityType!: string;
    tenants!: string | undefined;
    tenantType!: string;
    id!: number | undefined;

    constructor(data?: ICreateOrEditCrossTenantPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantRefId = data["tenantRefId"];
            this.entityType = data["entityType"];
            this.tenants = data["tenants"];
            this.tenantType = data["tenantType"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditCrossTenantPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditCrossTenantPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantRefId"] = this.tenantRefId;
        data["entityType"] = this.entityType;
        data["tenants"] = this.tenants;
        data["tenantType"] = this.tenantType;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditCrossTenantPermissionDto {
    tenantRefId: number | undefined;
    entityType: string;
    tenants: string | undefined;
    tenantType: string;
    id: number | undefined;
}

export class PagedResultDtoOfGetCurrencyForViewDto implements IPagedResultDtoOfGetCurrencyForViewDto {
    totalCount!: number | undefined;
    items!: GetCurrencyForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetCurrencyForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetCurrencyForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetCurrencyForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetCurrencyForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetCurrencyForViewDto {
    totalCount: number | undefined;
    items: GetCurrencyForViewDto[] | undefined;
}

export class GetCurrencyForViewDto implements IGetCurrencyForViewDto {
    currency!: CurrencyDto | undefined;

    constructor(data?: IGetCurrencyForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.currency = data["currency"] ? CurrencyDto.fromJS(data["currency"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCurrencyForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrencyForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currency"] = this.currency ? this.currency.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetCurrencyForViewDto {
    currency: CurrencyDto | undefined;
}

export class CurrencyDto implements ICurrencyDto {
    code!: string | undefined;
    name!: string | undefined;
    symbol!: string | undefined;
    country!: string | undefined;
    baseCountry!: string | undefined;
    id!: number | undefined;

    constructor(data?: ICurrencyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.name = data["name"];
            this.symbol = data["symbol"];
            this.country = data["country"];
            this.baseCountry = data["baseCountry"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CurrencyDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrencyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["symbol"] = this.symbol;
        data["country"] = this.country;
        data["baseCountry"] = this.baseCountry;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICurrencyDto {
    code: string | undefined;
    name: string | undefined;
    symbol: string | undefined;
    country: string | undefined;
    baseCountry: string | undefined;
    id: number | undefined;
}

export class GetCurrencyForEditOutput implements IGetCurrencyForEditOutput {
    currency!: CreateOrEditCurrencyDto | undefined;

    constructor(data?: IGetCurrencyForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.currency = data["currency"] ? CreateOrEditCurrencyDto.fromJS(data["currency"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCurrencyForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrencyForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currency"] = this.currency ? this.currency.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetCurrencyForEditOutput {
    currency: CreateOrEditCurrencyDto | undefined;
}

export class CreateOrEditCurrencyDto implements ICreateOrEditCurrencyDto {
    code!: string;
    name!: string;
    symbol!: string | undefined;
    country!: string;
    baseCountry!: string;
    id!: number | undefined;

    constructor(data?: ICreateOrEditCurrencyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.name = data["name"];
            this.symbol = data["symbol"];
            this.country = data["country"];
            this.baseCountry = data["baseCountry"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditCurrencyDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditCurrencyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["name"] = this.name;
        data["symbol"] = this.symbol;
        data["country"] = this.country;
        data["baseCountry"] = this.baseCountry;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditCurrencyDto {
    code: string;
    name: string;
    symbol: string | undefined;
    country: string;
    baseCountry: string;
    id: number | undefined;
}

export class PagedResultDtoOfGetCustomerGroupMembershipForViewDto implements IPagedResultDtoOfGetCustomerGroupMembershipForViewDto {
    totalCount!: number | undefined;
    items!: GetCustomerGroupMembershipForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetCustomerGroupMembershipForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetCustomerGroupMembershipForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetCustomerGroupMembershipForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetCustomerGroupMembershipForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetCustomerGroupMembershipForViewDto {
    totalCount: number | undefined;
    items: GetCustomerGroupMembershipForViewDto[] | undefined;
}

export class GetCustomerGroupMembershipForViewDto implements IGetCustomerGroupMembershipForViewDto {
    customerGroupMembership!: CustomerGroupMembershipDto | undefined;
    customerGroupName!: string | undefined;
    customerName!: string | undefined;

    constructor(data?: IGetCustomerGroupMembershipForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.customerGroupMembership = data["customerGroupMembership"] ? CustomerGroupMembershipDto.fromJS(data["customerGroupMembership"]) : <any>undefined;
            this.customerGroupName = data["customerGroupName"];
            this.customerName = data["customerName"];
        }
    }

    static fromJS(data: any): GetCustomerGroupMembershipForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetCustomerGroupMembershipForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerGroupMembership"] = this.customerGroupMembership ? this.customerGroupMembership.toJSON() : <any>undefined;
        data["customerGroupName"] = this.customerGroupName;
        data["customerName"] = this.customerName;
        return data; 
    }
}

export interface IGetCustomerGroupMembershipForViewDto {
    customerGroupMembership: CustomerGroupMembershipDto | undefined;
    customerGroupName: string | undefined;
    customerName: string | undefined;
}

export class CustomerGroupMembershipDto implements ICustomerGroupMembershipDto {
    dateJoined!: moment.Moment | undefined;
    dateLeft!: moment.Moment | undefined;
    customerGroupId!: number | undefined;
    customerId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICustomerGroupMembershipDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dateJoined = data["dateJoined"] ? moment(data["dateJoined"].toString()) : <any>undefined;
            this.dateLeft = data["dateLeft"] ? moment(data["dateLeft"].toString()) : <any>undefined;
            this.customerGroupId = data["customerGroupId"];
            this.customerId = data["customerId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CustomerGroupMembershipDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerGroupMembershipDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dateJoined"] = this.dateJoined ? this.dateJoined.toISOString() : <any>undefined;
        data["dateLeft"] = this.dateLeft ? this.dateLeft.toISOString() : <any>undefined;
        data["customerGroupId"] = this.customerGroupId;
        data["customerId"] = this.customerId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICustomerGroupMembershipDto {
    dateJoined: moment.Moment | undefined;
    dateLeft: moment.Moment | undefined;
    customerGroupId: number | undefined;
    customerId: number | undefined;
    id: number | undefined;
}

export class GetCustomerGroupMembershipForEditOutput implements IGetCustomerGroupMembershipForEditOutput {
    customerGroupMembership!: CreateOrEditCustomerGroupMembershipDto | undefined;
    customerGroupName!: string | undefined;
    customerName!: string | undefined;

    constructor(data?: IGetCustomerGroupMembershipForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.customerGroupMembership = data["customerGroupMembership"] ? CreateOrEditCustomerGroupMembershipDto.fromJS(data["customerGroupMembership"]) : <any>undefined;
            this.customerGroupName = data["customerGroupName"];
            this.customerName = data["customerName"];
        }
    }

    static fromJS(data: any): GetCustomerGroupMembershipForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCustomerGroupMembershipForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerGroupMembership"] = this.customerGroupMembership ? this.customerGroupMembership.toJSON() : <any>undefined;
        data["customerGroupName"] = this.customerGroupName;
        data["customerName"] = this.customerName;
        return data; 
    }
}

export interface IGetCustomerGroupMembershipForEditOutput {
    customerGroupMembership: CreateOrEditCustomerGroupMembershipDto | undefined;
    customerGroupName: string | undefined;
    customerName: string | undefined;
}

export class CreateOrEditCustomerGroupMembershipDto implements ICreateOrEditCustomerGroupMembershipDto {
    dateJoined!: moment.Moment | undefined;
    dateLeft!: moment.Moment | undefined;
    customerGroupId!: number | undefined;
    customerId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditCustomerGroupMembershipDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dateJoined = data["dateJoined"] ? moment(data["dateJoined"].toString()) : <any>undefined;
            this.dateLeft = data["dateLeft"] ? moment(data["dateLeft"].toString()) : <any>undefined;
            this.customerGroupId = data["customerGroupId"];
            this.customerId = data["customerId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditCustomerGroupMembershipDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditCustomerGroupMembershipDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dateJoined"] = this.dateJoined ? this.dateJoined.toISOString() : <any>undefined;
        data["dateLeft"] = this.dateLeft ? this.dateLeft.toISOString() : <any>undefined;
        data["customerGroupId"] = this.customerGroupId;
        data["customerId"] = this.customerId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditCustomerGroupMembershipDto {
    dateJoined: moment.Moment | undefined;
    dateLeft: moment.Moment | undefined;
    customerGroupId: number | undefined;
    customerId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfCustomerGroupMembershipCustomerGroupLookupTableDto implements IPagedResultDtoOfCustomerGroupMembershipCustomerGroupLookupTableDto {
    totalCount!: number | undefined;
    items!: CustomerGroupMembershipCustomerGroupLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfCustomerGroupMembershipCustomerGroupLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(CustomerGroupMembershipCustomerGroupLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCustomerGroupMembershipCustomerGroupLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCustomerGroupMembershipCustomerGroupLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfCustomerGroupMembershipCustomerGroupLookupTableDto {
    totalCount: number | undefined;
    items: CustomerGroupMembershipCustomerGroupLookupTableDto[] | undefined;
}

export class CustomerGroupMembershipCustomerGroupLookupTableDto implements ICustomerGroupMembershipCustomerGroupLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: ICustomerGroupMembershipCustomerGroupLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): CustomerGroupMembershipCustomerGroupLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerGroupMembershipCustomerGroupLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface ICustomerGroupMembershipCustomerGroupLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfCustomerGroupMembershipCustomerLookupTableDto implements IPagedResultDtoOfCustomerGroupMembershipCustomerLookupTableDto {
    totalCount!: number | undefined;
    items!: CustomerGroupMembershipCustomerLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfCustomerGroupMembershipCustomerLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(CustomerGroupMembershipCustomerLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCustomerGroupMembershipCustomerLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCustomerGroupMembershipCustomerLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfCustomerGroupMembershipCustomerLookupTableDto {
    totalCount: number | undefined;
    items: CustomerGroupMembershipCustomerLookupTableDto[] | undefined;
}

export class CustomerGroupMembershipCustomerLookupTableDto implements ICustomerGroupMembershipCustomerLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: ICustomerGroupMembershipCustomerLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): CustomerGroupMembershipCustomerLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerGroupMembershipCustomerLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface ICustomerGroupMembershipCustomerLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetCustomerGroupForViewDto implements IPagedResultDtoOfGetCustomerGroupForViewDto {
    totalCount!: number | undefined;
    items!: GetCustomerGroupForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetCustomerGroupForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetCustomerGroupForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetCustomerGroupForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetCustomerGroupForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetCustomerGroupForViewDto {
    totalCount: number | undefined;
    items: GetCustomerGroupForViewDto[] | undefined;
}

export class GetCustomerGroupForViewDto implements IGetCustomerGroupForViewDto {
    customerGroup!: CustomerGroupDto | undefined;

    constructor(data?: IGetCustomerGroupForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.customerGroup = data["customerGroup"] ? CustomerGroupDto.fromJS(data["customerGroup"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCustomerGroupForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetCustomerGroupForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerGroup"] = this.customerGroup ? this.customerGroup.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetCustomerGroupForViewDto {
    customerGroup: CustomerGroupDto | undefined;
}

export class CustomerGroupDto implements ICustomerGroupDto {
    name!: string | undefined;
    description!: string | undefined;
    id!: number | undefined;

    constructor(data?: ICustomerGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.description = data["description"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CustomerGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICustomerGroupDto {
    name: string | undefined;
    description: string | undefined;
    id: number | undefined;
}

export class GetCustomerGroupForEditOutput implements IGetCustomerGroupForEditOutput {
    customerGroup!: CreateOrEditCustomerGroupDto | undefined;

    constructor(data?: IGetCustomerGroupForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.customerGroup = data["customerGroup"] ? CreateOrEditCustomerGroupDto.fromJS(data["customerGroup"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCustomerGroupForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCustomerGroupForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerGroup"] = this.customerGroup ? this.customerGroup.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetCustomerGroupForEditOutput {
    customerGroup: CreateOrEditCustomerGroupDto | undefined;
}

export class CreateOrEditCustomerGroupDto implements ICreateOrEditCustomerGroupDto {
    name!: string;
    description!: string;
    id!: number | undefined;

    constructor(data?: ICreateOrEditCustomerGroupDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.description = data["description"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditCustomerGroupDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditCustomerGroupDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditCustomerGroupDto {
    name: string;
    description: string;
    id: number | undefined;
}

export class PagedResultDtoOfGetCustomerInvoiceDetailForViewDto implements IPagedResultDtoOfGetCustomerInvoiceDetailForViewDto {
    totalCount!: number | undefined;
    items!: GetCustomerInvoiceDetailForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetCustomerInvoiceDetailForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetCustomerInvoiceDetailForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetCustomerInvoiceDetailForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetCustomerInvoiceDetailForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetCustomerInvoiceDetailForViewDto {
    totalCount: number | undefined;
    items: GetCustomerInvoiceDetailForViewDto[] | undefined;
}

export class GetCustomerInvoiceDetailForViewDto implements IGetCustomerInvoiceDetailForViewDto {
    customerInvoiceDetail!: CustomerInvoiceDetailDto | undefined;
    customerInvoiceDescription!: string | undefined;
    itemTypeType!: string | undefined;
    uomUnitOfMeasurement!: string | undefined;
    actionWorkOrderAction!: string | undefined;
    leaseItemItem!: string | undefined;
    assetItem!: string | undefined;

    constructor(data?: IGetCustomerInvoiceDetailForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.customerInvoiceDetail = data["customerInvoiceDetail"] ? CustomerInvoiceDetailDto.fromJS(data["customerInvoiceDetail"]) : <any>undefined;
            this.customerInvoiceDescription = data["customerInvoiceDescription"];
            this.itemTypeType = data["itemTypeType"];
            this.uomUnitOfMeasurement = data["uomUnitOfMeasurement"];
            this.actionWorkOrderAction = data["actionWorkOrderAction"];
            this.leaseItemItem = data["leaseItemItem"];
            this.assetItem = data["assetItem"];
        }
    }

    static fromJS(data: any): GetCustomerInvoiceDetailForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetCustomerInvoiceDetailForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerInvoiceDetail"] = this.customerInvoiceDetail ? this.customerInvoiceDetail.toJSON() : <any>undefined;
        data["customerInvoiceDescription"] = this.customerInvoiceDescription;
        data["itemTypeType"] = this.itemTypeType;
        data["uomUnitOfMeasurement"] = this.uomUnitOfMeasurement;
        data["actionWorkOrderAction"] = this.actionWorkOrderAction;
        data["leaseItemItem"] = this.leaseItemItem;
        data["assetItem"] = this.assetItem;
        return data; 
    }
}

export interface IGetCustomerInvoiceDetailForViewDto {
    customerInvoiceDetail: CustomerInvoiceDetailDto | undefined;
    customerInvoiceDescription: string | undefined;
    itemTypeType: string | undefined;
    uomUnitOfMeasurement: string | undefined;
    actionWorkOrderAction: string | undefined;
    leaseItemItem: string | undefined;
    assetItem: string | undefined;
}

export class CustomerInvoiceDetailDto implements ICustomerInvoiceDetailDto {
    description!: string | undefined;
    quantity!: number | undefined;
    unitPrice!: number | undefined;
    gross!: number | undefined;
    tax!: number | undefined;
    net!: number | undefined;
    discount!: number | undefined;
    charge!: number | undefined;
    billingRuleRefId!: number | undefined;
    customerInvoiceId!: number | undefined;
    itemTypeId!: number | undefined;
    uomId!: number | undefined;
    workOrderActionId!: number | undefined;
    leaseItemId!: number | undefined;
    assetId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICustomerInvoiceDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.description = data["description"];
            this.quantity = data["quantity"];
            this.unitPrice = data["unitPrice"];
            this.gross = data["gross"];
            this.tax = data["tax"];
            this.net = data["net"];
            this.discount = data["discount"];
            this.charge = data["charge"];
            this.billingRuleRefId = data["billingRuleRefId"];
            this.customerInvoiceId = data["customerInvoiceId"];
            this.itemTypeId = data["itemTypeId"];
            this.uomId = data["uomId"];
            this.workOrderActionId = data["workOrderActionId"];
            this.leaseItemId = data["leaseItemId"];
            this.assetId = data["assetId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CustomerInvoiceDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerInvoiceDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["quantity"] = this.quantity;
        data["unitPrice"] = this.unitPrice;
        data["gross"] = this.gross;
        data["tax"] = this.tax;
        data["net"] = this.net;
        data["discount"] = this.discount;
        data["charge"] = this.charge;
        data["billingRuleRefId"] = this.billingRuleRefId;
        data["customerInvoiceId"] = this.customerInvoiceId;
        data["itemTypeId"] = this.itemTypeId;
        data["uomId"] = this.uomId;
        data["workOrderActionId"] = this.workOrderActionId;
        data["leaseItemId"] = this.leaseItemId;
        data["assetId"] = this.assetId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICustomerInvoiceDetailDto {
    description: string | undefined;
    quantity: number | undefined;
    unitPrice: number | undefined;
    gross: number | undefined;
    tax: number | undefined;
    net: number | undefined;
    discount: number | undefined;
    charge: number | undefined;
    billingRuleRefId: number | undefined;
    customerInvoiceId: number | undefined;
    itemTypeId: number | undefined;
    uomId: number | undefined;
    workOrderActionId: number | undefined;
    leaseItemId: number | undefined;
    assetId: number | undefined;
    id: number | undefined;
}

export class GetCustomerInvoiceDetailForEditOutput implements IGetCustomerInvoiceDetailForEditOutput {
    customerInvoiceDetail!: CreateOrEditCustomerInvoiceDetailDto | undefined;
    customerInvoiceDescription!: string | undefined;
    itemTypeType!: string | undefined;
    uomUnitOfMeasurement!: string | undefined;
    actionWorkOrderAction!: string | undefined;
    leaseItemItem!: string | undefined;
    assetItem!: string | undefined;

    constructor(data?: IGetCustomerInvoiceDetailForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.customerInvoiceDetail = data["customerInvoiceDetail"] ? CreateOrEditCustomerInvoiceDetailDto.fromJS(data["customerInvoiceDetail"]) : <any>undefined;
            this.customerInvoiceDescription = data["customerInvoiceDescription"];
            this.itemTypeType = data["itemTypeType"];
            this.uomUnitOfMeasurement = data["uomUnitOfMeasurement"];
            this.actionWorkOrderAction = data["actionWorkOrderAction"];
            this.leaseItemItem = data["leaseItemItem"];
            this.assetItem = data["assetItem"];
        }
    }

    static fromJS(data: any): GetCustomerInvoiceDetailForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCustomerInvoiceDetailForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerInvoiceDetail"] = this.customerInvoiceDetail ? this.customerInvoiceDetail.toJSON() : <any>undefined;
        data["customerInvoiceDescription"] = this.customerInvoiceDescription;
        data["itemTypeType"] = this.itemTypeType;
        data["uomUnitOfMeasurement"] = this.uomUnitOfMeasurement;
        data["actionWorkOrderAction"] = this.actionWorkOrderAction;
        data["leaseItemItem"] = this.leaseItemItem;
        data["assetItem"] = this.assetItem;
        return data; 
    }
}

export interface IGetCustomerInvoiceDetailForEditOutput {
    customerInvoiceDetail: CreateOrEditCustomerInvoiceDetailDto | undefined;
    customerInvoiceDescription: string | undefined;
    itemTypeType: string | undefined;
    uomUnitOfMeasurement: string | undefined;
    actionWorkOrderAction: string | undefined;
    leaseItemItem: string | undefined;
    assetItem: string | undefined;
}

export class CreateOrEditCustomerInvoiceDetailDto implements ICreateOrEditCustomerInvoiceDetailDto {
    description!: string | undefined;
    quantity!: number | undefined;
    unitPrice!: number | undefined;
    gross!: number | undefined;
    tax!: number | undefined;
    net!: number | undefined;
    discount!: number | undefined;
    charge!: number | undefined;
    billingRuleRefId!: number | undefined;
    customerInvoiceId!: number | undefined;
    isTaxable!: boolean | undefined;
    itemTypeId!: number | undefined;
    uomId!: number | undefined;
    workOrderActionId!: number | undefined;
    leaseItemId!: number | undefined;
    assetId!: number | undefined;
    assetOwnershipId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditCustomerInvoiceDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.description = data["description"];
            this.quantity = data["quantity"];
            this.unitPrice = data["unitPrice"];
            this.gross = data["gross"];
            this.tax = data["tax"];
            this.net = data["net"];
            this.discount = data["discount"];
            this.charge = data["charge"];
            this.billingRuleRefId = data["billingRuleRefId"];
            this.customerInvoiceId = data["customerInvoiceId"];
            this.isTaxable = data["isTaxable"];
            this.itemTypeId = data["itemTypeId"];
            this.uomId = data["uomId"];
            this.workOrderActionId = data["workOrderActionId"];
            this.leaseItemId = data["leaseItemId"];
            this.assetId = data["assetId"];
            this.assetOwnershipId = data["assetOwnershipId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditCustomerInvoiceDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditCustomerInvoiceDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["quantity"] = this.quantity;
        data["unitPrice"] = this.unitPrice;
        data["gross"] = this.gross;
        data["tax"] = this.tax;
        data["net"] = this.net;
        data["discount"] = this.discount;
        data["charge"] = this.charge;
        data["billingRuleRefId"] = this.billingRuleRefId;
        data["customerInvoiceId"] = this.customerInvoiceId;
        data["isTaxable"] = this.isTaxable;
        data["itemTypeId"] = this.itemTypeId;
        data["uomId"] = this.uomId;
        data["workOrderActionId"] = this.workOrderActionId;
        data["leaseItemId"] = this.leaseItemId;
        data["assetId"] = this.assetId;
        data["assetOwnershipId"] = this.assetOwnershipId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditCustomerInvoiceDetailDto {
    description: string | undefined;
    quantity: number | undefined;
    unitPrice: number | undefined;
    gross: number | undefined;
    tax: number | undefined;
    net: number | undefined;
    discount: number | undefined;
    charge: number | undefined;
    billingRuleRefId: number | undefined;
    customerInvoiceId: number | undefined;
    isTaxable: boolean | undefined;
    itemTypeId: number | undefined;
    uomId: number | undefined;
    workOrderActionId: number | undefined;
    leaseItemId: number | undefined;
    assetId: number | undefined;
    assetOwnershipId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfCustomerInvoiceDetailCustomerInvoiceLookupTableDto implements IPagedResultDtoOfCustomerInvoiceDetailCustomerInvoiceLookupTableDto {
    totalCount!: number | undefined;
    items!: CustomerInvoiceDetailCustomerInvoiceLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfCustomerInvoiceDetailCustomerInvoiceLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(CustomerInvoiceDetailCustomerInvoiceLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCustomerInvoiceDetailCustomerInvoiceLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCustomerInvoiceDetailCustomerInvoiceLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfCustomerInvoiceDetailCustomerInvoiceLookupTableDto {
    totalCount: number | undefined;
    items: CustomerInvoiceDetailCustomerInvoiceLookupTableDto[] | undefined;
}

export class CustomerInvoiceDetailCustomerInvoiceLookupTableDto implements ICustomerInvoiceDetailCustomerInvoiceLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: ICustomerInvoiceDetailCustomerInvoiceLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): CustomerInvoiceDetailCustomerInvoiceLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerInvoiceDetailCustomerInvoiceLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface ICustomerInvoiceDetailCustomerInvoiceLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfCustomerInvoiceLeaseItemLookupTableDto implements IPagedResultDtoOfCustomerInvoiceLeaseItemLookupTableDto {
    totalCount!: number | undefined;
    items!: CustomerInvoiceLeaseItemLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfCustomerInvoiceLeaseItemLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(CustomerInvoiceLeaseItemLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCustomerInvoiceLeaseItemLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCustomerInvoiceLeaseItemLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfCustomerInvoiceLeaseItemLookupTableDto {
    totalCount: number | undefined;
    items: CustomerInvoiceLeaseItemLookupTableDto[] | undefined;
}

export class CustomerInvoiceLeaseItemLookupTableDto implements ICustomerInvoiceLeaseItemLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: ICustomerInvoiceLeaseItemLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): CustomerInvoiceLeaseItemLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerInvoiceLeaseItemLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface ICustomerInvoiceLeaseItemLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetCustomerInvoiceForViewDto implements IPagedResultDtoOfGetCustomerInvoiceForViewDto {
    totalCount!: number | undefined;
    items!: GetCustomerInvoiceForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetCustomerInvoiceForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetCustomerInvoiceForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetCustomerInvoiceForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetCustomerInvoiceForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetCustomerInvoiceForViewDto {
    totalCount: number | undefined;
    items: GetCustomerInvoiceForViewDto[] | undefined;
}

export class GetCustomerInvoiceForViewDto implements IGetCustomerInvoiceForViewDto {
    customerInvoice!: CustomerInvoiceDto | undefined;
    customerName!: string | undefined;
    customerXeroContactId!: string | undefined;
    workOrderSubject!: string | undefined;
    estimateTitle!: string | undefined;
    currencyCode!: string | undefined;
    billingRuleName!: string | undefined;
    billingEventPurpose!: string | undefined;
    invoiceStatusStatus!: string | undefined;
    customerInvoiceDetails!: PagedResultDtoOfGetCustomerInvoiceDetailForViewDto | undefined;
    assetOwnerInfo!: AssetOwnerDto | undefined;
    customerInfo!: CustomerDto | undefined;
    customerAddress!: AddressDto | undefined;
    customerContact!: ContactDto | undefined;
    authenticationKey!: string | undefined;
    isXeroContactSynced!: boolean | undefined;

    constructor(data?: IGetCustomerInvoiceForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.customerInvoice = data["customerInvoice"] ? CustomerInvoiceDto.fromJS(data["customerInvoice"]) : <any>undefined;
            this.customerName = data["customerName"];
            this.customerXeroContactId = data["customerXeroContactId"];
            this.workOrderSubject = data["workOrderSubject"];
            this.estimateTitle = data["estimateTitle"];
            this.currencyCode = data["currencyCode"];
            this.billingRuleName = data["billingRuleName"];
            this.billingEventPurpose = data["billingEventPurpose"];
            this.invoiceStatusStatus = data["invoiceStatusStatus"];
            this.customerInvoiceDetails = data["customerInvoiceDetails"] ? PagedResultDtoOfGetCustomerInvoiceDetailForViewDto.fromJS(data["customerInvoiceDetails"]) : <any>undefined;
            this.assetOwnerInfo = data["assetOwnerInfo"] ? AssetOwnerDto.fromJS(data["assetOwnerInfo"]) : <any>undefined;
            this.customerInfo = data["customerInfo"] ? CustomerDto.fromJS(data["customerInfo"]) : <any>undefined;
            this.customerAddress = data["customerAddress"] ? AddressDto.fromJS(data["customerAddress"]) : <any>undefined;
            this.customerContact = data["customerContact"] ? ContactDto.fromJS(data["customerContact"]) : <any>undefined;
            this.authenticationKey = data["authenticationKey"];
            this.isXeroContactSynced = data["isXeroContactSynced"];
        }
    }

    static fromJS(data: any): GetCustomerInvoiceForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetCustomerInvoiceForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerInvoice"] = this.customerInvoice ? this.customerInvoice.toJSON() : <any>undefined;
        data["customerName"] = this.customerName;
        data["customerXeroContactId"] = this.customerXeroContactId;
        data["workOrderSubject"] = this.workOrderSubject;
        data["estimateTitle"] = this.estimateTitle;
        data["currencyCode"] = this.currencyCode;
        data["billingRuleName"] = this.billingRuleName;
        data["billingEventPurpose"] = this.billingEventPurpose;
        data["invoiceStatusStatus"] = this.invoiceStatusStatus;
        data["customerInvoiceDetails"] = this.customerInvoiceDetails ? this.customerInvoiceDetails.toJSON() : <any>undefined;
        data["assetOwnerInfo"] = this.assetOwnerInfo ? this.assetOwnerInfo.toJSON() : <any>undefined;
        data["customerInfo"] = this.customerInfo ? this.customerInfo.toJSON() : <any>undefined;
        data["customerAddress"] = this.customerAddress ? this.customerAddress.toJSON() : <any>undefined;
        data["customerContact"] = this.customerContact ? this.customerContact.toJSON() : <any>undefined;
        data["authenticationKey"] = this.authenticationKey;
        data["isXeroContactSynced"] = this.isXeroContactSynced;
        return data; 
    }
}

export interface IGetCustomerInvoiceForViewDto {
    customerInvoice: CustomerInvoiceDto | undefined;
    customerName: string | undefined;
    customerXeroContactId: string | undefined;
    workOrderSubject: string | undefined;
    estimateTitle: string | undefined;
    currencyCode: string | undefined;
    billingRuleName: string | undefined;
    billingEventPurpose: string | undefined;
    invoiceStatusStatus: string | undefined;
    customerInvoiceDetails: PagedResultDtoOfGetCustomerInvoiceDetailForViewDto | undefined;
    assetOwnerInfo: AssetOwnerDto | undefined;
    customerInfo: CustomerDto | undefined;
    customerAddress: AddressDto | undefined;
    customerContact: ContactDto | undefined;
    authenticationKey: string | undefined;
    isXeroContactSynced: boolean | undefined;
}

export class CustomerInvoiceDto implements ICustomerInvoiceDto {
    customerReference!: string | undefined;
    description!: string | undefined;
    dateIssued!: moment.Moment | undefined;
    dateDue!: moment.Moment | undefined;
    totalTax!: number | undefined;
    totalPrice!: number | undefined;
    totalNet!: number | undefined;
    totalDiscount!: number | undefined;
    totalCharge!: number | undefined;
    invoiceRecipient!: string | undefined;
    remarks!: string | undefined;
    customerId!: number | undefined;
    currencyId!: number | undefined;
    billingRuleId!: number | undefined;
    billingEventId!: number | undefined;
    invoiceStatusId!: number | undefined;
    estimateId!: number | undefined;
    workOrderId!: number | undefined;
    tenantId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICustomerInvoiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.customerReference = data["customerReference"];
            this.description = data["description"];
            this.dateIssued = data["dateIssued"] ? moment(data["dateIssued"].toString()) : <any>undefined;
            this.dateDue = data["dateDue"] ? moment(data["dateDue"].toString()) : <any>undefined;
            this.totalTax = data["totalTax"];
            this.totalPrice = data["totalPrice"];
            this.totalNet = data["totalNet"];
            this.totalDiscount = data["totalDiscount"];
            this.totalCharge = data["totalCharge"];
            this.invoiceRecipient = data["invoiceRecipient"];
            this.remarks = data["remarks"];
            this.customerId = data["customerId"];
            this.currencyId = data["currencyId"];
            this.billingRuleId = data["billingRuleId"];
            this.billingEventId = data["billingEventId"];
            this.invoiceStatusId = data["invoiceStatusId"];
            this.estimateId = data["estimateId"];
            this.workOrderId = data["workOrderId"];
            this.tenantId = data["tenantId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CustomerInvoiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerInvoiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerReference"] = this.customerReference;
        data["description"] = this.description;
        data["dateIssued"] = this.dateIssued ? this.dateIssued.toISOString() : <any>undefined;
        data["dateDue"] = this.dateDue ? this.dateDue.toISOString() : <any>undefined;
        data["totalTax"] = this.totalTax;
        data["totalPrice"] = this.totalPrice;
        data["totalNet"] = this.totalNet;
        data["totalDiscount"] = this.totalDiscount;
        data["totalCharge"] = this.totalCharge;
        data["invoiceRecipient"] = this.invoiceRecipient;
        data["remarks"] = this.remarks;
        data["customerId"] = this.customerId;
        data["currencyId"] = this.currencyId;
        data["billingRuleId"] = this.billingRuleId;
        data["billingEventId"] = this.billingEventId;
        data["invoiceStatusId"] = this.invoiceStatusId;
        data["estimateId"] = this.estimateId;
        data["workOrderId"] = this.workOrderId;
        data["tenantId"] = this.tenantId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICustomerInvoiceDto {
    customerReference: string | undefined;
    description: string | undefined;
    dateIssued: moment.Moment | undefined;
    dateDue: moment.Moment | undefined;
    totalTax: number | undefined;
    totalPrice: number | undefined;
    totalNet: number | undefined;
    totalDiscount: number | undefined;
    totalCharge: number | undefined;
    invoiceRecipient: string | undefined;
    remarks: string | undefined;
    customerId: number | undefined;
    currencyId: number | undefined;
    billingRuleId: number | undefined;
    billingEventId: number | undefined;
    invoiceStatusId: number | undefined;
    estimateId: number | undefined;
    workOrderId: number | undefined;
    tenantId: number | undefined;
    id: number | undefined;
}

export class CustomerDto implements ICustomerDto {
    reference!: string | undefined;
    name!: string | undefined;
    identifier!: string | undefined;
    logoUrl!: string | undefined;
    website!: string | undefined;
    customerLoc8UUID!: string | undefined;
    emailAddress!: string | undefined;
    xeroContactPersons!: string | undefined;
    xeroAccountsReceivableTaxType!: string | undefined;
    xeroAccountsPayableTaxType!: string | undefined;
    xeroAddresses!: string | undefined;
    xeroPhones!: string | undefined;
    xeroDefaultCurrency!: string | undefined;
    xeroPaymentTerms!: string | undefined;
    xeroContactId!: string | undefined;
    customerTypeId!: number | undefined;
    currencyId!: number | undefined;
    tenantId!: number | undefined;
    paymentTermNumber!: number | undefined;
    paymentTermType!: string | undefined;
    isXeroContactSynced!: boolean | undefined;
    id!: number | undefined;

    constructor(data?: ICustomerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reference = data["reference"];
            this.name = data["name"];
            this.identifier = data["identifier"];
            this.logoUrl = data["logoUrl"];
            this.website = data["website"];
            this.customerLoc8UUID = data["customerLoc8UUID"];
            this.emailAddress = data["emailAddress"];
            this.xeroContactPersons = data["xeroContactPersons"];
            this.xeroAccountsReceivableTaxType = data["xeroAccountsReceivableTaxType"];
            this.xeroAccountsPayableTaxType = data["xeroAccountsPayableTaxType"];
            this.xeroAddresses = data["xeroAddresses"];
            this.xeroPhones = data["xeroPhones"];
            this.xeroDefaultCurrency = data["xeroDefaultCurrency"];
            this.xeroPaymentTerms = data["xeroPaymentTerms"];
            this.xeroContactId = data["xeroContactId"];
            this.customerTypeId = data["customerTypeId"];
            this.currencyId = data["currencyId"];
            this.tenantId = data["tenantId"];
            this.paymentTermNumber = data["paymentTermNumber"];
            this.paymentTermType = data["paymentTermType"];
            this.isXeroContactSynced = data["isXeroContactSynced"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CustomerDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reference"] = this.reference;
        data["name"] = this.name;
        data["identifier"] = this.identifier;
        data["logoUrl"] = this.logoUrl;
        data["website"] = this.website;
        data["customerLoc8UUID"] = this.customerLoc8UUID;
        data["emailAddress"] = this.emailAddress;
        data["xeroContactPersons"] = this.xeroContactPersons;
        data["xeroAccountsReceivableTaxType"] = this.xeroAccountsReceivableTaxType;
        data["xeroAccountsPayableTaxType"] = this.xeroAccountsPayableTaxType;
        data["xeroAddresses"] = this.xeroAddresses;
        data["xeroPhones"] = this.xeroPhones;
        data["xeroDefaultCurrency"] = this.xeroDefaultCurrency;
        data["xeroPaymentTerms"] = this.xeroPaymentTerms;
        data["xeroContactId"] = this.xeroContactId;
        data["customerTypeId"] = this.customerTypeId;
        data["currencyId"] = this.currencyId;
        data["tenantId"] = this.tenantId;
        data["paymentTermNumber"] = this.paymentTermNumber;
        data["paymentTermType"] = this.paymentTermType;
        data["isXeroContactSynced"] = this.isXeroContactSynced;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICustomerDto {
    reference: string | undefined;
    name: string | undefined;
    identifier: string | undefined;
    logoUrl: string | undefined;
    website: string | undefined;
    customerLoc8UUID: string | undefined;
    emailAddress: string | undefined;
    xeroContactPersons: string | undefined;
    xeroAccountsReceivableTaxType: string | undefined;
    xeroAccountsPayableTaxType: string | undefined;
    xeroAddresses: string | undefined;
    xeroPhones: string | undefined;
    xeroDefaultCurrency: string | undefined;
    xeroPaymentTerms: string | undefined;
    xeroContactId: string | undefined;
    customerTypeId: number | undefined;
    currencyId: number | undefined;
    tenantId: number | undefined;
    paymentTermNumber: number | undefined;
    paymentTermType: string | undefined;
    isXeroContactSynced: boolean | undefined;
    id: number | undefined;
}

export class GetCustomerInvoiceForEditOutput implements IGetCustomerInvoiceForEditOutput {
    customerInvoice!: CreateOrEditCustomerInvoiceDto | undefined;
    customerName!: string | undefined;
    customerXeroContactId!: string | undefined;
    workOrderSubject!: string | undefined;
    estimateTitle!: string | undefined;
    currencyCode!: string | undefined;
    billingRuleName!: string | undefined;
    billingEventPurpose!: string | undefined;
    invoiceStatusStatus!: string | undefined;

    constructor(data?: IGetCustomerInvoiceForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.customerInvoice = data["customerInvoice"] ? CreateOrEditCustomerInvoiceDto.fromJS(data["customerInvoice"]) : <any>undefined;
            this.customerName = data["customerName"];
            this.customerXeroContactId = data["customerXeroContactId"];
            this.workOrderSubject = data["workOrderSubject"];
            this.estimateTitle = data["estimateTitle"];
            this.currencyCode = data["currencyCode"];
            this.billingRuleName = data["billingRuleName"];
            this.billingEventPurpose = data["billingEventPurpose"];
            this.invoiceStatusStatus = data["invoiceStatusStatus"];
        }
    }

    static fromJS(data: any): GetCustomerInvoiceForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCustomerInvoiceForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerInvoice"] = this.customerInvoice ? this.customerInvoice.toJSON() : <any>undefined;
        data["customerName"] = this.customerName;
        data["customerXeroContactId"] = this.customerXeroContactId;
        data["workOrderSubject"] = this.workOrderSubject;
        data["estimateTitle"] = this.estimateTitle;
        data["currencyCode"] = this.currencyCode;
        data["billingRuleName"] = this.billingRuleName;
        data["billingEventPurpose"] = this.billingEventPurpose;
        data["invoiceStatusStatus"] = this.invoiceStatusStatus;
        return data; 
    }
}

export interface IGetCustomerInvoiceForEditOutput {
    customerInvoice: CreateOrEditCustomerInvoiceDto | undefined;
    customerName: string | undefined;
    customerXeroContactId: string | undefined;
    workOrderSubject: string | undefined;
    estimateTitle: string | undefined;
    currencyCode: string | undefined;
    billingRuleName: string | undefined;
    billingEventPurpose: string | undefined;
    invoiceStatusStatus: string | undefined;
}

export class CreateOrEditCustomerInvoiceDto implements ICreateOrEditCustomerInvoiceDto {
    customerReference!: string | undefined;
    description!: string;
    dateIssued!: moment.Moment | undefined;
    dateDue!: moment.Moment | undefined;
    totalTax!: number | undefined;
    totalPrice!: number | undefined;
    totalNet!: number | undefined;
    totalDiscount!: number | undefined;
    totalCharge!: number | undefined;
    invoiceRecipient!: string | undefined;
    remarks!: string | undefined;
    customerId!: number | undefined;
    currencyId!: number | undefined;
    billingRuleId!: number | undefined;
    billingEventId!: number | undefined;
    invoiceStatusId!: number | undefined;
    estimateId!: number | undefined;
    workOrderId!: number | undefined;
    assetOwnerId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditCustomerInvoiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.customerReference = data["customerReference"];
            this.description = data["description"];
            this.dateIssued = data["dateIssued"] ? moment(data["dateIssued"].toString()) : <any>undefined;
            this.dateDue = data["dateDue"] ? moment(data["dateDue"].toString()) : <any>undefined;
            this.totalTax = data["totalTax"];
            this.totalPrice = data["totalPrice"];
            this.totalNet = data["totalNet"];
            this.totalDiscount = data["totalDiscount"];
            this.totalCharge = data["totalCharge"];
            this.invoiceRecipient = data["invoiceRecipient"];
            this.remarks = data["remarks"];
            this.customerId = data["customerId"];
            this.currencyId = data["currencyId"];
            this.billingRuleId = data["billingRuleId"];
            this.billingEventId = data["billingEventId"];
            this.invoiceStatusId = data["invoiceStatusId"];
            this.estimateId = data["estimateId"];
            this.workOrderId = data["workOrderId"];
            this.assetOwnerId = data["assetOwnerId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditCustomerInvoiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditCustomerInvoiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerReference"] = this.customerReference;
        data["description"] = this.description;
        data["dateIssued"] = this.dateIssued ? this.dateIssued.toISOString() : <any>undefined;
        data["dateDue"] = this.dateDue ? this.dateDue.toISOString() : <any>undefined;
        data["totalTax"] = this.totalTax;
        data["totalPrice"] = this.totalPrice;
        data["totalNet"] = this.totalNet;
        data["totalDiscount"] = this.totalDiscount;
        data["totalCharge"] = this.totalCharge;
        data["invoiceRecipient"] = this.invoiceRecipient;
        data["remarks"] = this.remarks;
        data["customerId"] = this.customerId;
        data["currencyId"] = this.currencyId;
        data["billingRuleId"] = this.billingRuleId;
        data["billingEventId"] = this.billingEventId;
        data["invoiceStatusId"] = this.invoiceStatusId;
        data["estimateId"] = this.estimateId;
        data["workOrderId"] = this.workOrderId;
        data["assetOwnerId"] = this.assetOwnerId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditCustomerInvoiceDto {
    customerReference: string | undefined;
    description: string;
    dateIssued: moment.Moment | undefined;
    dateDue: moment.Moment | undefined;
    totalTax: number | undefined;
    totalPrice: number | undefined;
    totalNet: number | undefined;
    totalDiscount: number | undefined;
    totalCharge: number | undefined;
    invoiceRecipient: string | undefined;
    remarks: string | undefined;
    customerId: number | undefined;
    currencyId: number | undefined;
    billingRuleId: number | undefined;
    billingEventId: number | undefined;
    invoiceStatusId: number | undefined;
    estimateId: number | undefined;
    workOrderId: number | undefined;
    assetOwnerId: number | undefined;
    id: number | undefined;
}

export class XeroResponse implements IXeroResponse {
    result!: string | undefined;
    byteData!: string | undefined;

    constructor(data?: IXeroResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.result = data["result"];
            this.byteData = data["byteData"];
        }
    }

    static fromJS(data: any): XeroResponse {
        data = typeof data === 'object' ? data : {};
        let result = new XeroResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["result"] = this.result;
        data["byteData"] = this.byteData;
        return data; 
    }
}

export interface IXeroResponse {
    result: string | undefined;
    byteData: string | undefined;
}

export class PagedResultDtoOfCustomerInvoiceCustomerLookupTableDto implements IPagedResultDtoOfCustomerInvoiceCustomerLookupTableDto {
    totalCount!: number | undefined;
    items!: CustomerInvoiceCustomerLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfCustomerInvoiceCustomerLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(CustomerInvoiceCustomerLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCustomerInvoiceCustomerLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCustomerInvoiceCustomerLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfCustomerInvoiceCustomerLookupTableDto {
    totalCount: number | undefined;
    items: CustomerInvoiceCustomerLookupTableDto[] | undefined;
}

export class CustomerInvoiceCustomerLookupTableDto implements ICustomerInvoiceCustomerLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: ICustomerInvoiceCustomerLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): CustomerInvoiceCustomerLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerInvoiceCustomerLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface ICustomerInvoiceCustomerLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfCustomerInvoiceCurrencyLookupTableDto implements IPagedResultDtoOfCustomerInvoiceCurrencyLookupTableDto {
    totalCount!: number | undefined;
    items!: CustomerInvoiceCurrencyLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfCustomerInvoiceCurrencyLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(CustomerInvoiceCurrencyLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCustomerInvoiceCurrencyLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCustomerInvoiceCurrencyLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfCustomerInvoiceCurrencyLookupTableDto {
    totalCount: number | undefined;
    items: CustomerInvoiceCurrencyLookupTableDto[] | undefined;
}

export class CustomerInvoiceCurrencyLookupTableDto implements ICustomerInvoiceCurrencyLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: ICustomerInvoiceCurrencyLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): CustomerInvoiceCurrencyLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerInvoiceCurrencyLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface ICustomerInvoiceCurrencyLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfCustomerInvoiceBillingRuleLookupTableDto implements IPagedResultDtoOfCustomerInvoiceBillingRuleLookupTableDto {
    totalCount!: number | undefined;
    items!: CustomerInvoiceBillingRuleLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfCustomerInvoiceBillingRuleLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(CustomerInvoiceBillingRuleLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCustomerInvoiceBillingRuleLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCustomerInvoiceBillingRuleLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfCustomerInvoiceBillingRuleLookupTableDto {
    totalCount: number | undefined;
    items: CustomerInvoiceBillingRuleLookupTableDto[] | undefined;
}

export class CustomerInvoiceBillingRuleLookupTableDto implements ICustomerInvoiceBillingRuleLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: ICustomerInvoiceBillingRuleLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): CustomerInvoiceBillingRuleLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerInvoiceBillingRuleLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface ICustomerInvoiceBillingRuleLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfCustomerInvoiceBillingEventLookupTableDto implements IPagedResultDtoOfCustomerInvoiceBillingEventLookupTableDto {
    totalCount!: number | undefined;
    items!: CustomerInvoiceBillingEventLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfCustomerInvoiceBillingEventLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(CustomerInvoiceBillingEventLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCustomerInvoiceBillingEventLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCustomerInvoiceBillingEventLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfCustomerInvoiceBillingEventLookupTableDto {
    totalCount: number | undefined;
    items: CustomerInvoiceBillingEventLookupTableDto[] | undefined;
}

export class CustomerInvoiceBillingEventLookupTableDto implements ICustomerInvoiceBillingEventLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: ICustomerInvoiceBillingEventLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): CustomerInvoiceBillingEventLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerInvoiceBillingEventLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface ICustomerInvoiceBillingEventLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfCustomerInvoiceInvoiceStatusLookupTableDto implements IPagedResultDtoOfCustomerInvoiceInvoiceStatusLookupTableDto {
    totalCount!: number | undefined;
    items!: CustomerInvoiceInvoiceStatusLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfCustomerInvoiceInvoiceStatusLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(CustomerInvoiceInvoiceStatusLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCustomerInvoiceInvoiceStatusLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCustomerInvoiceInvoiceStatusLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfCustomerInvoiceInvoiceStatusLookupTableDto {
    totalCount: number | undefined;
    items: CustomerInvoiceInvoiceStatusLookupTableDto[] | undefined;
}

export class CustomerInvoiceInvoiceStatusLookupTableDto implements ICustomerInvoiceInvoiceStatusLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: ICustomerInvoiceInvoiceStatusLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): CustomerInvoiceInvoiceStatusLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerInvoiceInvoiceStatusLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface ICustomerInvoiceInvoiceStatusLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfCustomerInvoiceWorkOrderLookupTableDto implements IPagedResultDtoOfCustomerInvoiceWorkOrderLookupTableDto {
    totalCount!: number | undefined;
    items!: CustomerInvoiceWorkOrderLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfCustomerInvoiceWorkOrderLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(CustomerInvoiceWorkOrderLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCustomerInvoiceWorkOrderLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCustomerInvoiceWorkOrderLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfCustomerInvoiceWorkOrderLookupTableDto {
    totalCount: number | undefined;
    items: CustomerInvoiceWorkOrderLookupTableDto[] | undefined;
}

export class CustomerInvoiceWorkOrderLookupTableDto implements ICustomerInvoiceWorkOrderLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: ICustomerInvoiceWorkOrderLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): CustomerInvoiceWorkOrderLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerInvoiceWorkOrderLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface ICustomerInvoiceWorkOrderLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfCustomerInvoiceEstimateLookupTableDto implements IPagedResultDtoOfCustomerInvoiceEstimateLookupTableDto {
    totalCount!: number | undefined;
    items!: CustomerInvoiceEstimateLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfCustomerInvoiceEstimateLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(CustomerInvoiceEstimateLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCustomerInvoiceEstimateLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCustomerInvoiceEstimateLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfCustomerInvoiceEstimateLookupTableDto {
    totalCount: number | undefined;
    items: CustomerInvoiceEstimateLookupTableDto[] | undefined;
}

export class CustomerInvoiceEstimateLookupTableDto implements ICustomerInvoiceEstimateLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: ICustomerInvoiceEstimateLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): CustomerInvoiceEstimateLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerInvoiceEstimateLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface ICustomerInvoiceEstimateLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class CustomerInvoiceWorkOrderFkListDto implements ICustomerInvoiceWorkOrderFkListDto {
    customerList!: CustomerInvoiceCustomerLookupTableDto[] | undefined;
    estimateList!: CustomerInvoiceEstimateLookupTableDto[] | undefined;

    constructor(data?: ICustomerInvoiceWorkOrderFkListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["customerList"])) {
                this.customerList = [] as any;
                for (let item of data["customerList"])
                    this.customerList!.push(CustomerInvoiceCustomerLookupTableDto.fromJS(item));
            }
            if (Array.isArray(data["estimateList"])) {
                this.estimateList = [] as any;
                for (let item of data["estimateList"])
                    this.estimateList!.push(CustomerInvoiceEstimateLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CustomerInvoiceWorkOrderFkListDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerInvoiceWorkOrderFkListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.customerList)) {
            data["customerList"] = [];
            for (let item of this.customerList)
                data["customerList"].push(item.toJSON());
        }
        if (Array.isArray(this.estimateList)) {
            data["estimateList"] = [];
            for (let item of this.estimateList)
                data["estimateList"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICustomerInvoiceWorkOrderFkListDto {
    customerList: CustomerInvoiceCustomerLookupTableDto[] | undefined;
    estimateList: CustomerInvoiceEstimateLookupTableDto[] | undefined;
}

export class CustomerInvoiceEstimateFkListDto implements ICustomerInvoiceEstimateFkListDto {
    customerList!: CustomerInvoiceCustomerLookupTableDto[] | undefined;

    constructor(data?: ICustomerInvoiceEstimateFkListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["customerList"])) {
                this.customerList = [] as any;
                for (let item of data["customerList"])
                    this.customerList!.push(CustomerInvoiceCustomerLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CustomerInvoiceEstimateFkListDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerInvoiceEstimateFkListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.customerList)) {
            data["customerList"] = [];
            for (let item of this.customerList)
                data["customerList"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICustomerInvoiceEstimateFkListDto {
    customerList: CustomerInvoiceCustomerLookupTableDto[] | undefined;
}

export class GetCustomerInvoiceEstimateForViewDto implements IGetCustomerInvoiceEstimateForViewDto {
    estimate!: GetEstimateForViewDto | undefined;
    estimateDetails!: PagedResultDtoOfGetEstimateDetailForViewDto | undefined;

    constructor(data?: IGetCustomerInvoiceEstimateForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.estimate = data["estimate"] ? GetEstimateForViewDto.fromJS(data["estimate"]) : <any>undefined;
            this.estimateDetails = data["estimateDetails"] ? PagedResultDtoOfGetEstimateDetailForViewDto.fromJS(data["estimateDetails"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCustomerInvoiceEstimateForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetCustomerInvoiceEstimateForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["estimate"] = this.estimate ? this.estimate.toJSON() : <any>undefined;
        data["estimateDetails"] = this.estimateDetails ? this.estimateDetails.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetCustomerInvoiceEstimateForViewDto {
    estimate: GetEstimateForViewDto | undefined;
    estimateDetails: PagedResultDtoOfGetEstimateDetailForViewDto | undefined;
}

export class GetEstimateForViewDto implements IGetEstimateForViewDto {
    estimate!: EstimateDto | undefined;
    workOrderSubject!: string | undefined;
    quotationTitle!: string | undefined;
    estimateStatusStatus!: string | undefined;
    customerName!: string | undefined;

    constructor(data?: IGetEstimateForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.estimate = data["estimate"] ? EstimateDto.fromJS(data["estimate"]) : <any>undefined;
            this.workOrderSubject = data["workOrderSubject"];
            this.quotationTitle = data["quotationTitle"];
            this.estimateStatusStatus = data["estimateStatusStatus"];
            this.customerName = data["customerName"];
        }
    }

    static fromJS(data: any): GetEstimateForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetEstimateForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["estimate"] = this.estimate ? this.estimate.toJSON() : <any>undefined;
        data["workOrderSubject"] = this.workOrderSubject;
        data["quotationTitle"] = this.quotationTitle;
        data["estimateStatusStatus"] = this.estimateStatusStatus;
        data["customerName"] = this.customerName;
        return data; 
    }
}

export interface IGetEstimateForViewDto {
    estimate: EstimateDto | undefined;
    workOrderSubject: string | undefined;
    quotationTitle: string | undefined;
    estimateStatusStatus: string | undefined;
    customerName: string | undefined;
}

export class PagedResultDtoOfGetEstimateDetailForViewDto implements IPagedResultDtoOfGetEstimateDetailForViewDto {
    totalCount!: number | undefined;
    items!: GetEstimateDetailForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetEstimateDetailForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetEstimateDetailForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetEstimateDetailForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetEstimateDetailForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetEstimateDetailForViewDto {
    totalCount: number | undefined;
    items: GetEstimateDetailForViewDto[] | undefined;
}

export class EstimateDto implements IEstimateDto {
    reference!: string | undefined;
    title!: string | undefined;
    description!: string | undefined;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    totalTax!: number | undefined;
    totalPrice!: number | undefined;
    totalDiscount!: number | undefined;
    totalCharge!: number | undefined;
    version!: number | undefined;
    remark!: string | undefined;
    requoteRefId!: number | undefined;
    quotationLoc8GUID!: string | undefined;
    acknowledgedBy!: number | undefined;
    acknowledgedAt!: moment.Moment | undefined;
    quotationId!: number | undefined;
    workOrderId!: number | undefined;
    estimateStatusId!: number | undefined;
    customerId!: number | undefined;
    tenantId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IEstimateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reference = data["reference"];
            this.title = data["title"];
            this.description = data["description"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.totalTax = data["totalTax"];
            this.totalPrice = data["totalPrice"];
            this.totalDiscount = data["totalDiscount"];
            this.totalCharge = data["totalCharge"];
            this.version = data["version"];
            this.remark = data["remark"];
            this.requoteRefId = data["requoteRefId"];
            this.quotationLoc8GUID = data["quotationLoc8GUID"];
            this.acknowledgedBy = data["acknowledgedBy"];
            this.acknowledgedAt = data["acknowledgedAt"] ? moment(data["acknowledgedAt"].toString()) : <any>undefined;
            this.quotationId = data["quotationId"];
            this.workOrderId = data["workOrderId"];
            this.estimateStatusId = data["estimateStatusId"];
            this.customerId = data["customerId"];
            this.tenantId = data["tenantId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EstimateDto {
        data = typeof data === 'object' ? data : {};
        let result = new EstimateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reference"] = this.reference;
        data["title"] = this.title;
        data["description"] = this.description;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["totalTax"] = this.totalTax;
        data["totalPrice"] = this.totalPrice;
        data["totalDiscount"] = this.totalDiscount;
        data["totalCharge"] = this.totalCharge;
        data["version"] = this.version;
        data["remark"] = this.remark;
        data["requoteRefId"] = this.requoteRefId;
        data["quotationLoc8GUID"] = this.quotationLoc8GUID;
        data["acknowledgedBy"] = this.acknowledgedBy;
        data["acknowledgedAt"] = this.acknowledgedAt ? this.acknowledgedAt.toISOString() : <any>undefined;
        data["quotationId"] = this.quotationId;
        data["workOrderId"] = this.workOrderId;
        data["estimateStatusId"] = this.estimateStatusId;
        data["customerId"] = this.customerId;
        data["tenantId"] = this.tenantId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IEstimateDto {
    reference: string | undefined;
    title: string | undefined;
    description: string | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    totalTax: number | undefined;
    totalPrice: number | undefined;
    totalDiscount: number | undefined;
    totalCharge: number | undefined;
    version: number | undefined;
    remark: string | undefined;
    requoteRefId: number | undefined;
    quotationLoc8GUID: string | undefined;
    acknowledgedBy: number | undefined;
    acknowledgedAt: moment.Moment | undefined;
    quotationId: number | undefined;
    workOrderId: number | undefined;
    estimateStatusId: number | undefined;
    customerId: number | undefined;
    tenantId: number | undefined;
    id: number | undefined;
}

export class GetEstimateDetailForViewDto implements IGetEstimateDetailForViewDto {
    estimateDetail!: EstimateDetailDto | undefined;
    itemTypeType!: string | undefined;
    estimateTitle!: string | undefined;
    uomUnitOfMeasurement!: string | undefined;
    actionWorkOrderAction!: string | undefined;

    constructor(data?: IGetEstimateDetailForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.estimateDetail = data["estimateDetail"] ? EstimateDetailDto.fromJS(data["estimateDetail"]) : <any>undefined;
            this.itemTypeType = data["itemTypeType"];
            this.estimateTitle = data["estimateTitle"];
            this.uomUnitOfMeasurement = data["uomUnitOfMeasurement"];
            this.actionWorkOrderAction = data["actionWorkOrderAction"];
        }
    }

    static fromJS(data: any): GetEstimateDetailForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetEstimateDetailForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["estimateDetail"] = this.estimateDetail ? this.estimateDetail.toJSON() : <any>undefined;
        data["itemTypeType"] = this.itemTypeType;
        data["estimateTitle"] = this.estimateTitle;
        data["uomUnitOfMeasurement"] = this.uomUnitOfMeasurement;
        data["actionWorkOrderAction"] = this.actionWorkOrderAction;
        return data; 
    }
}

export interface IGetEstimateDetailForViewDto {
    estimateDetail: EstimateDetailDto | undefined;
    itemTypeType: string | undefined;
    estimateTitle: string | undefined;
    uomUnitOfMeasurement: string | undefined;
    actionWorkOrderAction: string | undefined;
}

export class EstimateDetailDto implements IEstimateDetailDto {
    description!: string | undefined;
    quantity!: number | undefined;
    unitPrice!: number | undefined;
    cost!: number | undefined;
    tax!: number | undefined;
    charge!: number | undefined;
    discount!: number | undefined;
    markUp!: number | undefined;
    isChargeable!: boolean | undefined;
    isAdHoc!: boolean | undefined;
    isStandbyReplacementUnit!: boolean | undefined;
    isOptionalItem!: boolean | undefined;
    remark!: string | undefined;
    loc8GUID!: string | undefined;
    itemTypeId!: number | undefined;
    estimateId!: number | undefined;
    uomId!: number | undefined;
    workOrderActionId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IEstimateDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.description = data["description"];
            this.quantity = data["quantity"];
            this.unitPrice = data["unitPrice"];
            this.cost = data["cost"];
            this.tax = data["tax"];
            this.charge = data["charge"];
            this.discount = data["discount"];
            this.markUp = data["markUp"];
            this.isChargeable = data["isChargeable"];
            this.isAdHoc = data["isAdHoc"];
            this.isStandbyReplacementUnit = data["isStandbyReplacementUnit"];
            this.isOptionalItem = data["isOptionalItem"];
            this.remark = data["remark"];
            this.loc8GUID = data["loc8GUID"];
            this.itemTypeId = data["itemTypeId"];
            this.estimateId = data["estimateId"];
            this.uomId = data["uomId"];
            this.workOrderActionId = data["workOrderActionId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EstimateDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new EstimateDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["quantity"] = this.quantity;
        data["unitPrice"] = this.unitPrice;
        data["cost"] = this.cost;
        data["tax"] = this.tax;
        data["charge"] = this.charge;
        data["discount"] = this.discount;
        data["markUp"] = this.markUp;
        data["isChargeable"] = this.isChargeable;
        data["isAdHoc"] = this.isAdHoc;
        data["isStandbyReplacementUnit"] = this.isStandbyReplacementUnit;
        data["isOptionalItem"] = this.isOptionalItem;
        data["remark"] = this.remark;
        data["loc8GUID"] = this.loc8GUID;
        data["itemTypeId"] = this.itemTypeId;
        data["estimateId"] = this.estimateId;
        data["uomId"] = this.uomId;
        data["workOrderActionId"] = this.workOrderActionId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IEstimateDetailDto {
    description: string | undefined;
    quantity: number | undefined;
    unitPrice: number | undefined;
    cost: number | undefined;
    tax: number | undefined;
    charge: number | undefined;
    discount: number | undefined;
    markUp: number | undefined;
    isChargeable: boolean | undefined;
    isAdHoc: boolean | undefined;
    isStandbyReplacementUnit: boolean | undefined;
    isOptionalItem: boolean | undefined;
    remark: string | undefined;
    loc8GUID: string | undefined;
    itemTypeId: number | undefined;
    estimateId: number | undefined;
    uomId: number | undefined;
    workOrderActionId: number | undefined;
    id: number | undefined;
}

export class GetCustomerInvoiceWorkOrderForViewDto implements IGetCustomerInvoiceWorkOrderForViewDto {
    workOrder!: GetWorkOrderForViewDto | undefined;
    workOrderUpdates!: PagedResultDtoOfGetWorkOrderUpdateForViewDto | undefined;

    constructor(data?: IGetCustomerInvoiceWorkOrderForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.workOrder = data["workOrder"] ? GetWorkOrderForViewDto.fromJS(data["workOrder"]) : <any>undefined;
            this.workOrderUpdates = data["workOrderUpdates"] ? PagedResultDtoOfGetWorkOrderUpdateForViewDto.fromJS(data["workOrderUpdates"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCustomerInvoiceWorkOrderForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetCustomerInvoiceWorkOrderForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workOrder"] = this.workOrder ? this.workOrder.toJSON() : <any>undefined;
        data["workOrderUpdates"] = this.workOrderUpdates ? this.workOrderUpdates.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetCustomerInvoiceWorkOrderForViewDto {
    workOrder: GetWorkOrderForViewDto | undefined;
    workOrderUpdates: PagedResultDtoOfGetWorkOrderUpdateForViewDto | undefined;
}

export class PagedResultDtoOfGetWorkOrderUpdateForViewDto implements IPagedResultDtoOfGetWorkOrderUpdateForViewDto {
    totalCount!: number | undefined;
    items!: GetWorkOrderUpdateForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetWorkOrderUpdateForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetWorkOrderUpdateForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetWorkOrderUpdateForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetWorkOrderUpdateForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetWorkOrderUpdateForViewDto {
    totalCount: number | undefined;
    items: GetWorkOrderUpdateForViewDto[] | undefined;
}

export class GetWorkOrderUpdateForViewDto implements IGetWorkOrderUpdateForViewDto {
    workOrderUpdate!: WorkOrderUpdateDto | undefined;
    workOrderSubject!: string | undefined;
    itemTypeType!: string | undefined;
    workOrderActionAction!: string | undefined;
    assetPartName!: string | undefined;

    constructor(data?: IGetWorkOrderUpdateForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.workOrderUpdate = data["workOrderUpdate"] ? WorkOrderUpdateDto.fromJS(data["workOrderUpdate"]) : <any>undefined;
            this.workOrderSubject = data["workOrderSubject"];
            this.itemTypeType = data["itemTypeType"];
            this.workOrderActionAction = data["workOrderActionAction"];
            this.assetPartName = data["assetPartName"];
        }
    }

    static fromJS(data: any): GetWorkOrderUpdateForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetWorkOrderUpdateForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workOrderUpdate"] = this.workOrderUpdate ? this.workOrderUpdate.toJSON() : <any>undefined;
        data["workOrderSubject"] = this.workOrderSubject;
        data["itemTypeType"] = this.itemTypeType;
        data["workOrderActionAction"] = this.workOrderActionAction;
        data["assetPartName"] = this.assetPartName;
        return data; 
    }
}

export interface IGetWorkOrderUpdateForViewDto {
    workOrderUpdate: WorkOrderUpdateDto | undefined;
    workOrderSubject: string | undefined;
    itemTypeType: string | undefined;
    workOrderActionAction: string | undefined;
    assetPartName: string | undefined;
}

export class WorkOrderUpdateDto implements IWorkOrderUpdateDto {
    comments!: string | undefined;
    number!: number | undefined;
    completed!: boolean | undefined;
    workOrderId!: number | undefined;
    itemTypeId!: number | undefined;
    workOrderActionId!: number | undefined;
    assetPartId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IWorkOrderUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.comments = data["comments"];
            this.number = data["number"];
            this.completed = data["completed"];
            this.workOrderId = data["workOrderId"];
            this.itemTypeId = data["itemTypeId"];
            this.workOrderActionId = data["workOrderActionId"];
            this.assetPartId = data["assetPartId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): WorkOrderUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkOrderUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["comments"] = this.comments;
        data["number"] = this.number;
        data["completed"] = this.completed;
        data["workOrderId"] = this.workOrderId;
        data["itemTypeId"] = this.itemTypeId;
        data["workOrderActionId"] = this.workOrderActionId;
        data["assetPartId"] = this.assetPartId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IWorkOrderUpdateDto {
    comments: string | undefined;
    number: number | undefined;
    completed: boolean | undefined;
    workOrderId: number | undefined;
    itemTypeId: number | undefined;
    workOrderActionId: number | undefined;
    assetPartId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfGetCustomerInvoiceStatusForViewDto implements IPagedResultDtoOfGetCustomerInvoiceStatusForViewDto {
    totalCount!: number | undefined;
    items!: GetCustomerInvoiceStatusForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetCustomerInvoiceStatusForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetCustomerInvoiceStatusForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetCustomerInvoiceStatusForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetCustomerInvoiceStatusForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetCustomerInvoiceStatusForViewDto {
    totalCount: number | undefined;
    items: GetCustomerInvoiceStatusForViewDto[] | undefined;
}

export class GetCustomerInvoiceStatusForViewDto implements IGetCustomerInvoiceStatusForViewDto {
    customerInvoiceStatus!: CustomerInvoiceStatusDto | undefined;

    constructor(data?: IGetCustomerInvoiceStatusForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.customerInvoiceStatus = data["customerInvoiceStatus"] ? CustomerInvoiceStatusDto.fromJS(data["customerInvoiceStatus"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCustomerInvoiceStatusForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetCustomerInvoiceStatusForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerInvoiceStatus"] = this.customerInvoiceStatus ? this.customerInvoiceStatus.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetCustomerInvoiceStatusForViewDto {
    customerInvoiceStatus: CustomerInvoiceStatusDto | undefined;
}

export class CustomerInvoiceStatusDto implements ICustomerInvoiceStatusDto {
    status!: string | undefined;
    description!: string | undefined;
    id!: number | undefined;

    constructor(data?: ICustomerInvoiceStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"];
            this.description = data["description"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CustomerInvoiceStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerInvoiceStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICustomerInvoiceStatusDto {
    status: string | undefined;
    description: string | undefined;
    id: number | undefined;
}

export class GetCustomerInvoiceStatusForEditOutput implements IGetCustomerInvoiceStatusForEditOutput {
    customerInvoiceStatus!: CreateOrEditCustomerInvoiceStatusDto | undefined;

    constructor(data?: IGetCustomerInvoiceStatusForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.customerInvoiceStatus = data["customerInvoiceStatus"] ? CreateOrEditCustomerInvoiceStatusDto.fromJS(data["customerInvoiceStatus"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCustomerInvoiceStatusForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCustomerInvoiceStatusForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerInvoiceStatus"] = this.customerInvoiceStatus ? this.customerInvoiceStatus.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetCustomerInvoiceStatusForEditOutput {
    customerInvoiceStatus: CreateOrEditCustomerInvoiceStatusDto | undefined;
}

export class CreateOrEditCustomerInvoiceStatusDto implements ICreateOrEditCustomerInvoiceStatusDto {
    status!: string;
    description!: string;
    id!: number | undefined;

    constructor(data?: ICreateOrEditCustomerInvoiceStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"];
            this.description = data["description"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditCustomerInvoiceStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditCustomerInvoiceStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditCustomerInvoiceStatusDto {
    status: string;
    description: string;
    id: number | undefined;
}

export class PagedResultDtoOfGetCustomerForViewDto implements IPagedResultDtoOfGetCustomerForViewDto {
    totalCount!: number | undefined;
    items!: GetCustomerForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetCustomerForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetCustomerForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetCustomerForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetCustomerForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetCustomerForViewDto {
    totalCount: number | undefined;
    items: GetCustomerForViewDto[] | undefined;
}

export class GetCustomerForViewDto implements IGetCustomerForViewDto {
    customer!: CustomerDto | undefined;
    customerTypeType!: string | undefined;
    currencyCode!: string | undefined;
    paymentTermNumber!: number | undefined;
    paymentTermType!: string | undefined;

    constructor(data?: IGetCustomerForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.customer = data["customer"] ? CustomerDto.fromJS(data["customer"]) : <any>undefined;
            this.customerTypeType = data["customerTypeType"];
            this.currencyCode = data["currencyCode"];
            this.paymentTermNumber = data["paymentTermNumber"];
            this.paymentTermType = data["paymentTermType"];
        }
    }

    static fromJS(data: any): GetCustomerForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetCustomerForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["customerTypeType"] = this.customerTypeType;
        data["currencyCode"] = this.currencyCode;
        data["paymentTermNumber"] = this.paymentTermNumber;
        data["paymentTermType"] = this.paymentTermType;
        return data; 
    }
}

export interface IGetCustomerForViewDto {
    customer: CustomerDto | undefined;
    customerTypeType: string | undefined;
    currencyCode: string | undefined;
    paymentTermNumber: number | undefined;
    paymentTermType: string | undefined;
}

export class GetCustomerForEditOutput implements IGetCustomerForEditOutput {
    customer!: CreateOrEditCustomerDto | undefined;
    customerTypeType!: string | undefined;
    currencyCode!: string | undefined;

    constructor(data?: IGetCustomerForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.customer = data["customer"] ? CreateOrEditCustomerDto.fromJS(data["customer"]) : <any>undefined;
            this.customerTypeType = data["customerTypeType"];
            this.currencyCode = data["currencyCode"];
        }
    }

    static fromJS(data: any): GetCustomerForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCustomerForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customer"] = this.customer ? this.customer.toJSON() : <any>undefined;
        data["customerTypeType"] = this.customerTypeType;
        data["currencyCode"] = this.currencyCode;
        return data; 
    }
}

export interface IGetCustomerForEditOutput {
    customer: CreateOrEditCustomerDto | undefined;
    customerTypeType: string | undefined;
    currencyCode: string | undefined;
}

export class CreateOrEditCustomerDto implements ICreateOrEditCustomerDto {
    reference!: string;
    name!: string;
    identifier!: string;
    logoUrl!: string | undefined;
    website!: string | undefined;
    customerLoc8UUID!: string | undefined;
    customerTypeId!: number | undefined;
    currencyId!: number | undefined;
    paymentTermNumber!: string | undefined;
    paymentTermType!: string | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditCustomerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reference = data["reference"];
            this.name = data["name"];
            this.identifier = data["identifier"];
            this.logoUrl = data["logoUrl"];
            this.website = data["website"];
            this.customerLoc8UUID = data["customerLoc8UUID"];
            this.customerTypeId = data["customerTypeId"];
            this.currencyId = data["currencyId"];
            this.paymentTermNumber = data["paymentTermNumber"];
            this.paymentTermType = data["paymentTermType"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditCustomerDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditCustomerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reference"] = this.reference;
        data["name"] = this.name;
        data["identifier"] = this.identifier;
        data["logoUrl"] = this.logoUrl;
        data["website"] = this.website;
        data["customerLoc8UUID"] = this.customerLoc8UUID;
        data["customerTypeId"] = this.customerTypeId;
        data["currencyId"] = this.currencyId;
        data["paymentTermNumber"] = this.paymentTermNumber;
        data["paymentTermType"] = this.paymentTermType;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditCustomerDto {
    reference: string;
    name: string;
    identifier: string;
    logoUrl: string | undefined;
    website: string | undefined;
    customerLoc8UUID: string | undefined;
    customerTypeId: number | undefined;
    currencyId: number | undefined;
    paymentTermNumber: string | undefined;
    paymentTermType: string | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfCustomerCustomerTypeLookupTableDto implements IPagedResultDtoOfCustomerCustomerTypeLookupTableDto {
    totalCount!: number | undefined;
    items!: CustomerCustomerTypeLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfCustomerCustomerTypeLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(CustomerCustomerTypeLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCustomerCustomerTypeLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCustomerCustomerTypeLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfCustomerCustomerTypeLookupTableDto {
    totalCount: number | undefined;
    items: CustomerCustomerTypeLookupTableDto[] | undefined;
}

export class CustomerCustomerTypeLookupTableDto implements ICustomerCustomerTypeLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: ICustomerCustomerTypeLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): CustomerCustomerTypeLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerCustomerTypeLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface ICustomerCustomerTypeLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfCustomerCurrencyLookupTableDto implements IPagedResultDtoOfCustomerCurrencyLookupTableDto {
    totalCount!: number | undefined;
    items!: CustomerCurrencyLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfCustomerCurrencyLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(CustomerCurrencyLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCustomerCurrencyLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCustomerCurrencyLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfCustomerCurrencyLookupTableDto {
    totalCount: number | undefined;
    items: CustomerCurrencyLookupTableDto[] | undefined;
}

export class CustomerCurrencyLookupTableDto implements ICustomerCurrencyLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: ICustomerCurrencyLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): CustomerCurrencyLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerCurrencyLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface ICustomerCurrencyLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfCustomerPaymentTermsTypeLookupTableDto implements IPagedResultDtoOfCustomerPaymentTermsTypeLookupTableDto {
    totalCount!: number | undefined;
    items!: CustomerPaymentTermsTypeLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfCustomerPaymentTermsTypeLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(CustomerPaymentTermsTypeLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfCustomerPaymentTermsTypeLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfCustomerPaymentTermsTypeLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfCustomerPaymentTermsTypeLookupTableDto {
    totalCount: number | undefined;
    items: CustomerPaymentTermsTypeLookupTableDto[] | undefined;
}

export class CustomerPaymentTermsTypeLookupTableDto implements ICustomerPaymentTermsTypeLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: ICustomerPaymentTermsTypeLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): CustomerPaymentTermsTypeLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerPaymentTermsTypeLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface ICustomerPaymentTermsTypeLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class CustomerForCustomerInvoiceEditDto implements ICustomerForCustomerInvoiceEditDto {
    dueDate!: string | undefined;
    currencyId!: number | undefined;
    currencyCode!: string | undefined;

    constructor(data?: ICustomerForCustomerInvoiceEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dueDate = data["dueDate"];
            this.currencyId = data["currencyId"];
            this.currencyCode = data["currencyCode"];
        }
    }

    static fromJS(data: any): CustomerForCustomerInvoiceEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerForCustomerInvoiceEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dueDate"] = this.dueDate;
        data["currencyId"] = this.currencyId;
        data["currencyCode"] = this.currencyCode;
        return data; 
    }
}

export interface ICustomerForCustomerInvoiceEditDto {
    dueDate: string | undefined;
    currencyId: number | undefined;
    currencyCode: string | undefined;
}

export class PagedResultDtoOfGetCustomerTypeForViewDto implements IPagedResultDtoOfGetCustomerTypeForViewDto {
    totalCount!: number | undefined;
    items!: GetCustomerTypeForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetCustomerTypeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetCustomerTypeForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetCustomerTypeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetCustomerTypeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetCustomerTypeForViewDto {
    totalCount: number | undefined;
    items: GetCustomerTypeForViewDto[] | undefined;
}

export class GetCustomerTypeForViewDto implements IGetCustomerTypeForViewDto {
    customerType!: CustomerTypeDto | undefined;

    constructor(data?: IGetCustomerTypeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.customerType = data["customerType"] ? CustomerTypeDto.fromJS(data["customerType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCustomerTypeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetCustomerTypeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerType"] = this.customerType ? this.customerType.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetCustomerTypeForViewDto {
    customerType: CustomerTypeDto | undefined;
}

export class CustomerTypeDto implements ICustomerTypeDto {
    type!: string | undefined;
    description!: string | undefined;
    id!: number | undefined;

    constructor(data?: ICustomerTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.type = data["type"];
            this.description = data["description"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CustomerTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CustomerTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICustomerTypeDto {
    type: string | undefined;
    description: string | undefined;
    id: number | undefined;
}

export class GetCustomerTypeForEditOutput implements IGetCustomerTypeForEditOutput {
    customerType!: CreateOrEditCustomerTypeDto | undefined;

    constructor(data?: IGetCustomerTypeForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.customerType = data["customerType"] ? CreateOrEditCustomerTypeDto.fromJS(data["customerType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCustomerTypeForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCustomerTypeForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerType"] = this.customerType ? this.customerType.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetCustomerTypeForEditOutput {
    customerType: CreateOrEditCustomerTypeDto | undefined;
}

export class CreateOrEditCustomerTypeDto implements ICreateOrEditCustomerTypeDto {
    type!: string;
    description!: string;
    id!: number | undefined;

    constructor(data?: ICreateOrEditCustomerTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.type = data["type"];
            this.description = data["description"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditCustomerTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditCustomerTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditCustomerTypeDto {
    type: string;
    description: string;
    id: number | undefined;
}

export class DateToStringOutput implements IDateToStringOutput {
    dateString!: string | undefined;

    constructor(data?: IDateToStringOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dateString = data["dateString"];
        }
    }

    static fromJS(data: any): DateToStringOutput {
        data = typeof data === 'object' ? data : {};
        let result = new DateToStringOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dateString"] = this.dateString;
        return data; 
    }
}

export interface IDateToStringOutput {
    dateString: string | undefined;
}

export class NameValueOfString implements INameValueOfString {
    name!: string | undefined;
    value!: string | undefined;

    constructor(data?: INameValueOfString) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): NameValueOfString {
        data = typeof data === 'object' ? data : {};
        let result = new NameValueOfString();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }
}

export interface INameValueOfString {
    name: string | undefined;
    value: string | undefined;
}

export class StringOutput implements IStringOutput {
    output!: string | undefined;

    constructor(data?: IStringOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.output = data["output"];
        }
    }

    static fromJS(data: any): StringOutput {
        data = typeof data === 'object' ? data : {};
        let result = new StringOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["output"] = this.output;
        return data; 
    }
}

export interface IStringOutput {
    output: string | undefined;
}

export class ListResultDtoOfEditionListDto implements IListResultDtoOfEditionListDto {
    items!: EditionListDto[] | undefined;

    constructor(data?: IListResultDtoOfEditionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(EditionListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfEditionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfEditionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfEditionListDto {
    items: EditionListDto[] | undefined;
}

export class EditionListDto implements IEditionListDto {
    name!: string | undefined;
    displayName!: string | undefined;
    dailyPrice!: number | undefined;
    weeklyPrice!: number | undefined;
    monthlyPrice!: number | undefined;
    annualPrice!: number | undefined;
    waitingDayAfterExpire!: number | undefined;
    trialDayCount!: number | undefined;
    expiringEditionDisplayName!: string | undefined;
    id!: number | undefined;

    constructor(data?: IEditionListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.dailyPrice = data["dailyPrice"];
            this.weeklyPrice = data["weeklyPrice"];
            this.monthlyPrice = data["monthlyPrice"];
            this.annualPrice = data["annualPrice"];
            this.waitingDayAfterExpire = data["waitingDayAfterExpire"];
            this.trialDayCount = data["trialDayCount"];
            this.expiringEditionDisplayName = data["expiringEditionDisplayName"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EditionListDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["dailyPrice"] = this.dailyPrice;
        data["weeklyPrice"] = this.weeklyPrice;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["waitingDayAfterExpire"] = this.waitingDayAfterExpire;
        data["trialDayCount"] = this.trialDayCount;
        data["expiringEditionDisplayName"] = this.expiringEditionDisplayName;
        data["id"] = this.id;
        return data; 
    }
}

export interface IEditionListDto {
    name: string | undefined;
    displayName: string | undefined;
    dailyPrice: number | undefined;
    weeklyPrice: number | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    waitingDayAfterExpire: number | undefined;
    trialDayCount: number | undefined;
    expiringEditionDisplayName: string | undefined;
    id: number | undefined;
}

export class GetEditionEditOutput implements IGetEditionEditOutput {
    edition!: EditionEditDto | undefined;
    featureValues!: NameValueDto[] | undefined;
    features!: FlatFeatureDto[] | undefined;

    constructor(data?: IGetEditionEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.edition = data["edition"] ? EditionEditDto.fromJS(data["edition"]) : <any>undefined;
            if (Array.isArray(data["featureValues"])) {
                this.featureValues = [] as any;
                for (let item of data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
            if (Array.isArray(data["features"])) {
                this.features = [] as any;
                for (let item of data["features"])
                    this.features!.push(FlatFeatureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetEditionEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetEditionEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (Array.isArray(this.featureValues)) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        if (Array.isArray(this.features)) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetEditionEditOutput {
    edition: EditionEditDto | undefined;
    featureValues: NameValueDto[] | undefined;
    features: FlatFeatureDto[] | undefined;
}

export class EditionEditDto implements IEditionEditDto {
    id!: number | undefined;
    displayName!: string;
    expiringEditionId!: number | undefined;

    constructor(data?: IEditionEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
            this.expiringEditionId = data["expiringEditionId"];
        }
    }

    static fromJS(data: any): EditionEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["expiringEditionId"] = this.expiringEditionId;
        return data; 
    }
}

export interface IEditionEditDto {
    id: number | undefined;
    displayName: string;
    expiringEditionId: number | undefined;
}

export class FlatFeatureDto implements IFlatFeatureDto {
    parentName!: string | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;
    defaultValue!: string | undefined;
    inputType!: FeatureInputTypeDto | undefined;

    constructor(data?: IFlatFeatureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentName = data["parentName"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.defaultValue = data["defaultValue"];
            this.inputType = data["inputType"] ? FeatureInputTypeDto.fromJS(data["inputType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FlatFeatureDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatFeatureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["defaultValue"] = this.defaultValue;
        data["inputType"] = this.inputType ? this.inputType.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IFlatFeatureDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    defaultValue: string | undefined;
    inputType: FeatureInputTypeDto | undefined;
}

export class FeatureInputTypeDto implements IFeatureInputTypeDto {
    name!: string | undefined;
    attributes!: { [key: string]: any; } | undefined;
    validator!: IValueValidator | undefined;
    itemSource!: LocalizableComboboxItemSourceDto | undefined;

    constructor(data?: IFeatureInputTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            if (data["attributes"]) {
                this.attributes = {} as any;
                for (let key in data["attributes"]) {
                    if (data["attributes"].hasOwnProperty(key))
                        this.attributes![key] = data["attributes"][key];
                }
            }
            this.validator = data["validator"] ? IValueValidator.fromJS(data["validator"]) : <any>undefined;
            this.itemSource = data["itemSource"] ? LocalizableComboboxItemSourceDto.fromJS(data["itemSource"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FeatureInputTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new FeatureInputTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    data["attributes"][key] = this.attributes[key];
            }
        }
        data["validator"] = this.validator ? this.validator.toJSON() : <any>undefined;
        data["itemSource"] = this.itemSource ? this.itemSource.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IFeatureInputTypeDto {
    name: string | undefined;
    attributes: { [key: string]: any; } | undefined;
    validator: IValueValidator | undefined;
    itemSource: LocalizableComboboxItemSourceDto | undefined;
}

export class IValueValidator implements IIValueValidator {
    readonly name!: string | undefined;
    readonly attributes!: { [key: string]: any; } | undefined;

    constructor(data?: IIValueValidator) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            (<any>this).name = data["name"];
            if (data["attributes"]) {
                (<any>this).attributes = {} as any;
                for (let key in data["attributes"]) {
                    if (data["attributes"].hasOwnProperty(key))
                        (<any>this).attributes![key] = data["attributes"][key];
                }
            }
        }
    }

    static fromJS(data: any): IValueValidator {
        data = typeof data === 'object' ? data : {};
        let result = new IValueValidator();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    data["attributes"][key] = this.attributes[key];
            }
        }
        return data; 
    }
}

export interface IIValueValidator {
    name: string | undefined;
    attributes: { [key: string]: any; } | undefined;
}

export class LocalizableComboboxItemSourceDto implements ILocalizableComboboxItemSourceDto {
    items!: LocalizableComboboxItemDto[] | undefined;

    constructor(data?: ILocalizableComboboxItemSourceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(LocalizableComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LocalizableComboboxItemSourceDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizableComboboxItemSourceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ILocalizableComboboxItemSourceDto {
    items: LocalizableComboboxItemDto[] | undefined;
}

export class LocalizableComboboxItemDto implements ILocalizableComboboxItemDto {
    value!: string | undefined;
    displayText!: string | undefined;

    constructor(data?: ILocalizableComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.value = data["value"];
            this.displayText = data["displayText"];
        }
    }

    static fromJS(data: any): LocalizableComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocalizableComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        return data; 
    }
}

export interface ILocalizableComboboxItemDto {
    value: string | undefined;
    displayText: string | undefined;
}

export class CreateEditionDto implements ICreateEditionDto {
    edition!: EditionCreateDto;
    featureValues!: NameValueDto[];

    constructor(data?: ICreateEditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.edition = new EditionCreateDto();
            this.featureValues = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.edition = data["edition"] ? EditionCreateDto.fromJS(data["edition"]) : new EditionCreateDto();
            if (Array.isArray(data["featureValues"])) {
                this.featureValues = [] as any;
                for (let item of data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateEditionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateEditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (Array.isArray(this.featureValues)) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICreateEditionDto {
    edition: EditionCreateDto;
    featureValues: NameValueDto[];
}

export class EditionCreateDto implements IEditionCreateDto {
    id!: number | undefined;
    displayName!: string;
    dailyPrice!: number | undefined;
    weeklyPrice!: number | undefined;
    monthlyPrice!: number | undefined;
    annualPrice!: number | undefined;
    trialDayCount!: number | undefined;
    waitingDayAfterExpire!: number | undefined;
    expiringEditionId!: number | undefined;

    constructor(data?: IEditionCreateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
            this.dailyPrice = data["dailyPrice"];
            this.weeklyPrice = data["weeklyPrice"];
            this.monthlyPrice = data["monthlyPrice"];
            this.annualPrice = data["annualPrice"];
            this.trialDayCount = data["trialDayCount"];
            this.waitingDayAfterExpire = data["waitingDayAfterExpire"];
            this.expiringEditionId = data["expiringEditionId"];
        }
    }

    static fromJS(data: any): EditionCreateDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionCreateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["dailyPrice"] = this.dailyPrice;
        data["weeklyPrice"] = this.weeklyPrice;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["trialDayCount"] = this.trialDayCount;
        data["waitingDayAfterExpire"] = this.waitingDayAfterExpire;
        data["expiringEditionId"] = this.expiringEditionId;
        return data; 
    }
}

export interface IEditionCreateDto {
    id: number | undefined;
    displayName: string;
    dailyPrice: number | undefined;
    weeklyPrice: number | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    trialDayCount: number | undefined;
    waitingDayAfterExpire: number | undefined;
    expiringEditionId: number | undefined;
}

export class UpdateEditionDto implements IUpdateEditionDto {
    edition!: EditionEditDto;
    featureValues!: NameValueDto[];

    constructor(data?: IUpdateEditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.edition = new EditionEditDto();
            this.featureValues = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.edition = data["edition"] ? EditionEditDto.fromJS(data["edition"]) : new EditionEditDto();
            if (Array.isArray(data["featureValues"])) {
                this.featureValues = [] as any;
                for (let item of data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateEditionDto {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateEditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (Array.isArray(this.featureValues)) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUpdateEditionDto {
    edition: EditionEditDto;
    featureValues: NameValueDto[];
}

export class MoveTenantsToAnotherEditionDto implements IMoveTenantsToAnotherEditionDto {
    sourceEditionId!: number | undefined;
    targetEditionId!: number | undefined;

    constructor(data?: IMoveTenantsToAnotherEditionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.sourceEditionId = data["sourceEditionId"];
            this.targetEditionId = data["targetEditionId"];
        }
    }

    static fromJS(data: any): MoveTenantsToAnotherEditionDto {
        data = typeof data === 'object' ? data : {};
        let result = new MoveTenantsToAnotherEditionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sourceEditionId"] = this.sourceEditionId;
        data["targetEditionId"] = this.targetEditionId;
        return data; 
    }
}

export interface IMoveTenantsToAnotherEditionDto {
    sourceEditionId: number | undefined;
    targetEditionId: number | undefined;
}

export class GetEstimateDetailForEditOutput implements IGetEstimateDetailForEditOutput {
    estimateDetail!: CreateOrEditEstimateDetailDto | undefined;
    itemTypeType!: string | undefined;
    estimateTitle!: string | undefined;
    uomUnitOfMeasurement!: string | undefined;
    actionWorkOrderAction!: string | undefined;

    constructor(data?: IGetEstimateDetailForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.estimateDetail = data["estimateDetail"] ? CreateOrEditEstimateDetailDto.fromJS(data["estimateDetail"]) : <any>undefined;
            this.itemTypeType = data["itemTypeType"];
            this.estimateTitle = data["estimateTitle"];
            this.uomUnitOfMeasurement = data["uomUnitOfMeasurement"];
            this.actionWorkOrderAction = data["actionWorkOrderAction"];
        }
    }

    static fromJS(data: any): GetEstimateDetailForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetEstimateDetailForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["estimateDetail"] = this.estimateDetail ? this.estimateDetail.toJSON() : <any>undefined;
        data["itemTypeType"] = this.itemTypeType;
        data["estimateTitle"] = this.estimateTitle;
        data["uomUnitOfMeasurement"] = this.uomUnitOfMeasurement;
        data["actionWorkOrderAction"] = this.actionWorkOrderAction;
        return data; 
    }
}

export interface IGetEstimateDetailForEditOutput {
    estimateDetail: CreateOrEditEstimateDetailDto | undefined;
    itemTypeType: string | undefined;
    estimateTitle: string | undefined;
    uomUnitOfMeasurement: string | undefined;
    actionWorkOrderAction: string | undefined;
}

export class CreateOrEditEstimateDetailDto implements ICreateOrEditEstimateDetailDto {
    description!: string | undefined;
    quantity!: number | undefined;
    unitPrice!: number | undefined;
    cost!: number | undefined;
    tax!: number | undefined;
    charge!: number | undefined;
    discount!: number | undefined;
    markUp!: number | undefined;
    isTaxable!: boolean | undefined;
    isChargeable!: boolean | undefined;
    isAdHoc!: boolean | undefined;
    isStandbyReplacementUnit!: boolean | undefined;
    isOptionalItem!: boolean | undefined;
    remark!: string | undefined;
    loc8GUID!: string | undefined;
    itemTypeId!: number | undefined;
    uomId!: number | undefined;
    workOrderActionId!: number | undefined;
    estimateId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditEstimateDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.description = data["description"];
            this.quantity = data["quantity"];
            this.unitPrice = data["unitPrice"];
            this.cost = data["cost"];
            this.tax = data["tax"];
            this.charge = data["charge"];
            this.discount = data["discount"];
            this.markUp = data["markUp"];
            this.isTaxable = data["isTaxable"];
            this.isChargeable = data["isChargeable"];
            this.isAdHoc = data["isAdHoc"];
            this.isStandbyReplacementUnit = data["isStandbyReplacementUnit"];
            this.isOptionalItem = data["isOptionalItem"];
            this.remark = data["remark"];
            this.loc8GUID = data["loc8GUID"];
            this.itemTypeId = data["itemTypeId"];
            this.uomId = data["uomId"];
            this.workOrderActionId = data["workOrderActionId"];
            this.estimateId = data["estimateId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditEstimateDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditEstimateDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["quantity"] = this.quantity;
        data["unitPrice"] = this.unitPrice;
        data["cost"] = this.cost;
        data["tax"] = this.tax;
        data["charge"] = this.charge;
        data["discount"] = this.discount;
        data["markUp"] = this.markUp;
        data["isTaxable"] = this.isTaxable;
        data["isChargeable"] = this.isChargeable;
        data["isAdHoc"] = this.isAdHoc;
        data["isStandbyReplacementUnit"] = this.isStandbyReplacementUnit;
        data["isOptionalItem"] = this.isOptionalItem;
        data["remark"] = this.remark;
        data["loc8GUID"] = this.loc8GUID;
        data["itemTypeId"] = this.itemTypeId;
        data["uomId"] = this.uomId;
        data["workOrderActionId"] = this.workOrderActionId;
        data["estimateId"] = this.estimateId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditEstimateDetailDto {
    description: string | undefined;
    quantity: number | undefined;
    unitPrice: number | undefined;
    cost: number | undefined;
    tax: number | undefined;
    charge: number | undefined;
    discount: number | undefined;
    markUp: number | undefined;
    isTaxable: boolean | undefined;
    isChargeable: boolean | undefined;
    isAdHoc: boolean | undefined;
    isStandbyReplacementUnit: boolean | undefined;
    isOptionalItem: boolean | undefined;
    remark: string | undefined;
    loc8GUID: string | undefined;
    itemTypeId: number | undefined;
    uomId: number | undefined;
    workOrderActionId: number | undefined;
    estimateId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfGetEstimateForViewDto implements IPagedResultDtoOfGetEstimateForViewDto {
    totalCount!: number | undefined;
    items!: GetEstimateForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetEstimateForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetEstimateForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetEstimateForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetEstimateForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetEstimateForViewDto {
    totalCount: number | undefined;
    items: GetEstimateForViewDto[] | undefined;
}

export class GetEstimateForEditOutput implements IGetEstimateForEditOutput {
    estimate!: CreateOrEditEstimateDto | undefined;
    workOrderSubject!: string | undefined;
    quotationTitle!: string | undefined;
    estimateStatusStatus!: string | undefined;
    customerName!: string | undefined;

    constructor(data?: IGetEstimateForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.estimate = data["estimate"] ? CreateOrEditEstimateDto.fromJS(data["estimate"]) : <any>undefined;
            this.workOrderSubject = data["workOrderSubject"];
            this.quotationTitle = data["quotationTitle"];
            this.estimateStatusStatus = data["estimateStatusStatus"];
            this.customerName = data["customerName"];
        }
    }

    static fromJS(data: any): GetEstimateForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetEstimateForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["estimate"] = this.estimate ? this.estimate.toJSON() : <any>undefined;
        data["workOrderSubject"] = this.workOrderSubject;
        data["quotationTitle"] = this.quotationTitle;
        data["estimateStatusStatus"] = this.estimateStatusStatus;
        data["customerName"] = this.customerName;
        return data; 
    }
}

export interface IGetEstimateForEditOutput {
    estimate: CreateOrEditEstimateDto | undefined;
    workOrderSubject: string | undefined;
    quotationTitle: string | undefined;
    estimateStatusStatus: string | undefined;
    customerName: string | undefined;
}

export class CreateOrEditEstimateDto implements ICreateOrEditEstimateDto {
    reference!: string;
    title!: string;
    description!: string | undefined;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    totalTax!: number | undefined;
    totalPrice!: number | undefined;
    totalDiscount!: number | undefined;
    totalCharge!: number | undefined;
    version!: number | undefined;
    remark!: string | undefined;
    requoteRefId!: number | undefined;
    quotationLoc8GUID!: string | undefined;
    acknowledgedBy!: number | undefined;
    acknowledgedAt!: moment.Moment | undefined;
    quotationId!: number | undefined;
    workOrderId!: number | undefined;
    estimateStatusId!: number | undefined;
    customerId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditEstimateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reference = data["reference"];
            this.title = data["title"];
            this.description = data["description"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.totalTax = data["totalTax"];
            this.totalPrice = data["totalPrice"];
            this.totalDiscount = data["totalDiscount"];
            this.totalCharge = data["totalCharge"];
            this.version = data["version"];
            this.remark = data["remark"];
            this.requoteRefId = data["requoteRefId"];
            this.quotationLoc8GUID = data["quotationLoc8GUID"];
            this.acknowledgedBy = data["acknowledgedBy"];
            this.acknowledgedAt = data["acknowledgedAt"] ? moment(data["acknowledgedAt"].toString()) : <any>undefined;
            this.quotationId = data["quotationId"];
            this.workOrderId = data["workOrderId"];
            this.estimateStatusId = data["estimateStatusId"];
            this.customerId = data["customerId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditEstimateDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditEstimateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reference"] = this.reference;
        data["title"] = this.title;
        data["description"] = this.description;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["totalTax"] = this.totalTax;
        data["totalPrice"] = this.totalPrice;
        data["totalDiscount"] = this.totalDiscount;
        data["totalCharge"] = this.totalCharge;
        data["version"] = this.version;
        data["remark"] = this.remark;
        data["requoteRefId"] = this.requoteRefId;
        data["quotationLoc8GUID"] = this.quotationLoc8GUID;
        data["acknowledgedBy"] = this.acknowledgedBy;
        data["acknowledgedAt"] = this.acknowledgedAt ? this.acknowledgedAt.toISOString() : <any>undefined;
        data["quotationId"] = this.quotationId;
        data["workOrderId"] = this.workOrderId;
        data["estimateStatusId"] = this.estimateStatusId;
        data["customerId"] = this.customerId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditEstimateDto {
    reference: string;
    title: string;
    description: string | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    totalTax: number | undefined;
    totalPrice: number | undefined;
    totalDiscount: number | undefined;
    totalCharge: number | undefined;
    version: number | undefined;
    remark: string | undefined;
    requoteRefId: number | undefined;
    quotationLoc8GUID: string | undefined;
    acknowledgedBy: number | undefined;
    acknowledgedAt: moment.Moment | undefined;
    quotationId: number | undefined;
    workOrderId: number | undefined;
    estimateStatusId: number | undefined;
    customerId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfEstimateWorkOrderLookupTableDto implements IPagedResultDtoOfEstimateWorkOrderLookupTableDto {
    totalCount!: number | undefined;
    items!: EstimateWorkOrderLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfEstimateWorkOrderLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(EstimateWorkOrderLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfEstimateWorkOrderLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfEstimateWorkOrderLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfEstimateWorkOrderLookupTableDto {
    totalCount: number | undefined;
    items: EstimateWorkOrderLookupTableDto[] | undefined;
}

export class EstimateWorkOrderLookupTableDto implements IEstimateWorkOrderLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IEstimateWorkOrderLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): EstimateWorkOrderLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new EstimateWorkOrderLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IEstimateWorkOrderLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfEstimateQuotationLookupTableDto implements IPagedResultDtoOfEstimateQuotationLookupTableDto {
    totalCount!: number | undefined;
    items!: EstimateQuotationLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfEstimateQuotationLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(EstimateQuotationLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfEstimateQuotationLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfEstimateQuotationLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfEstimateQuotationLookupTableDto {
    totalCount: number | undefined;
    items: EstimateQuotationLookupTableDto[] | undefined;
}

export class EstimateQuotationLookupTableDto implements IEstimateQuotationLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IEstimateQuotationLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): EstimateQuotationLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new EstimateQuotationLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IEstimateQuotationLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfEstimateEstimateStatusLookupTableDto implements IPagedResultDtoOfEstimateEstimateStatusLookupTableDto {
    totalCount!: number | undefined;
    items!: EstimateEstimateStatusLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfEstimateEstimateStatusLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(EstimateEstimateStatusLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfEstimateEstimateStatusLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfEstimateEstimateStatusLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfEstimateEstimateStatusLookupTableDto {
    totalCount: number | undefined;
    items: EstimateEstimateStatusLookupTableDto[] | undefined;
}

export class EstimateEstimateStatusLookupTableDto implements IEstimateEstimateStatusLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IEstimateEstimateStatusLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): EstimateEstimateStatusLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new EstimateEstimateStatusLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IEstimateEstimateStatusLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfEstimateCustomerLookupTableDto implements IPagedResultDtoOfEstimateCustomerLookupTableDto {
    totalCount!: number | undefined;
    items!: EstimateCustomerLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfEstimateCustomerLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(EstimateCustomerLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfEstimateCustomerLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfEstimateCustomerLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfEstimateCustomerLookupTableDto {
    totalCount: number | undefined;
    items: EstimateCustomerLookupTableDto[] | undefined;
}

export class EstimateCustomerLookupTableDto implements IEstimateCustomerLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IEstimateCustomerLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): EstimateCustomerLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new EstimateCustomerLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IEstimateCustomerLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class EstimateWorkOrderFkListDto implements IEstimateWorkOrderFkListDto {
    customerList!: EstimateCustomerLookupTableDto[] | undefined;
    quotationList!: EstimateQuotationLookupTableDto[] | undefined;

    constructor(data?: IEstimateWorkOrderFkListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["customerList"])) {
                this.customerList = [] as any;
                for (let item of data["customerList"])
                    this.customerList!.push(EstimateCustomerLookupTableDto.fromJS(item));
            }
            if (Array.isArray(data["quotationList"])) {
                this.quotationList = [] as any;
                for (let item of data["quotationList"])
                    this.quotationList!.push(EstimateQuotationLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EstimateWorkOrderFkListDto {
        data = typeof data === 'object' ? data : {};
        let result = new EstimateWorkOrderFkListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.customerList)) {
            data["customerList"] = [];
            for (let item of this.customerList)
                data["customerList"].push(item.toJSON());
        }
        if (Array.isArray(this.quotationList)) {
            data["quotationList"] = [];
            for (let item of this.quotationList)
                data["quotationList"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IEstimateWorkOrderFkListDto {
    customerList: EstimateCustomerLookupTableDto[] | undefined;
    quotationList: EstimateQuotationLookupTableDto[] | undefined;
}

export class EstimateQuotationFkListDto implements IEstimateQuotationFkListDto {
    customerList!: EstimateCustomerLookupTableDto[] | undefined;

    constructor(data?: IEstimateQuotationFkListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["customerList"])) {
                this.customerList = [] as any;
                for (let item of data["customerList"])
                    this.customerList!.push(EstimateCustomerLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EstimateQuotationFkListDto {
        data = typeof data === 'object' ? data : {};
        let result = new EstimateQuotationFkListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.customerList)) {
            data["customerList"] = [];
            for (let item of this.customerList)
                data["customerList"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IEstimateQuotationFkListDto {
    customerList: EstimateCustomerLookupTableDto[] | undefined;
}

export class GetEstimateQuotationForViewDto implements IGetEstimateQuotationForViewDto {
    quotation!: GetQuotationForViewDto | undefined;
    quotationDetails!: PagedResultDtoOfGetQuotationDetailForViewDto | undefined;

    constructor(data?: IGetEstimateQuotationForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.quotation = data["quotation"] ? GetQuotationForViewDto.fromJS(data["quotation"]) : <any>undefined;
            this.quotationDetails = data["quotationDetails"] ? PagedResultDtoOfGetQuotationDetailForViewDto.fromJS(data["quotationDetails"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetEstimateQuotationForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetEstimateQuotationForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["quotation"] = this.quotation ? this.quotation.toJSON() : <any>undefined;
        data["quotationDetails"] = this.quotationDetails ? this.quotationDetails.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetEstimateQuotationForViewDto {
    quotation: GetQuotationForViewDto | undefined;
    quotationDetails: PagedResultDtoOfGetQuotationDetailForViewDto | undefined;
}

export class GetQuotationForViewDto implements IGetQuotationForViewDto {
    quotation!: QuotationDto | undefined;
    supportContractTitle!: string | undefined;
    quotationStatusStatus!: string | undefined;
    workOrderSubject!: string | undefined;
    assetReference!: string | undefined;
    assetClassClass!: string | undefined;
    supportTypeType!: string | undefined;
    supportItemDescription!: string | undefined;

    constructor(data?: IGetQuotationForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.quotation = data["quotation"] ? QuotationDto.fromJS(data["quotation"]) : <any>undefined;
            this.supportContractTitle = data["supportContractTitle"];
            this.quotationStatusStatus = data["quotationStatusStatus"];
            this.workOrderSubject = data["workOrderSubject"];
            this.assetReference = data["assetReference"];
            this.assetClassClass = data["assetClassClass"];
            this.supportTypeType = data["supportTypeType"];
            this.supportItemDescription = data["supportItemDescription"];
        }
    }

    static fromJS(data: any): GetQuotationForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetQuotationForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["quotation"] = this.quotation ? this.quotation.toJSON() : <any>undefined;
        data["supportContractTitle"] = this.supportContractTitle;
        data["quotationStatusStatus"] = this.quotationStatusStatus;
        data["workOrderSubject"] = this.workOrderSubject;
        data["assetReference"] = this.assetReference;
        data["assetClassClass"] = this.assetClassClass;
        data["supportTypeType"] = this.supportTypeType;
        data["supportItemDescription"] = this.supportItemDescription;
        return data; 
    }
}

export interface IGetQuotationForViewDto {
    quotation: QuotationDto | undefined;
    supportContractTitle: string | undefined;
    quotationStatusStatus: string | undefined;
    workOrderSubject: string | undefined;
    assetReference: string | undefined;
    assetClassClass: string | undefined;
    supportTypeType: string | undefined;
    supportItemDescription: string | undefined;
}

export class PagedResultDtoOfGetQuotationDetailForViewDto implements IPagedResultDtoOfGetQuotationDetailForViewDto {
    totalCount!: number | undefined;
    items!: GetQuotationDetailForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetQuotationDetailForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetQuotationDetailForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetQuotationDetailForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetQuotationDetailForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetQuotationDetailForViewDto {
    totalCount: number | undefined;
    items: GetQuotationDetailForViewDto[] | undefined;
}

export class QuotationDto implements IQuotationDto {
    reference!: string | undefined;
    title!: string | undefined;
    description!: string | undefined;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    totalTax!: number | undefined;
    totalPrice!: number | undefined;
    totalDiscount!: number | undefined;
    totalCharge!: number | undefined;
    version!: number | undefined;
    isFinal!: boolean | undefined;
    remark!: string | undefined;
    requoteRefId!: number | undefined;
    quotationLoc8GUID!: string | undefined;
    acknowledgedBy!: string | undefined;
    acknowledgedAt!: moment.Moment | undefined;
    supportContractId!: number | undefined;
    quotationStatusId!: number | undefined;
    workOrderId!: number | undefined;
    assetId!: number | undefined;
    assetClassId!: number | undefined;
    supportTypeId!: number | undefined;
    supportItemId!: number | undefined;
    tenantId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IQuotationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reference = data["reference"];
            this.title = data["title"];
            this.description = data["description"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.totalTax = data["totalTax"];
            this.totalPrice = data["totalPrice"];
            this.totalDiscount = data["totalDiscount"];
            this.totalCharge = data["totalCharge"];
            this.version = data["version"];
            this.isFinal = data["isFinal"];
            this.remark = data["remark"];
            this.requoteRefId = data["requoteRefId"];
            this.quotationLoc8GUID = data["quotationLoc8GUID"];
            this.acknowledgedBy = data["acknowledgedBy"];
            this.acknowledgedAt = data["acknowledgedAt"] ? moment(data["acknowledgedAt"].toString()) : <any>undefined;
            this.supportContractId = data["supportContractId"];
            this.quotationStatusId = data["quotationStatusId"];
            this.workOrderId = data["workOrderId"];
            this.assetId = data["assetId"];
            this.assetClassId = data["assetClassId"];
            this.supportTypeId = data["supportTypeId"];
            this.supportItemId = data["supportItemId"];
            this.tenantId = data["tenantId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): QuotationDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuotationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reference"] = this.reference;
        data["title"] = this.title;
        data["description"] = this.description;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["totalTax"] = this.totalTax;
        data["totalPrice"] = this.totalPrice;
        data["totalDiscount"] = this.totalDiscount;
        data["totalCharge"] = this.totalCharge;
        data["version"] = this.version;
        data["isFinal"] = this.isFinal;
        data["remark"] = this.remark;
        data["requoteRefId"] = this.requoteRefId;
        data["quotationLoc8GUID"] = this.quotationLoc8GUID;
        data["acknowledgedBy"] = this.acknowledgedBy;
        data["acknowledgedAt"] = this.acknowledgedAt ? this.acknowledgedAt.toISOString() : <any>undefined;
        data["supportContractId"] = this.supportContractId;
        data["quotationStatusId"] = this.quotationStatusId;
        data["workOrderId"] = this.workOrderId;
        data["assetId"] = this.assetId;
        data["assetClassId"] = this.assetClassId;
        data["supportTypeId"] = this.supportTypeId;
        data["supportItemId"] = this.supportItemId;
        data["tenantId"] = this.tenantId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IQuotationDto {
    reference: string | undefined;
    title: string | undefined;
    description: string | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    totalTax: number | undefined;
    totalPrice: number | undefined;
    totalDiscount: number | undefined;
    totalCharge: number | undefined;
    version: number | undefined;
    isFinal: boolean | undefined;
    remark: string | undefined;
    requoteRefId: number | undefined;
    quotationLoc8GUID: string | undefined;
    acknowledgedBy: string | undefined;
    acknowledgedAt: moment.Moment | undefined;
    supportContractId: number | undefined;
    quotationStatusId: number | undefined;
    workOrderId: number | undefined;
    assetId: number | undefined;
    assetClassId: number | undefined;
    supportTypeId: number | undefined;
    supportItemId: number | undefined;
    tenantId: number | undefined;
    id: number | undefined;
}

export class GetQuotationDetailForViewDto implements IGetQuotationDetailForViewDto {
    quotationDetail!: QuotationDetailDto | undefined;
    itemTypeType!: string | undefined;
    quotationTitle!: string | undefined;
    uomUnitOfMeasurement!: string | undefined;

    constructor(data?: IGetQuotationDetailForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.quotationDetail = data["quotationDetail"] ? QuotationDetailDto.fromJS(data["quotationDetail"]) : <any>undefined;
            this.itemTypeType = data["itemTypeType"];
            this.quotationTitle = data["quotationTitle"];
            this.uomUnitOfMeasurement = data["uomUnitOfMeasurement"];
        }
    }

    static fromJS(data: any): GetQuotationDetailForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetQuotationDetailForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["quotationDetail"] = this.quotationDetail ? this.quotationDetail.toJSON() : <any>undefined;
        data["itemTypeType"] = this.itemTypeType;
        data["quotationTitle"] = this.quotationTitle;
        data["uomUnitOfMeasurement"] = this.uomUnitOfMeasurement;
        return data; 
    }
}

export interface IGetQuotationDetailForViewDto {
    quotationDetail: QuotationDetailDto | undefined;
    itemTypeType: string | undefined;
    quotationTitle: string | undefined;
    uomUnitOfMeasurement: string | undefined;
}

export class QuotationDetailDto implements IQuotationDetailDto {
    description!: string | undefined;
    quantity!: number | undefined;
    unitPrice!: number | undefined;
    cost!: number | undefined;
    tax!: number | undefined;
    charge!: number | undefined;
    discount!: number | undefined;
    markUp!: number | undefined;
    isChargeable!: boolean | undefined;
    isAdHoc!: boolean | undefined;
    isStandbyReplacementUnit!: boolean | undefined;
    isOptionalItem!: boolean | undefined;
    remark!: string | undefined;
    loc8GUID!: string | undefined;
    itemTypeId!: number | undefined;
    quotationId!: number | undefined;
    uomId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IQuotationDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.description = data["description"];
            this.quantity = data["quantity"];
            this.unitPrice = data["unitPrice"];
            this.cost = data["cost"];
            this.tax = data["tax"];
            this.charge = data["charge"];
            this.discount = data["discount"];
            this.markUp = data["markUp"];
            this.isChargeable = data["isChargeable"];
            this.isAdHoc = data["isAdHoc"];
            this.isStandbyReplacementUnit = data["isStandbyReplacementUnit"];
            this.isOptionalItem = data["isOptionalItem"];
            this.remark = data["remark"];
            this.loc8GUID = data["loc8GUID"];
            this.itemTypeId = data["itemTypeId"];
            this.quotationId = data["quotationId"];
            this.uomId = data["uomId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): QuotationDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuotationDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["quantity"] = this.quantity;
        data["unitPrice"] = this.unitPrice;
        data["cost"] = this.cost;
        data["tax"] = this.tax;
        data["charge"] = this.charge;
        data["discount"] = this.discount;
        data["markUp"] = this.markUp;
        data["isChargeable"] = this.isChargeable;
        data["isAdHoc"] = this.isAdHoc;
        data["isStandbyReplacementUnit"] = this.isStandbyReplacementUnit;
        data["isOptionalItem"] = this.isOptionalItem;
        data["remark"] = this.remark;
        data["loc8GUID"] = this.loc8GUID;
        data["itemTypeId"] = this.itemTypeId;
        data["quotationId"] = this.quotationId;
        data["uomId"] = this.uomId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IQuotationDetailDto {
    description: string | undefined;
    quantity: number | undefined;
    unitPrice: number | undefined;
    cost: number | undefined;
    tax: number | undefined;
    charge: number | undefined;
    discount: number | undefined;
    markUp: number | undefined;
    isChargeable: boolean | undefined;
    isAdHoc: boolean | undefined;
    isStandbyReplacementUnit: boolean | undefined;
    isOptionalItem: boolean | undefined;
    remark: string | undefined;
    loc8GUID: string | undefined;
    itemTypeId: number | undefined;
    quotationId: number | undefined;
    uomId: number | undefined;
    id: number | undefined;
}

export class GetEstimateWorkOrderForViewDto implements IGetEstimateWorkOrderForViewDto {
    workOrder!: GetWorkOrderForViewDto | undefined;
    workOrderUpdates!: PagedResultDtoOfGetWorkOrderUpdateForViewDto | undefined;

    constructor(data?: IGetEstimateWorkOrderForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.workOrder = data["workOrder"] ? GetWorkOrderForViewDto.fromJS(data["workOrder"]) : <any>undefined;
            this.workOrderUpdates = data["workOrderUpdates"] ? PagedResultDtoOfGetWorkOrderUpdateForViewDto.fromJS(data["workOrderUpdates"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetEstimateWorkOrderForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetEstimateWorkOrderForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workOrder"] = this.workOrder ? this.workOrder.toJSON() : <any>undefined;
        data["workOrderUpdates"] = this.workOrderUpdates ? this.workOrderUpdates.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetEstimateWorkOrderForViewDto {
    workOrder: GetWorkOrderForViewDto | undefined;
    workOrderUpdates: PagedResultDtoOfGetWorkOrderUpdateForViewDto | undefined;
}

export class EstimatePdfDto implements IEstimatePdfDto {
    assetOwnerInfo!: AssetOwnerDto | undefined;
    assetOwnerAddress!: AddressDto | undefined;
    assetOwnerContact!: ContactDto | undefined;
    estimateInfo!: EstimateDto | undefined;
    estimateDetailList!: PdfEstimateDetailListDto | undefined;
    customerInfo!: CustomerDto | undefined;
    customerAddress!: AddressDto | undefined;
    customerContact!: ContactDto | undefined;
    authenticationKey!: string | undefined;

    constructor(data?: IEstimatePdfDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assetOwnerInfo = data["assetOwnerInfo"] ? AssetOwnerDto.fromJS(data["assetOwnerInfo"]) : <any>undefined;
            this.assetOwnerAddress = data["assetOwnerAddress"] ? AddressDto.fromJS(data["assetOwnerAddress"]) : <any>undefined;
            this.assetOwnerContact = data["assetOwnerContact"] ? ContactDto.fromJS(data["assetOwnerContact"]) : <any>undefined;
            this.estimateInfo = data["estimateInfo"] ? EstimateDto.fromJS(data["estimateInfo"]) : <any>undefined;
            this.estimateDetailList = data["estimateDetailList"] ? PdfEstimateDetailListDto.fromJS(data["estimateDetailList"]) : <any>undefined;
            this.customerInfo = data["customerInfo"] ? CustomerDto.fromJS(data["customerInfo"]) : <any>undefined;
            this.customerAddress = data["customerAddress"] ? AddressDto.fromJS(data["customerAddress"]) : <any>undefined;
            this.customerContact = data["customerContact"] ? ContactDto.fromJS(data["customerContact"]) : <any>undefined;
            this.authenticationKey = data["authenticationKey"];
        }
    }

    static fromJS(data: any): EstimatePdfDto {
        data = typeof data === 'object' ? data : {};
        let result = new EstimatePdfDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assetOwnerInfo"] = this.assetOwnerInfo ? this.assetOwnerInfo.toJSON() : <any>undefined;
        data["assetOwnerAddress"] = this.assetOwnerAddress ? this.assetOwnerAddress.toJSON() : <any>undefined;
        data["assetOwnerContact"] = this.assetOwnerContact ? this.assetOwnerContact.toJSON() : <any>undefined;
        data["estimateInfo"] = this.estimateInfo ? this.estimateInfo.toJSON() : <any>undefined;
        data["estimateDetailList"] = this.estimateDetailList ? this.estimateDetailList.toJSON() : <any>undefined;
        data["customerInfo"] = this.customerInfo ? this.customerInfo.toJSON() : <any>undefined;
        data["customerAddress"] = this.customerAddress ? this.customerAddress.toJSON() : <any>undefined;
        data["customerContact"] = this.customerContact ? this.customerContact.toJSON() : <any>undefined;
        data["authenticationKey"] = this.authenticationKey;
        return data; 
    }
}

export interface IEstimatePdfDto {
    assetOwnerInfo: AssetOwnerDto | undefined;
    assetOwnerAddress: AddressDto | undefined;
    assetOwnerContact: ContactDto | undefined;
    estimateInfo: EstimateDto | undefined;
    estimateDetailList: PdfEstimateDetailListDto | undefined;
    customerInfo: CustomerDto | undefined;
    customerAddress: AddressDto | undefined;
    customerContact: ContactDto | undefined;
    authenticationKey: string | undefined;
}

export class PdfEstimateDetailListDto implements IPdfEstimateDetailListDto {
    detailList!: PdfEstimateDetailForViewDto[] | undefined;
    totalTax!: number | undefined;
    totalAmount!: number | undefined;

    constructor(data?: IPdfEstimateDetailListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["detailList"])) {
                this.detailList = [] as any;
                for (let item of data["detailList"])
                    this.detailList!.push(PdfEstimateDetailForViewDto.fromJS(item));
            }
            this.totalTax = data["totalTax"];
            this.totalAmount = data["totalAmount"];
        }
    }

    static fromJS(data: any): PdfEstimateDetailListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PdfEstimateDetailListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.detailList)) {
            data["detailList"] = [];
            for (let item of this.detailList)
                data["detailList"].push(item.toJSON());
        }
        data["totalTax"] = this.totalTax;
        data["totalAmount"] = this.totalAmount;
        return data; 
    }
}

export interface IPdfEstimateDetailListDto {
    detailList: PdfEstimateDetailForViewDto[] | undefined;
    totalTax: number | undefined;
    totalAmount: number | undefined;
}

export class PdfEstimateDetailForViewDto implements IPdfEstimateDetailForViewDto {
    estimateDetail!: PdfEstimateDetailDto | undefined;
    itemTypeType!: string | undefined;
    uomUnitOfMeasurement!: string | undefined;
    actionWorkOrderAction!: string | undefined;

    constructor(data?: IPdfEstimateDetailForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.estimateDetail = data["estimateDetail"] ? PdfEstimateDetailDto.fromJS(data["estimateDetail"]) : <any>undefined;
            this.itemTypeType = data["itemTypeType"];
            this.uomUnitOfMeasurement = data["uomUnitOfMeasurement"];
            this.actionWorkOrderAction = data["actionWorkOrderAction"];
        }
    }

    static fromJS(data: any): PdfEstimateDetailForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PdfEstimateDetailForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["estimateDetail"] = this.estimateDetail ? this.estimateDetail.toJSON() : <any>undefined;
        data["itemTypeType"] = this.itemTypeType;
        data["uomUnitOfMeasurement"] = this.uomUnitOfMeasurement;
        data["actionWorkOrderAction"] = this.actionWorkOrderAction;
        return data; 
    }
}

export interface IPdfEstimateDetailForViewDto {
    estimateDetail: PdfEstimateDetailDto | undefined;
    itemTypeType: string | undefined;
    uomUnitOfMeasurement: string | undefined;
    actionWorkOrderAction: string | undefined;
}

export class PdfEstimateDetailDto implements IPdfEstimateDetailDto {
    id!: number | undefined;
    estimateId!: number | undefined;
    itemTypeId!: number | undefined;
    uomId!: number | undefined;
    workOrderActionId!: number | undefined;
    description!: string | undefined;
    quantity!: number | undefined;
    calculatedUnitPrice!: number | undefined;
    calculatedAmount!: number | undefined;
    unitPrice!: number | undefined;
    cost!: number | undefined;
    tax!: number | undefined;
    charge!: number | undefined;
    discount!: number | undefined;
    markUp!: number | undefined;
    remark!: string | undefined;

    constructor(data?: IPdfEstimateDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.estimateId = data["estimateId"];
            this.itemTypeId = data["itemTypeId"];
            this.uomId = data["uomId"];
            this.workOrderActionId = data["workOrderActionId"];
            this.description = data["description"];
            this.quantity = data["quantity"];
            this.calculatedUnitPrice = data["calculatedUnitPrice"];
            this.calculatedAmount = data["calculatedAmount"];
            this.unitPrice = data["unitPrice"];
            this.cost = data["cost"];
            this.tax = data["tax"];
            this.charge = data["charge"];
            this.discount = data["discount"];
            this.markUp = data["markUp"];
            this.remark = data["remark"];
        }
    }

    static fromJS(data: any): PdfEstimateDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new PdfEstimateDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["estimateId"] = this.estimateId;
        data["itemTypeId"] = this.itemTypeId;
        data["uomId"] = this.uomId;
        data["workOrderActionId"] = this.workOrderActionId;
        data["description"] = this.description;
        data["quantity"] = this.quantity;
        data["calculatedUnitPrice"] = this.calculatedUnitPrice;
        data["calculatedAmount"] = this.calculatedAmount;
        data["unitPrice"] = this.unitPrice;
        data["cost"] = this.cost;
        data["tax"] = this.tax;
        data["charge"] = this.charge;
        data["discount"] = this.discount;
        data["markUp"] = this.markUp;
        data["remark"] = this.remark;
        return data; 
    }
}

export interface IPdfEstimateDetailDto {
    id: number | undefined;
    estimateId: number | undefined;
    itemTypeId: number | undefined;
    uomId: number | undefined;
    workOrderActionId: number | undefined;
    description: string | undefined;
    quantity: number | undefined;
    calculatedUnitPrice: number | undefined;
    calculatedAmount: number | undefined;
    unitPrice: number | undefined;
    cost: number | undefined;
    tax: number | undefined;
    charge: number | undefined;
    discount: number | undefined;
    markUp: number | undefined;
    remark: string | undefined;
}

export class PagedResultDtoOfGetEstimateStatusForViewDto implements IPagedResultDtoOfGetEstimateStatusForViewDto {
    totalCount!: number | undefined;
    items!: GetEstimateStatusForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetEstimateStatusForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetEstimateStatusForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetEstimateStatusForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetEstimateStatusForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetEstimateStatusForViewDto {
    totalCount: number | undefined;
    items: GetEstimateStatusForViewDto[] | undefined;
}

export class GetEstimateStatusForViewDto implements IGetEstimateStatusForViewDto {
    estimateStatus!: EstimateStatusDto | undefined;

    constructor(data?: IGetEstimateStatusForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.estimateStatus = data["estimateStatus"] ? EstimateStatusDto.fromJS(data["estimateStatus"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetEstimateStatusForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetEstimateStatusForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["estimateStatus"] = this.estimateStatus ? this.estimateStatus.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetEstimateStatusForViewDto {
    estimateStatus: EstimateStatusDto | undefined;
}

export class EstimateStatusDto implements IEstimateStatusDto {
    status!: string | undefined;
    description!: string | undefined;
    id!: number | undefined;

    constructor(data?: IEstimateStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"];
            this.description = data["description"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EstimateStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new EstimateStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }
}

export interface IEstimateStatusDto {
    status: string | undefined;
    description: string | undefined;
    id: number | undefined;
}

export class GetEstimateStatusForEditOutput implements IGetEstimateStatusForEditOutput {
    estimateStatus!: CreateOrEditEstimateStatusDto | undefined;

    constructor(data?: IGetEstimateStatusForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.estimateStatus = data["estimateStatus"] ? CreateOrEditEstimateStatusDto.fromJS(data["estimateStatus"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetEstimateStatusForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetEstimateStatusForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["estimateStatus"] = this.estimateStatus ? this.estimateStatus.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetEstimateStatusForEditOutput {
    estimateStatus: CreateOrEditEstimateStatusDto | undefined;
}

export class CreateOrEditEstimateStatusDto implements ICreateOrEditEstimateStatusDto {
    status!: string;
    description!: string;
    id!: number | undefined;

    constructor(data?: ICreateOrEditEstimateStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"];
            this.description = data["description"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditEstimateStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditEstimateStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditEstimateStatusDto {
    status: string;
    description: string;
    id: number | undefined;
}

export class CreateFriendshipRequestInput implements ICreateFriendshipRequestInput {
    userId!: number | undefined;
    tenantId!: number | undefined;

    constructor(data?: ICreateFriendshipRequestInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): CreateFriendshipRequestInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFriendshipRequestInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data; 
    }
}

export interface ICreateFriendshipRequestInput {
    userId: number | undefined;
    tenantId: number | undefined;
}

export class CreateFriendshipRequestByUserNameInput implements ICreateFriendshipRequestByUserNameInput {
    tenancyName!: string;
    userName!: string | undefined;

    constructor(data?: ICreateFriendshipRequestByUserNameInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.userName = data["userName"];
        }
    }

    static fromJS(data: any): CreateFriendshipRequestByUserNameInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateFriendshipRequestByUserNameInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["userName"] = this.userName;
        return data; 
    }
}

export interface ICreateFriendshipRequestByUserNameInput {
    tenancyName: string;
    userName: string | undefined;
}

export class BlockUserInput implements IBlockUserInput {
    userId!: number | undefined;
    tenantId!: number | undefined;

    constructor(data?: IBlockUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): BlockUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new BlockUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data; 
    }
}

export interface IBlockUserInput {
    userId: number | undefined;
    tenantId: number | undefined;
}

export class UnblockUserInput implements IUnblockUserInput {
    userId!: number | undefined;
    tenantId!: number | undefined;

    constructor(data?: IUnblockUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): UnblockUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new UnblockUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data; 
    }
}

export interface IUnblockUserInput {
    userId: number | undefined;
    tenantId: number | undefined;
}

export class AcceptFriendshipRequestInput implements IAcceptFriendshipRequestInput {
    userId!: number | undefined;
    tenantId!: number | undefined;

    constructor(data?: IAcceptFriendshipRequestInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
        }
    }

    static fromJS(data: any): AcceptFriendshipRequestInput {
        data = typeof data === 'object' ? data : {};
        let result = new AcceptFriendshipRequestInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        return data; 
    }
}

export interface IAcceptFriendshipRequestInput {
    userId: number | undefined;
    tenantId: number | undefined;
}

export enum ChartDateInterval {
    Daily = 1,
    Weekly = 2,
    Monthly = 3,
}

export class HostDashboardData implements IHostDashboardData {
    newTenantsCount!: number | undefined;
    newSubscriptionAmount!: number | undefined;
    dashboardPlaceholder1!: number | undefined;
    dashboardPlaceholder2!: number | undefined;
    incomeStatistics!: IncomeStastistic[] | undefined;
    editionStatistics!: TenantEdition[] | undefined;
    expiringTenants!: ExpiringTenant[] | undefined;
    recentTenants!: RecentTenant[] | undefined;
    maxExpiringTenantsShownCount!: number | undefined;
    maxRecentTenantsShownCount!: number | undefined;
    subscriptionEndAlertDayCount!: number | undefined;
    recentTenantsDayCount!: number | undefined;
    subscriptionEndDateStart!: moment.Moment | undefined;
    subscriptionEndDateEnd!: moment.Moment | undefined;
    tenantCreationStartDate!: moment.Moment | undefined;

    constructor(data?: IHostDashboardData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.newTenantsCount = data["newTenantsCount"];
            this.newSubscriptionAmount = data["newSubscriptionAmount"];
            this.dashboardPlaceholder1 = data["dashboardPlaceholder1"];
            this.dashboardPlaceholder2 = data["dashboardPlaceholder2"];
            if (Array.isArray(data["incomeStatistics"])) {
                this.incomeStatistics = [] as any;
                for (let item of data["incomeStatistics"])
                    this.incomeStatistics!.push(IncomeStastistic.fromJS(item));
            }
            if (Array.isArray(data["editionStatistics"])) {
                this.editionStatistics = [] as any;
                for (let item of data["editionStatistics"])
                    this.editionStatistics!.push(TenantEdition.fromJS(item));
            }
            if (Array.isArray(data["expiringTenants"])) {
                this.expiringTenants = [] as any;
                for (let item of data["expiringTenants"])
                    this.expiringTenants!.push(ExpiringTenant.fromJS(item));
            }
            if (Array.isArray(data["recentTenants"])) {
                this.recentTenants = [] as any;
                for (let item of data["recentTenants"])
                    this.recentTenants!.push(RecentTenant.fromJS(item));
            }
            this.maxExpiringTenantsShownCount = data["maxExpiringTenantsShownCount"];
            this.maxRecentTenantsShownCount = data["maxRecentTenantsShownCount"];
            this.subscriptionEndAlertDayCount = data["subscriptionEndAlertDayCount"];
            this.recentTenantsDayCount = data["recentTenantsDayCount"];
            this.subscriptionEndDateStart = data["subscriptionEndDateStart"] ? moment(data["subscriptionEndDateStart"].toString()) : <any>undefined;
            this.subscriptionEndDateEnd = data["subscriptionEndDateEnd"] ? moment(data["subscriptionEndDateEnd"].toString()) : <any>undefined;
            this.tenantCreationStartDate = data["tenantCreationStartDate"] ? moment(data["tenantCreationStartDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): HostDashboardData {
        data = typeof data === 'object' ? data : {};
        let result = new HostDashboardData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newTenantsCount"] = this.newTenantsCount;
        data["newSubscriptionAmount"] = this.newSubscriptionAmount;
        data["dashboardPlaceholder1"] = this.dashboardPlaceholder1;
        data["dashboardPlaceholder2"] = this.dashboardPlaceholder2;
        if (Array.isArray(this.incomeStatistics)) {
            data["incomeStatistics"] = [];
            for (let item of this.incomeStatistics)
                data["incomeStatistics"].push(item.toJSON());
        }
        if (Array.isArray(this.editionStatistics)) {
            data["editionStatistics"] = [];
            for (let item of this.editionStatistics)
                data["editionStatistics"].push(item.toJSON());
        }
        if (Array.isArray(this.expiringTenants)) {
            data["expiringTenants"] = [];
            for (let item of this.expiringTenants)
                data["expiringTenants"].push(item.toJSON());
        }
        if (Array.isArray(this.recentTenants)) {
            data["recentTenants"] = [];
            for (let item of this.recentTenants)
                data["recentTenants"].push(item.toJSON());
        }
        data["maxExpiringTenantsShownCount"] = this.maxExpiringTenantsShownCount;
        data["maxRecentTenantsShownCount"] = this.maxRecentTenantsShownCount;
        data["subscriptionEndAlertDayCount"] = this.subscriptionEndAlertDayCount;
        data["recentTenantsDayCount"] = this.recentTenantsDayCount;
        data["subscriptionEndDateStart"] = this.subscriptionEndDateStart ? this.subscriptionEndDateStart.toISOString() : <any>undefined;
        data["subscriptionEndDateEnd"] = this.subscriptionEndDateEnd ? this.subscriptionEndDateEnd.toISOString() : <any>undefined;
        data["tenantCreationStartDate"] = this.tenantCreationStartDate ? this.tenantCreationStartDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IHostDashboardData {
    newTenantsCount: number | undefined;
    newSubscriptionAmount: number | undefined;
    dashboardPlaceholder1: number | undefined;
    dashboardPlaceholder2: number | undefined;
    incomeStatistics: IncomeStastistic[] | undefined;
    editionStatistics: TenantEdition[] | undefined;
    expiringTenants: ExpiringTenant[] | undefined;
    recentTenants: RecentTenant[] | undefined;
    maxExpiringTenantsShownCount: number | undefined;
    maxRecentTenantsShownCount: number | undefined;
    subscriptionEndAlertDayCount: number | undefined;
    recentTenantsDayCount: number | undefined;
    subscriptionEndDateStart: moment.Moment | undefined;
    subscriptionEndDateEnd: moment.Moment | undefined;
    tenantCreationStartDate: moment.Moment | undefined;
}

export class IncomeStastistic implements IIncomeStastistic {
    label!: string | undefined;
    date!: moment.Moment | undefined;
    amount!: number | undefined;

    constructor(data?: IIncomeStastistic) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.label = data["label"];
            this.date = data["date"] ? moment(data["date"].toString()) : <any>undefined;
            this.amount = data["amount"];
        }
    }

    static fromJS(data: any): IncomeStastistic {
        data = typeof data === 'object' ? data : {};
        let result = new IncomeStastistic();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["amount"] = this.amount;
        return data; 
    }
}

export interface IIncomeStastistic {
    label: string | undefined;
    date: moment.Moment | undefined;
    amount: number | undefined;
}

export class TenantEdition implements ITenantEdition {
    label!: string | undefined;
    value!: number | undefined;

    constructor(data?: ITenantEdition) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.label = data["label"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): TenantEdition {
        data = typeof data === 'object' ? data : {};
        let result = new TenantEdition();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["value"] = this.value;
        return data; 
    }
}

export interface ITenantEdition {
    label: string | undefined;
    value: number | undefined;
}

export class ExpiringTenant implements IExpiringTenant {
    tenantName!: string | undefined;
    remainingDayCount!: number | undefined;

    constructor(data?: IExpiringTenant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantName = data["tenantName"];
            this.remainingDayCount = data["remainingDayCount"];
        }
    }

    static fromJS(data: any): ExpiringTenant {
        data = typeof data === 'object' ? data : {};
        let result = new ExpiringTenant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantName"] = this.tenantName;
        data["remainingDayCount"] = this.remainingDayCount;
        return data; 
    }
}

export interface IExpiringTenant {
    tenantName: string | undefined;
    remainingDayCount: number | undefined;
}

export class RecentTenant implements IRecentTenant {
    id!: number | undefined;
    name!: string | undefined;
    creationTime!: moment.Moment | undefined;

    constructor(data?: IRecentTenant) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): RecentTenant {
        data = typeof data === 'object' ? data : {};
        let result = new RecentTenant();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IRecentTenant {
    id: number | undefined;
    name: string | undefined;
    creationTime: moment.Moment | undefined;
}

export class GetIncomeStatisticsDataOutput implements IGetIncomeStatisticsDataOutput {
    incomeStatistics!: IncomeStastistic[] | undefined;

    constructor(data?: IGetIncomeStatisticsDataOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["incomeStatistics"])) {
                this.incomeStatistics = [] as any;
                for (let item of data["incomeStatistics"])
                    this.incomeStatistics!.push(IncomeStastistic.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetIncomeStatisticsDataOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetIncomeStatisticsDataOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.incomeStatistics)) {
            data["incomeStatistics"] = [];
            for (let item of this.incomeStatistics)
                data["incomeStatistics"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetIncomeStatisticsDataOutput {
    incomeStatistics: IncomeStastistic[] | undefined;
}

export class GetEditionTenantStatisticsOutput implements IGetEditionTenantStatisticsOutput {
    editionStatistics!: TenantEdition[] | undefined;

    constructor(data?: IGetEditionTenantStatisticsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["editionStatistics"])) {
                this.editionStatistics = [] as any;
                for (let item of data["editionStatistics"])
                    this.editionStatistics!.push(TenantEdition.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetEditionTenantStatisticsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetEditionTenantStatisticsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.editionStatistics)) {
            data["editionStatistics"] = [];
            for (let item of this.editionStatistics)
                data["editionStatistics"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetEditionTenantStatisticsOutput {
    editionStatistics: TenantEdition[] | undefined;
}

export class HostSettingsEditDto implements IHostSettingsEditDto {
    general!: GeneralSettingsEditDto;
    userManagement!: HostUserManagementSettingsEditDto;
    email!: EmailSettingsEditDto;
    tenantManagement!: TenantManagementSettingsEditDto;
    security!: SecuritySettingsEditDto;
    billing!: HostBillingSettingsEditDto | undefined;
    otherSettings!: OtherSettingsEditDto | undefined;

    constructor(data?: IHostSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.general = new GeneralSettingsEditDto();
            this.userManagement = new HostUserManagementSettingsEditDto();
            this.email = new EmailSettingsEditDto();
            this.tenantManagement = new TenantManagementSettingsEditDto();
            this.security = new SecuritySettingsEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.general = data["general"] ? GeneralSettingsEditDto.fromJS(data["general"]) : new GeneralSettingsEditDto();
            this.userManagement = data["userManagement"] ? HostUserManagementSettingsEditDto.fromJS(data["userManagement"]) : new HostUserManagementSettingsEditDto();
            this.email = data["email"] ? EmailSettingsEditDto.fromJS(data["email"]) : new EmailSettingsEditDto();
            this.tenantManagement = data["tenantManagement"] ? TenantManagementSettingsEditDto.fromJS(data["tenantManagement"]) : new TenantManagementSettingsEditDto();
            this.security = data["security"] ? SecuritySettingsEditDto.fromJS(data["security"]) : new SecuritySettingsEditDto();
            this.billing = data["billing"] ? HostBillingSettingsEditDto.fromJS(data["billing"]) : <any>undefined;
            this.otherSettings = data["otherSettings"] ? OtherSettingsEditDto.fromJS(data["otherSettings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): HostSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["general"] = this.general ? this.general.toJSON() : <any>undefined;
        data["userManagement"] = this.userManagement ? this.userManagement.toJSON() : <any>undefined;
        data["email"] = this.email ? this.email.toJSON() : <any>undefined;
        data["tenantManagement"] = this.tenantManagement ? this.tenantManagement.toJSON() : <any>undefined;
        data["security"] = this.security ? this.security.toJSON() : <any>undefined;
        data["billing"] = this.billing ? this.billing.toJSON() : <any>undefined;
        data["otherSettings"] = this.otherSettings ? this.otherSettings.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IHostSettingsEditDto {
    general: GeneralSettingsEditDto;
    userManagement: HostUserManagementSettingsEditDto;
    email: EmailSettingsEditDto;
    tenantManagement: TenantManagementSettingsEditDto;
    security: SecuritySettingsEditDto;
    billing: HostBillingSettingsEditDto | undefined;
    otherSettings: OtherSettingsEditDto | undefined;
}

export class GeneralSettingsEditDto implements IGeneralSettingsEditDto {
    timezone!: string | undefined;
    timezoneForComparison!: string | undefined;

    constructor(data?: IGeneralSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.timezone = data["timezone"];
            this.timezoneForComparison = data["timezoneForComparison"];
        }
    }

    static fromJS(data: any): GeneralSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new GeneralSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["timezone"] = this.timezone;
        data["timezoneForComparison"] = this.timezoneForComparison;
        return data; 
    }
}

export interface IGeneralSettingsEditDto {
    timezone: string | undefined;
    timezoneForComparison: string | undefined;
}

export class HostUserManagementSettingsEditDto implements IHostUserManagementSettingsEditDto {
    isEmailConfirmationRequiredForLogin!: boolean | undefined;
    smsVerificationEnabled!: boolean | undefined;
    isCookieConsentEnabled!: boolean | undefined;
    isQuickThemeSelectEnabled!: boolean | undefined;
    useCaptchaOnLogin!: boolean | undefined;
    sessionTimeOutSettings!: SessionTimeOutSettingsEditDto | undefined;

    constructor(data?: IHostUserManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isEmailConfirmationRequiredForLogin = data["isEmailConfirmationRequiredForLogin"];
            this.smsVerificationEnabled = data["smsVerificationEnabled"];
            this.isCookieConsentEnabled = data["isCookieConsentEnabled"];
            this.isQuickThemeSelectEnabled = data["isQuickThemeSelectEnabled"];
            this.useCaptchaOnLogin = data["useCaptchaOnLogin"];
            this.sessionTimeOutSettings = data["sessionTimeOutSettings"] ? SessionTimeOutSettingsEditDto.fromJS(data["sessionTimeOutSettings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): HostUserManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostUserManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEmailConfirmationRequiredForLogin"] = this.isEmailConfirmationRequiredForLogin;
        data["smsVerificationEnabled"] = this.smsVerificationEnabled;
        data["isCookieConsentEnabled"] = this.isCookieConsentEnabled;
        data["isQuickThemeSelectEnabled"] = this.isQuickThemeSelectEnabled;
        data["useCaptchaOnLogin"] = this.useCaptchaOnLogin;
        data["sessionTimeOutSettings"] = this.sessionTimeOutSettings ? this.sessionTimeOutSettings.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IHostUserManagementSettingsEditDto {
    isEmailConfirmationRequiredForLogin: boolean | undefined;
    smsVerificationEnabled: boolean | undefined;
    isCookieConsentEnabled: boolean | undefined;
    isQuickThemeSelectEnabled: boolean | undefined;
    useCaptchaOnLogin: boolean | undefined;
    sessionTimeOutSettings: SessionTimeOutSettingsEditDto | undefined;
}

export class EmailSettingsEditDto implements IEmailSettingsEditDto {
    defaultFromAddress!: string | undefined;
    defaultFromDisplayName!: string | undefined;
    smtpHost!: string | undefined;
    smtpPort!: number | undefined;
    smtpUserName!: string | undefined;
    smtpPassword!: string | undefined;
    smtpDomain!: string | undefined;
    smtpEnableSsl!: boolean | undefined;
    smtpUseDefaultCredentials!: boolean | undefined;

    constructor(data?: IEmailSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.defaultFromAddress = data["defaultFromAddress"];
            this.defaultFromDisplayName = data["defaultFromDisplayName"];
            this.smtpHost = data["smtpHost"];
            this.smtpPort = data["smtpPort"];
            this.smtpUserName = data["smtpUserName"];
            this.smtpPassword = data["smtpPassword"];
            this.smtpDomain = data["smtpDomain"];
            this.smtpEnableSsl = data["smtpEnableSsl"];
            this.smtpUseDefaultCredentials = data["smtpUseDefaultCredentials"];
        }
    }

    static fromJS(data: any): EmailSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new EmailSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultFromAddress"] = this.defaultFromAddress;
        data["defaultFromDisplayName"] = this.defaultFromDisplayName;
        data["smtpHost"] = this.smtpHost;
        data["smtpPort"] = this.smtpPort;
        data["smtpUserName"] = this.smtpUserName;
        data["smtpPassword"] = this.smtpPassword;
        data["smtpDomain"] = this.smtpDomain;
        data["smtpEnableSsl"] = this.smtpEnableSsl;
        data["smtpUseDefaultCredentials"] = this.smtpUseDefaultCredentials;
        return data; 
    }
}

export interface IEmailSettingsEditDto {
    defaultFromAddress: string | undefined;
    defaultFromDisplayName: string | undefined;
    smtpHost: string | undefined;
    smtpPort: number | undefined;
    smtpUserName: string | undefined;
    smtpPassword: string | undefined;
    smtpDomain: string | undefined;
    smtpEnableSsl: boolean | undefined;
    smtpUseDefaultCredentials: boolean | undefined;
}

export class TenantManagementSettingsEditDto implements ITenantManagementSettingsEditDto {
    allowSelfRegistration!: boolean | undefined;
    isNewRegisteredTenantActiveByDefault!: boolean | undefined;
    useCaptchaOnRegistration!: boolean | undefined;
    defaultEditionId!: number | undefined;

    constructor(data?: ITenantManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.allowSelfRegistration = data["allowSelfRegistration"];
            this.isNewRegisteredTenantActiveByDefault = data["isNewRegisteredTenantActiveByDefault"];
            this.useCaptchaOnRegistration = data["useCaptchaOnRegistration"];
            this.defaultEditionId = data["defaultEditionId"];
        }
    }

    static fromJS(data: any): TenantManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowSelfRegistration"] = this.allowSelfRegistration;
        data["isNewRegisteredTenantActiveByDefault"] = this.isNewRegisteredTenantActiveByDefault;
        data["useCaptchaOnRegistration"] = this.useCaptchaOnRegistration;
        data["defaultEditionId"] = this.defaultEditionId;
        return data; 
    }
}

export interface ITenantManagementSettingsEditDto {
    allowSelfRegistration: boolean | undefined;
    isNewRegisteredTenantActiveByDefault: boolean | undefined;
    useCaptchaOnRegistration: boolean | undefined;
    defaultEditionId: number | undefined;
}

export class SecuritySettingsEditDto implements ISecuritySettingsEditDto {
    allowOneConcurrentLoginPerUser!: boolean | undefined;
    useDefaultPasswordComplexitySettings!: boolean | undefined;
    passwordComplexity!: PasswordComplexitySetting | undefined;
    defaultPasswordComplexity!: PasswordComplexitySetting | undefined;
    userLockOut!: UserLockOutSettingsEditDto | undefined;
    twoFactorLogin!: TwoFactorLoginSettingsEditDto | undefined;

    constructor(data?: ISecuritySettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.allowOneConcurrentLoginPerUser = data["allowOneConcurrentLoginPerUser"];
            this.useDefaultPasswordComplexitySettings = data["useDefaultPasswordComplexitySettings"];
            this.passwordComplexity = data["passwordComplexity"] ? PasswordComplexitySetting.fromJS(data["passwordComplexity"]) : <any>undefined;
            this.defaultPasswordComplexity = data["defaultPasswordComplexity"] ? PasswordComplexitySetting.fromJS(data["defaultPasswordComplexity"]) : <any>undefined;
            this.userLockOut = data["userLockOut"] ? UserLockOutSettingsEditDto.fromJS(data["userLockOut"]) : <any>undefined;
            this.twoFactorLogin = data["twoFactorLogin"] ? TwoFactorLoginSettingsEditDto.fromJS(data["twoFactorLogin"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SecuritySettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new SecuritySettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowOneConcurrentLoginPerUser"] = this.allowOneConcurrentLoginPerUser;
        data["useDefaultPasswordComplexitySettings"] = this.useDefaultPasswordComplexitySettings;
        data["passwordComplexity"] = this.passwordComplexity ? this.passwordComplexity.toJSON() : <any>undefined;
        data["defaultPasswordComplexity"] = this.defaultPasswordComplexity ? this.defaultPasswordComplexity.toJSON() : <any>undefined;
        data["userLockOut"] = this.userLockOut ? this.userLockOut.toJSON() : <any>undefined;
        data["twoFactorLogin"] = this.twoFactorLogin ? this.twoFactorLogin.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ISecuritySettingsEditDto {
    allowOneConcurrentLoginPerUser: boolean | undefined;
    useDefaultPasswordComplexitySettings: boolean | undefined;
    passwordComplexity: PasswordComplexitySetting | undefined;
    defaultPasswordComplexity: PasswordComplexitySetting | undefined;
    userLockOut: UserLockOutSettingsEditDto | undefined;
    twoFactorLogin: TwoFactorLoginSettingsEditDto | undefined;
}

export class HostBillingSettingsEditDto implements IHostBillingSettingsEditDto {
    legalName!: string | undefined;
    address!: string | undefined;

    constructor(data?: IHostBillingSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.legalName = data["legalName"];
            this.address = data["address"];
        }
    }

    static fromJS(data: any): HostBillingSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new HostBillingSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["legalName"] = this.legalName;
        data["address"] = this.address;
        return data; 
    }
}

export interface IHostBillingSettingsEditDto {
    legalName: string | undefined;
    address: string | undefined;
}

export class OtherSettingsEditDto implements IOtherSettingsEditDto {
    isQuickThemeSelectEnabled!: boolean | undefined;

    constructor(data?: IOtherSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isQuickThemeSelectEnabled = data["isQuickThemeSelectEnabled"];
        }
    }

    static fromJS(data: any): OtherSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new OtherSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isQuickThemeSelectEnabled"] = this.isQuickThemeSelectEnabled;
        return data; 
    }
}

export interface IOtherSettingsEditDto {
    isQuickThemeSelectEnabled: boolean | undefined;
}

export class SessionTimeOutSettingsEditDto implements ISessionTimeOutSettingsEditDto {
    isEnabled!: boolean | undefined;
    timeOutSecond!: number | undefined;
    showTimeOutNotificationSecond!: number | undefined;

    constructor(data?: ISessionTimeOutSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isEnabled = data["isEnabled"];
            this.timeOutSecond = data["timeOutSecond"];
            this.showTimeOutNotificationSecond = data["showTimeOutNotificationSecond"];
        }
    }

    static fromJS(data: any): SessionTimeOutSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new SessionTimeOutSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabled"] = this.isEnabled;
        data["timeOutSecond"] = this.timeOutSecond;
        data["showTimeOutNotificationSecond"] = this.showTimeOutNotificationSecond;
        return data; 
    }
}

export interface ISessionTimeOutSettingsEditDto {
    isEnabled: boolean | undefined;
    timeOutSecond: number | undefined;
    showTimeOutNotificationSecond: number | undefined;
}

export class PasswordComplexitySetting implements IPasswordComplexitySetting {
    requireDigit!: boolean | undefined;
    requireLowercase!: boolean | undefined;
    requireNonAlphanumeric!: boolean | undefined;
    requireUppercase!: boolean | undefined;
    requiredLength!: number | undefined;

    constructor(data?: IPasswordComplexitySetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.requireDigit = data["requireDigit"];
            this.requireLowercase = data["requireLowercase"];
            this.requireNonAlphanumeric = data["requireNonAlphanumeric"];
            this.requireUppercase = data["requireUppercase"];
            this.requiredLength = data["requiredLength"];
        }
    }

    static fromJS(data: any): PasswordComplexitySetting {
        data = typeof data === 'object' ? data : {};
        let result = new PasswordComplexitySetting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requireDigit"] = this.requireDigit;
        data["requireLowercase"] = this.requireLowercase;
        data["requireNonAlphanumeric"] = this.requireNonAlphanumeric;
        data["requireUppercase"] = this.requireUppercase;
        data["requiredLength"] = this.requiredLength;
        return data; 
    }
}

export interface IPasswordComplexitySetting {
    requireDigit: boolean | undefined;
    requireLowercase: boolean | undefined;
    requireNonAlphanumeric: boolean | undefined;
    requireUppercase: boolean | undefined;
    requiredLength: number | undefined;
}

export class UserLockOutSettingsEditDto implements IUserLockOutSettingsEditDto {
    isEnabled!: boolean | undefined;
    maxFailedAccessAttemptsBeforeLockout!: number | undefined;
    defaultAccountLockoutSeconds!: number | undefined;

    constructor(data?: IUserLockOutSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isEnabled = data["isEnabled"];
            this.maxFailedAccessAttemptsBeforeLockout = data["maxFailedAccessAttemptsBeforeLockout"];
            this.defaultAccountLockoutSeconds = data["defaultAccountLockoutSeconds"];
        }
    }

    static fromJS(data: any): UserLockOutSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLockOutSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabled"] = this.isEnabled;
        data["maxFailedAccessAttemptsBeforeLockout"] = this.maxFailedAccessAttemptsBeforeLockout;
        data["defaultAccountLockoutSeconds"] = this.defaultAccountLockoutSeconds;
        return data; 
    }
}

export interface IUserLockOutSettingsEditDto {
    isEnabled: boolean | undefined;
    maxFailedAccessAttemptsBeforeLockout: number | undefined;
    defaultAccountLockoutSeconds: number | undefined;
}

export class TwoFactorLoginSettingsEditDto implements ITwoFactorLoginSettingsEditDto {
    isEnabledForApplication!: boolean | undefined;
    isEnabled!: boolean | undefined;
    isEmailProviderEnabled!: boolean | undefined;
    isSmsProviderEnabled!: boolean | undefined;
    isRememberBrowserEnabled!: boolean | undefined;
    isGoogleAuthenticatorEnabled!: boolean | undefined;

    constructor(data?: ITwoFactorLoginSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isEnabledForApplication = data["isEnabledForApplication"];
            this.isEnabled = data["isEnabled"];
            this.isEmailProviderEnabled = data["isEmailProviderEnabled"];
            this.isSmsProviderEnabled = data["isSmsProviderEnabled"];
            this.isRememberBrowserEnabled = data["isRememberBrowserEnabled"];
            this.isGoogleAuthenticatorEnabled = data["isGoogleAuthenticatorEnabled"];
        }
    }

    static fromJS(data: any): TwoFactorLoginSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TwoFactorLoginSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isEnabledForApplication"] = this.isEnabledForApplication;
        data["isEnabled"] = this.isEnabled;
        data["isEmailProviderEnabled"] = this.isEmailProviderEnabled;
        data["isSmsProviderEnabled"] = this.isSmsProviderEnabled;
        data["isRememberBrowserEnabled"] = this.isRememberBrowserEnabled;
        data["isGoogleAuthenticatorEnabled"] = this.isGoogleAuthenticatorEnabled;
        return data; 
    }
}

export interface ITwoFactorLoginSettingsEditDto {
    isEnabledForApplication: boolean | undefined;
    isEnabled: boolean | undefined;
    isEmailProviderEnabled: boolean | undefined;
    isSmsProviderEnabled: boolean | undefined;
    isRememberBrowserEnabled: boolean | undefined;
    isGoogleAuthenticatorEnabled: boolean | undefined;
}

export class SendTestEmailInput implements ISendTestEmailInput {
    emailAddress!: string;

    constructor(data?: ISendTestEmailInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.emailAddress = data["emailAddress"];
        }
    }

    static fromJS(data: any): SendTestEmailInput {
        data = typeof data === 'object' ? data : {};
        let result = new SendTestEmailInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["emailAddress"] = this.emailAddress;
        return data; 
    }
}

export interface ISendTestEmailInput {
    emailAddress: string;
}

export class PagedResultDtoOfGetIncidentPriorityForViewDto implements IPagedResultDtoOfGetIncidentPriorityForViewDto {
    totalCount!: number | undefined;
    items!: GetIncidentPriorityForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetIncidentPriorityForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetIncidentPriorityForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetIncidentPriorityForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetIncidentPriorityForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetIncidentPriorityForViewDto {
    totalCount: number | undefined;
    items: GetIncidentPriorityForViewDto[] | undefined;
}

export class GetIncidentPriorityForViewDto implements IGetIncidentPriorityForViewDto {
    incidentPriority!: IncidentPriorityDto | undefined;

    constructor(data?: IGetIncidentPriorityForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.incidentPriority = data["incidentPriority"] ? IncidentPriorityDto.fromJS(data["incidentPriority"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetIncidentPriorityForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetIncidentPriorityForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["incidentPriority"] = this.incidentPriority ? this.incidentPriority.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetIncidentPriorityForViewDto {
    incidentPriority: IncidentPriorityDto | undefined;
}

export class IncidentPriorityDto implements IIncidentPriorityDto {
    priority!: string | undefined;
    description!: string | undefined;
    priorityLevel!: number | undefined;
    id!: number | undefined;

    constructor(data?: IIncidentPriorityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.priority = data["priority"];
            this.description = data["description"];
            this.priorityLevel = data["priorityLevel"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): IncidentPriorityDto {
        data = typeof data === 'object' ? data : {};
        let result = new IncidentPriorityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["priority"] = this.priority;
        data["description"] = this.description;
        data["priorityLevel"] = this.priorityLevel;
        data["id"] = this.id;
        return data; 
    }
}

export interface IIncidentPriorityDto {
    priority: string | undefined;
    description: string | undefined;
    priorityLevel: number | undefined;
    id: number | undefined;
}

export class GetIncidentPriorityForEditOutput implements IGetIncidentPriorityForEditOutput {
    incidentPriority!: CreateOrEditIncidentPriorityDto | undefined;

    constructor(data?: IGetIncidentPriorityForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.incidentPriority = data["incidentPriority"] ? CreateOrEditIncidentPriorityDto.fromJS(data["incidentPriority"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetIncidentPriorityForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetIncidentPriorityForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["incidentPriority"] = this.incidentPriority ? this.incidentPriority.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetIncidentPriorityForEditOutput {
    incidentPriority: CreateOrEditIncidentPriorityDto | undefined;
}

export class CreateOrEditIncidentPriorityDto implements ICreateOrEditIncidentPriorityDto {
    priority!: string;
    description!: string;
    priorityLevel!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditIncidentPriorityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.priority = data["priority"];
            this.description = data["description"];
            this.priorityLevel = data["priorityLevel"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditIncidentPriorityDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditIncidentPriorityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["priority"] = this.priority;
        data["description"] = this.description;
        data["priorityLevel"] = this.priorityLevel;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditIncidentPriorityDto {
    priority: string;
    description: string;
    priorityLevel: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfGetIncidentForViewDto implements IPagedResultDtoOfGetIncidentForViewDto {
    totalCount!: number | undefined;
    items!: GetIncidentForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetIncidentForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetIncidentForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetIncidentForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetIncidentForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetIncidentForViewDto {
    totalCount: number | undefined;
    items: GetIncidentForViewDto[] | undefined;
}

export class GetIncidentForViewDto implements IGetIncidentForViewDto {
    incident!: IncidentDto | undefined;
    incidentPriorityPriority!: string | undefined;
    incidentStatusStatus!: string | undefined;
    customerName!: string | undefined;
    assetReference!: string | undefined;
    supportItemDescription!: string | undefined;
    incidentTypeType!: string | undefined;
    userName!: string | undefined;
    incidentUpdates!: PagedResultDtoOfGetIncidentUpdateForViewDto | undefined;

    constructor(data?: IGetIncidentForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.incident = data["incident"] ? IncidentDto.fromJS(data["incident"]) : <any>undefined;
            this.incidentPriorityPriority = data["incidentPriorityPriority"];
            this.incidentStatusStatus = data["incidentStatusStatus"];
            this.customerName = data["customerName"];
            this.assetReference = data["assetReference"];
            this.supportItemDescription = data["supportItemDescription"];
            this.incidentTypeType = data["incidentTypeType"];
            this.userName = data["userName"];
            this.incidentUpdates = data["incidentUpdates"] ? PagedResultDtoOfGetIncidentUpdateForViewDto.fromJS(data["incidentUpdates"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetIncidentForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetIncidentForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["incident"] = this.incident ? this.incident.toJSON() : <any>undefined;
        data["incidentPriorityPriority"] = this.incidentPriorityPriority;
        data["incidentStatusStatus"] = this.incidentStatusStatus;
        data["customerName"] = this.customerName;
        data["assetReference"] = this.assetReference;
        data["supportItemDescription"] = this.supportItemDescription;
        data["incidentTypeType"] = this.incidentTypeType;
        data["userName"] = this.userName;
        data["incidentUpdates"] = this.incidentUpdates ? this.incidentUpdates.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetIncidentForViewDto {
    incident: IncidentDto | undefined;
    incidentPriorityPriority: string | undefined;
    incidentStatusStatus: string | undefined;
    customerName: string | undefined;
    assetReference: string | undefined;
    supportItemDescription: string | undefined;
    incidentTypeType: string | undefined;
    userName: string | undefined;
    incidentUpdates: PagedResultDtoOfGetIncidentUpdateForViewDto | undefined;
}

export class IncidentDto implements IIncidentDto {
    description!: string | undefined;
    incidentDate!: moment.Moment | undefined;
    location!: string | undefined;
    remarks!: string | undefined;
    resolvedAt!: moment.Moment | undefined;
    incidentPriorityId!: number | undefined;
    incidentStatusId!: number | undefined;
    customerId!: number | undefined;
    assetId!: number | undefined;
    supportItemId!: number | undefined;
    incidentTypeId!: number | undefined;
    userId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IIncidentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.description = data["description"];
            this.incidentDate = data["incidentDate"] ? moment(data["incidentDate"].toString()) : <any>undefined;
            this.location = data["location"];
            this.remarks = data["remarks"];
            this.resolvedAt = data["resolvedAt"] ? moment(data["resolvedAt"].toString()) : <any>undefined;
            this.incidentPriorityId = data["incidentPriorityId"];
            this.incidentStatusId = data["incidentStatusId"];
            this.customerId = data["customerId"];
            this.assetId = data["assetId"];
            this.supportItemId = data["supportItemId"];
            this.incidentTypeId = data["incidentTypeId"];
            this.userId = data["userId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): IncidentDto {
        data = typeof data === 'object' ? data : {};
        let result = new IncidentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["incidentDate"] = this.incidentDate ? this.incidentDate.toISOString() : <any>undefined;
        data["location"] = this.location;
        data["remarks"] = this.remarks;
        data["resolvedAt"] = this.resolvedAt ? this.resolvedAt.toISOString() : <any>undefined;
        data["incidentPriorityId"] = this.incidentPriorityId;
        data["incidentStatusId"] = this.incidentStatusId;
        data["customerId"] = this.customerId;
        data["assetId"] = this.assetId;
        data["supportItemId"] = this.supportItemId;
        data["incidentTypeId"] = this.incidentTypeId;
        data["userId"] = this.userId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IIncidentDto {
    description: string | undefined;
    incidentDate: moment.Moment | undefined;
    location: string | undefined;
    remarks: string | undefined;
    resolvedAt: moment.Moment | undefined;
    incidentPriorityId: number | undefined;
    incidentStatusId: number | undefined;
    customerId: number | undefined;
    assetId: number | undefined;
    supportItemId: number | undefined;
    incidentTypeId: number | undefined;
    userId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfGetIncidentUpdateForViewDto implements IPagedResultDtoOfGetIncidentUpdateForViewDto {
    totalCount!: number | undefined;
    items!: GetIncidentUpdateForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetIncidentUpdateForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetIncidentUpdateForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetIncidentUpdateForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetIncidentUpdateForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetIncidentUpdateForViewDto {
    totalCount: number | undefined;
    items: GetIncidentUpdateForViewDto[] | undefined;
}

export class GetIncidentUpdateForViewDto implements IGetIncidentUpdateForViewDto {
    incidentUpdate!: IncidentUpdateDto | undefined;
    userName!: string | undefined;
    incidentDescription!: string | undefined;

    constructor(data?: IGetIncidentUpdateForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.incidentUpdate = data["incidentUpdate"] ? IncidentUpdateDto.fromJS(data["incidentUpdate"]) : <any>undefined;
            this.userName = data["userName"];
            this.incidentDescription = data["incidentDescription"];
        }
    }

    static fromJS(data: any): GetIncidentUpdateForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetIncidentUpdateForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["incidentUpdate"] = this.incidentUpdate ? this.incidentUpdate.toJSON() : <any>undefined;
        data["userName"] = this.userName;
        data["incidentDescription"] = this.incidentDescription;
        return data; 
    }
}

export interface IGetIncidentUpdateForViewDto {
    incidentUpdate: IncidentUpdateDto | undefined;
    userName: string | undefined;
    incidentDescription: string | undefined;
}

export class IncidentUpdateDto implements IIncidentUpdateDto {
    updated!: moment.Moment | undefined;
    update!: string | undefined;
    userId!: number | undefined;
    incidentId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IIncidentUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.updated = data["updated"] ? moment(data["updated"].toString()) : <any>undefined;
            this.update = data["update"];
            this.userId = data["userId"];
            this.incidentId = data["incidentId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): IncidentUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new IncidentUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
        data["update"] = this.update;
        data["userId"] = this.userId;
        data["incidentId"] = this.incidentId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IIncidentUpdateDto {
    updated: moment.Moment | undefined;
    update: string | undefined;
    userId: number | undefined;
    incidentId: number | undefined;
    id: number | undefined;
}

export class GetIncidentForEditOutput implements IGetIncidentForEditOutput {
    incident!: CreateOrEditIncidentDto | undefined;
    incidentPriorityPriority!: string | undefined;
    incidentStatusStatus!: string | undefined;
    customerName!: string | undefined;
    assetReference!: string | undefined;
    supportItemDescription!: string | undefined;
    incidentTypeType!: string | undefined;
    userName!: string | undefined;
    tenantType!: string | undefined;

    constructor(data?: IGetIncidentForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.incident = data["incident"] ? CreateOrEditIncidentDto.fromJS(data["incident"]) : <any>undefined;
            this.incidentPriorityPriority = data["incidentPriorityPriority"];
            this.incidentStatusStatus = data["incidentStatusStatus"];
            this.customerName = data["customerName"];
            this.assetReference = data["assetReference"];
            this.supportItemDescription = data["supportItemDescription"];
            this.incidentTypeType = data["incidentTypeType"];
            this.userName = data["userName"];
            this.tenantType = data["tenantType"];
        }
    }

    static fromJS(data: any): GetIncidentForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetIncidentForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["incident"] = this.incident ? this.incident.toJSON() : <any>undefined;
        data["incidentPriorityPriority"] = this.incidentPriorityPriority;
        data["incidentStatusStatus"] = this.incidentStatusStatus;
        data["customerName"] = this.customerName;
        data["assetReference"] = this.assetReference;
        data["supportItemDescription"] = this.supportItemDescription;
        data["incidentTypeType"] = this.incidentTypeType;
        data["userName"] = this.userName;
        data["tenantType"] = this.tenantType;
        return data; 
    }
}

export interface IGetIncidentForEditOutput {
    incident: CreateOrEditIncidentDto | undefined;
    incidentPriorityPriority: string | undefined;
    incidentStatusStatus: string | undefined;
    customerName: string | undefined;
    assetReference: string | undefined;
    supportItemDescription: string | undefined;
    incidentTypeType: string | undefined;
    userName: string | undefined;
    tenantType: string | undefined;
}

export class CreateOrEditIncidentDto implements ICreateOrEditIncidentDto {
    description!: string;
    incidentDate!: moment.Moment | undefined;
    location!: string;
    remarks!: string | undefined;
    resolvedAt!: moment.Moment | undefined;
    incidentPriorityId!: number | undefined;
    incidentStatusId!: number | undefined;
    customerId!: number | undefined;
    assetId!: number | undefined;
    supportItemId!: number | undefined;
    incidentTypeId!: number | undefined;
    userId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditIncidentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.description = data["description"];
            this.incidentDate = data["incidentDate"] ? moment(data["incidentDate"].toString()) : <any>undefined;
            this.location = data["location"];
            this.remarks = data["remarks"];
            this.resolvedAt = data["resolvedAt"] ? moment(data["resolvedAt"].toString()) : <any>undefined;
            this.incidentPriorityId = data["incidentPriorityId"];
            this.incidentStatusId = data["incidentStatusId"];
            this.customerId = data["customerId"];
            this.assetId = data["assetId"];
            this.supportItemId = data["supportItemId"];
            this.incidentTypeId = data["incidentTypeId"];
            this.userId = data["userId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditIncidentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditIncidentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["incidentDate"] = this.incidentDate ? this.incidentDate.toISOString() : <any>undefined;
        data["location"] = this.location;
        data["remarks"] = this.remarks;
        data["resolvedAt"] = this.resolvedAt ? this.resolvedAt.toISOString() : <any>undefined;
        data["incidentPriorityId"] = this.incidentPriorityId;
        data["incidentStatusId"] = this.incidentStatusId;
        data["customerId"] = this.customerId;
        data["assetId"] = this.assetId;
        data["supportItemId"] = this.supportItemId;
        data["incidentTypeId"] = this.incidentTypeId;
        data["userId"] = this.userId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditIncidentDto {
    description: string;
    incidentDate: moment.Moment | undefined;
    location: string;
    remarks: string | undefined;
    resolvedAt: moment.Moment | undefined;
    incidentPriorityId: number | undefined;
    incidentStatusId: number | undefined;
    customerId: number | undefined;
    assetId: number | undefined;
    supportItemId: number | undefined;
    incidentTypeId: number | undefined;
    userId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfIncidentIncidentPriorityLookupTableDto implements IPagedResultDtoOfIncidentIncidentPriorityLookupTableDto {
    totalCount!: number | undefined;
    items!: IncidentIncidentPriorityLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfIncidentIncidentPriorityLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(IncidentIncidentPriorityLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfIncidentIncidentPriorityLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfIncidentIncidentPriorityLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfIncidentIncidentPriorityLookupTableDto {
    totalCount: number | undefined;
    items: IncidentIncidentPriorityLookupTableDto[] | undefined;
}

export class IncidentIncidentPriorityLookupTableDto implements IIncidentIncidentPriorityLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IIncidentIncidentPriorityLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): IncidentIncidentPriorityLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new IncidentIncidentPriorityLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IIncidentIncidentPriorityLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfIncidentIncidentStatusLookupTableDto implements IPagedResultDtoOfIncidentIncidentStatusLookupTableDto {
    totalCount!: number | undefined;
    items!: IncidentIncidentStatusLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfIncidentIncidentStatusLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(IncidentIncidentStatusLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfIncidentIncidentStatusLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfIncidentIncidentStatusLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfIncidentIncidentStatusLookupTableDto {
    totalCount: number | undefined;
    items: IncidentIncidentStatusLookupTableDto[] | undefined;
}

export class IncidentIncidentStatusLookupTableDto implements IIncidentIncidentStatusLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IIncidentIncidentStatusLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): IncidentIncidentStatusLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new IncidentIncidentStatusLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IIncidentIncidentStatusLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfIncidentCustomerLookupTableDto implements IPagedResultDtoOfIncidentCustomerLookupTableDto {
    totalCount!: number | undefined;
    items!: IncidentCustomerLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfIncidentCustomerLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(IncidentCustomerLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfIncidentCustomerLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfIncidentCustomerLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfIncidentCustomerLookupTableDto {
    totalCount: number | undefined;
    items: IncidentCustomerLookupTableDto[] | undefined;
}

export class IncidentCustomerLookupTableDto implements IIncidentCustomerLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IIncidentCustomerLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): IncidentCustomerLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new IncidentCustomerLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IIncidentCustomerLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfIncidentAssetLookupTableDto implements IPagedResultDtoOfIncidentAssetLookupTableDto {
    totalCount!: number | undefined;
    items!: IncidentAssetLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfIncidentAssetLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(IncidentAssetLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfIncidentAssetLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfIncidentAssetLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfIncidentAssetLookupTableDto {
    totalCount: number | undefined;
    items: IncidentAssetLookupTableDto[] | undefined;
}

export class IncidentAssetLookupTableDto implements IIncidentAssetLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IIncidentAssetLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): IncidentAssetLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new IncidentAssetLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IIncidentAssetLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfIncidentSupportItemLookupTableDto implements IPagedResultDtoOfIncidentSupportItemLookupTableDto {
    totalCount!: number | undefined;
    items!: IncidentSupportItemLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfIncidentSupportItemLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(IncidentSupportItemLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfIncidentSupportItemLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfIncidentSupportItemLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfIncidentSupportItemLookupTableDto {
    totalCount: number | undefined;
    items: IncidentSupportItemLookupTableDto[] | undefined;
}

export class IncidentSupportItemLookupTableDto implements IIncidentSupportItemLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IIncidentSupportItemLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): IncidentSupportItemLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new IncidentSupportItemLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IIncidentSupportItemLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfIncidentIncidentTypeLookupTableDto implements IPagedResultDtoOfIncidentIncidentTypeLookupTableDto {
    totalCount!: number | undefined;
    items!: IncidentIncidentTypeLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfIncidentIncidentTypeLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(IncidentIncidentTypeLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfIncidentIncidentTypeLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfIncidentIncidentTypeLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfIncidentIncidentTypeLookupTableDto {
    totalCount: number | undefined;
    items: IncidentIncidentTypeLookupTableDto[] | undefined;
}

export class IncidentIncidentTypeLookupTableDto implements IIncidentIncidentTypeLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IIncidentIncidentTypeLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): IncidentIncidentTypeLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new IncidentIncidentTypeLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IIncidentIncidentTypeLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfIncidentUserLookupTableDto implements IPagedResultDtoOfIncidentUserLookupTableDto {
    totalCount!: number | undefined;
    items!: IncidentUserLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfIncidentUserLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(IncidentUserLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfIncidentUserLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfIncidentUserLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfIncidentUserLookupTableDto {
    totalCount: number | undefined;
    items: IncidentUserLookupTableDto[] | undefined;
}

export class IncidentUserLookupTableDto implements IIncidentUserLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IIncidentUserLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): IncidentUserLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new IncidentUserLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IIncidentUserLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class IncidentSupportItemAndCustomerListDto implements IIncidentSupportItemAndCustomerListDto {
    customerList!: IncidentCustomerLookupTableDto[] | undefined;
    supportItemList!: IncidentSupportItemLookupTableDto[] | undefined;

    constructor(data?: IIncidentSupportItemAndCustomerListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["customerList"])) {
                this.customerList = [] as any;
                for (let item of data["customerList"])
                    this.customerList!.push(IncidentCustomerLookupTableDto.fromJS(item));
            }
            if (Array.isArray(data["supportItemList"])) {
                this.supportItemList = [] as any;
                for (let item of data["supportItemList"])
                    this.supportItemList!.push(IncidentSupportItemLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): IncidentSupportItemAndCustomerListDto {
        data = typeof data === 'object' ? data : {};
        let result = new IncidentSupportItemAndCustomerListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.customerList)) {
            data["customerList"] = [];
            for (let item of this.customerList)
                data["customerList"].push(item.toJSON());
        }
        if (Array.isArray(this.supportItemList)) {
            data["supportItemList"] = [];
            for (let item of this.supportItemList)
                data["supportItemList"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IIncidentSupportItemAndCustomerListDto {
    customerList: IncidentCustomerLookupTableDto[] | undefined;
    supportItemList: IncidentSupportItemLookupTableDto[] | undefined;
}

export class PagedResultDtoOfGetIncidentStatusForViewDto implements IPagedResultDtoOfGetIncidentStatusForViewDto {
    totalCount!: number | undefined;
    items!: GetIncidentStatusForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetIncidentStatusForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetIncidentStatusForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetIncidentStatusForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetIncidentStatusForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetIncidentStatusForViewDto {
    totalCount: number | undefined;
    items: GetIncidentStatusForViewDto[] | undefined;
}

export class GetIncidentStatusForViewDto implements IGetIncidentStatusForViewDto {
    incidentStatus!: IncidentStatusDto | undefined;

    constructor(data?: IGetIncidentStatusForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.incidentStatus = data["incidentStatus"] ? IncidentStatusDto.fromJS(data["incidentStatus"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetIncidentStatusForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetIncidentStatusForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["incidentStatus"] = this.incidentStatus ? this.incidentStatus.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetIncidentStatusForViewDto {
    incidentStatus: IncidentStatusDto | undefined;
}

export class IncidentStatusDto implements IIncidentStatusDto {
    status!: string | undefined;
    description!: string | undefined;
    id!: number | undefined;

    constructor(data?: IIncidentStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"];
            this.description = data["description"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): IncidentStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new IncidentStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }
}

export interface IIncidentStatusDto {
    status: string | undefined;
    description: string | undefined;
    id: number | undefined;
}

export class GetIncidentStatusForEditOutput implements IGetIncidentStatusForEditOutput {
    incidentStatus!: CreateOrEditIncidentStatusDto | undefined;

    constructor(data?: IGetIncidentStatusForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.incidentStatus = data["incidentStatus"] ? CreateOrEditIncidentStatusDto.fromJS(data["incidentStatus"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetIncidentStatusForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetIncidentStatusForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["incidentStatus"] = this.incidentStatus ? this.incidentStatus.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetIncidentStatusForEditOutput {
    incidentStatus: CreateOrEditIncidentStatusDto | undefined;
}

export class CreateOrEditIncidentStatusDto implements ICreateOrEditIncidentStatusDto {
    status!: string;
    description!: string;
    id!: number | undefined;

    constructor(data?: ICreateOrEditIncidentStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"];
            this.description = data["description"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditIncidentStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditIncidentStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditIncidentStatusDto {
    status: string;
    description: string;
    id: number | undefined;
}

export class PagedResultDtoOfGetIncidentTypeForViewDto implements IPagedResultDtoOfGetIncidentTypeForViewDto {
    totalCount!: number | undefined;
    items!: GetIncidentTypeForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetIncidentTypeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetIncidentTypeForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetIncidentTypeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetIncidentTypeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetIncidentTypeForViewDto {
    totalCount: number | undefined;
    items: GetIncidentTypeForViewDto[] | undefined;
}

export class GetIncidentTypeForViewDto implements IGetIncidentTypeForViewDto {
    incidentType!: IncidentTypeDto | undefined;

    constructor(data?: IGetIncidentTypeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.incidentType = data["incidentType"] ? IncidentTypeDto.fromJS(data["incidentType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetIncidentTypeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetIncidentTypeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["incidentType"] = this.incidentType ? this.incidentType.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetIncidentTypeForViewDto {
    incidentType: IncidentTypeDto | undefined;
}

export class IncidentTypeDto implements IIncidentTypeDto {
    type!: string | undefined;
    description!: string | undefined;
    id!: number | undefined;

    constructor(data?: IIncidentTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.type = data["type"];
            this.description = data["description"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): IncidentTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new IncidentTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }
}

export interface IIncidentTypeDto {
    type: string | undefined;
    description: string | undefined;
    id: number | undefined;
}

export class GetIncidentTypeForEditOutput implements IGetIncidentTypeForEditOutput {
    incidentType!: CreateOrEditIncidentTypeDto | undefined;

    constructor(data?: IGetIncidentTypeForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.incidentType = data["incidentType"] ? CreateOrEditIncidentTypeDto.fromJS(data["incidentType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetIncidentTypeForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetIncidentTypeForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["incidentType"] = this.incidentType ? this.incidentType.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetIncidentTypeForEditOutput {
    incidentType: CreateOrEditIncidentTypeDto | undefined;
}

export class CreateOrEditIncidentTypeDto implements ICreateOrEditIncidentTypeDto {
    type!: string;
    description!: string;
    id!: number | undefined;

    constructor(data?: ICreateOrEditIncidentTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.type = data["type"];
            this.description = data["description"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditIncidentTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditIncidentTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditIncidentTypeDto {
    type: string;
    description: string;
    id: number | undefined;
}

export class GetIncidentUpdateForEditOutput implements IGetIncidentUpdateForEditOutput {
    incidentUpdate!: CreateOrEditIncidentUpdateDto | undefined;
    userName!: string | undefined;
    incidentDescription!: string | undefined;

    constructor(data?: IGetIncidentUpdateForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.incidentUpdate = data["incidentUpdate"] ? CreateOrEditIncidentUpdateDto.fromJS(data["incidentUpdate"]) : <any>undefined;
            this.userName = data["userName"];
            this.incidentDescription = data["incidentDescription"];
        }
    }

    static fromJS(data: any): GetIncidentUpdateForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetIncidentUpdateForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["incidentUpdate"] = this.incidentUpdate ? this.incidentUpdate.toJSON() : <any>undefined;
        data["userName"] = this.userName;
        data["incidentDescription"] = this.incidentDescription;
        return data; 
    }
}

export interface IGetIncidentUpdateForEditOutput {
    incidentUpdate: CreateOrEditIncidentUpdateDto | undefined;
    userName: string | undefined;
    incidentDescription: string | undefined;
}

export class CreateOrEditIncidentUpdateDto implements ICreateOrEditIncidentUpdateDto {
    updated!: moment.Moment | undefined;
    update!: string | undefined;
    userId!: number | undefined;
    incidentId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditIncidentUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.updated = data["updated"] ? moment(data["updated"].toString()) : <any>undefined;
            this.update = data["update"];
            this.userId = data["userId"];
            this.incidentId = data["incidentId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditIncidentUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditIncidentUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["updated"] = this.updated ? this.updated.toISOString() : <any>undefined;
        data["update"] = this.update;
        data["userId"] = this.userId;
        data["incidentId"] = this.incidentId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditIncidentUpdateDto {
    updated: moment.Moment | undefined;
    update: string | undefined;
    userId: number | undefined;
    incidentId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfIncidentUpdateUserLookupTableDto implements IPagedResultDtoOfIncidentUpdateUserLookupTableDto {
    totalCount!: number | undefined;
    items!: IncidentUpdateUserLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfIncidentUpdateUserLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(IncidentUpdateUserLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfIncidentUpdateUserLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfIncidentUpdateUserLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfIncidentUpdateUserLookupTableDto {
    totalCount: number | undefined;
    items: IncidentUpdateUserLookupTableDto[] | undefined;
}

export class IncidentUpdateUserLookupTableDto implements IIncidentUpdateUserLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IIncidentUpdateUserLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): IncidentUpdateUserLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new IncidentUpdateUserLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IIncidentUpdateUserLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfIncidentUpdateIncidentLookupTableDto implements IPagedResultDtoOfIncidentUpdateIncidentLookupTableDto {
    totalCount!: number | undefined;
    items!: IncidentUpdateIncidentLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfIncidentUpdateIncidentLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(IncidentUpdateIncidentLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfIncidentUpdateIncidentLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfIncidentUpdateIncidentLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfIncidentUpdateIncidentLookupTableDto {
    totalCount: number | undefined;
    items: IncidentUpdateIncidentLookupTableDto[] | undefined;
}

export class IncidentUpdateIncidentLookupTableDto implements IIncidentUpdateIncidentLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IIncidentUpdateIncidentLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): IncidentUpdateIncidentLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new IncidentUpdateIncidentLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IIncidentUpdateIncidentLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class InstallDto implements IInstallDto {
    connectionString!: string;
    adminPassword!: string;
    webSiteUrl!: string;
    serverUrl!: string | undefined;
    defaultLanguage!: string;
    smtpSettings!: EmailSettingsEditDto | undefined;
    billInfo!: HostBillingSettingsEditDto | undefined;

    constructor(data?: IInstallDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.connectionString = data["connectionString"];
            this.adminPassword = data["adminPassword"];
            this.webSiteUrl = data["webSiteUrl"];
            this.serverUrl = data["serverUrl"];
            this.defaultLanguage = data["defaultLanguage"];
            this.smtpSettings = data["smtpSettings"] ? EmailSettingsEditDto.fromJS(data["smtpSettings"]) : <any>undefined;
            this.billInfo = data["billInfo"] ? HostBillingSettingsEditDto.fromJS(data["billInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): InstallDto {
        data = typeof data === 'object' ? data : {};
        let result = new InstallDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["connectionString"] = this.connectionString;
        data["adminPassword"] = this.adminPassword;
        data["webSiteUrl"] = this.webSiteUrl;
        data["serverUrl"] = this.serverUrl;
        data["defaultLanguage"] = this.defaultLanguage;
        data["smtpSettings"] = this.smtpSettings ? this.smtpSettings.toJSON() : <any>undefined;
        data["billInfo"] = this.billInfo ? this.billInfo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IInstallDto {
    connectionString: string;
    adminPassword: string;
    webSiteUrl: string;
    serverUrl: string | undefined;
    defaultLanguage: string;
    smtpSettings: EmailSettingsEditDto | undefined;
    billInfo: HostBillingSettingsEditDto | undefined;
}

export class AppSettingsJsonDto implements IAppSettingsJsonDto {
    webSiteUrl!: string | undefined;
    serverSiteUrl!: string | undefined;
    languages!: NameValue[] | undefined;

    constructor(data?: IAppSettingsJsonDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.webSiteUrl = data["webSiteUrl"];
            this.serverSiteUrl = data["serverSiteUrl"];
            if (Array.isArray(data["languages"])) {
                this.languages = [] as any;
                for (let item of data["languages"])
                    this.languages!.push(NameValue.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AppSettingsJsonDto {
        data = typeof data === 'object' ? data : {};
        let result = new AppSettingsJsonDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["webSiteUrl"] = this.webSiteUrl;
        data["serverSiteUrl"] = this.serverSiteUrl;
        if (Array.isArray(this.languages)) {
            data["languages"] = [];
            for (let item of this.languages)
                data["languages"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAppSettingsJsonDto {
    webSiteUrl: string | undefined;
    serverSiteUrl: string | undefined;
    languages: NameValue[] | undefined;
}

export class NameValue implements INameValue {
    name!: string | undefined;
    value!: string | undefined;

    constructor(data?: INameValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): NameValue {
        data = typeof data === 'object' ? data : {};
        let result = new NameValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }
}

export interface INameValue {
    name: string | undefined;
    value: string | undefined;
}

export class CheckDatabaseOutput implements ICheckDatabaseOutput {
    isDatabaseExist!: boolean | undefined;

    constructor(data?: ICheckDatabaseOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isDatabaseExist = data["isDatabaseExist"];
        }
    }

    static fromJS(data: any): CheckDatabaseOutput {
        data = typeof data === 'object' ? data : {};
        let result = new CheckDatabaseOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isDatabaseExist"] = this.isDatabaseExist;
        return data; 
    }
}

export interface ICheckDatabaseOutput {
    isDatabaseExist: boolean | undefined;
}

export class PagedResultDtoOfGetInventoryItemForViewDto implements IPagedResultDtoOfGetInventoryItemForViewDto {
    totalCount!: number | undefined;
    items!: GetInventoryItemForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetInventoryItemForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetInventoryItemForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetInventoryItemForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetInventoryItemForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetInventoryItemForViewDto {
    totalCount: number | undefined;
    items: GetInventoryItemForViewDto[] | undefined;
}

export class GetInventoryItemForViewDto implements IGetInventoryItemForViewDto {
    inventoryItem!: InventoryItemDto | undefined;
    itemTypeType!: string | undefined;
    assetReference!: string | undefined;
    warehouseName!: string | undefined;

    constructor(data?: IGetInventoryItemForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.inventoryItem = data["inventoryItem"] ? InventoryItemDto.fromJS(data["inventoryItem"]) : <any>undefined;
            this.itemTypeType = data["itemTypeType"];
            this.assetReference = data["assetReference"];
            this.warehouseName = data["warehouseName"];
        }
    }

    static fromJS(data: any): GetInventoryItemForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetInventoryItemForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["inventoryItem"] = this.inventoryItem ? this.inventoryItem.toJSON() : <any>undefined;
        data["itemTypeType"] = this.itemTypeType;
        data["assetReference"] = this.assetReference;
        data["warehouseName"] = this.warehouseName;
        return data; 
    }
}

export interface IGetInventoryItemForViewDto {
    inventoryItem: InventoryItemDto | undefined;
    itemTypeType: string | undefined;
    assetReference: string | undefined;
    warehouseName: string | undefined;
}

export class InventoryItemDto implements IInventoryItemDto {
    name!: string | undefined;
    reference!: string | undefined;
    qtyInWarehouse!: number | undefined;
    qtyInAssets!: number | undefined;
    restockLimit!: number | undefined;
    qtyOnOrder!: number | undefined;
    itemTypeId!: number | undefined;
    assetId!: number | undefined;
    warehouseId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IInventoryItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.reference = data["reference"];
            this.qtyInWarehouse = data["qtyInWarehouse"];
            this.qtyInAssets = data["qtyInAssets"];
            this.restockLimit = data["restockLimit"];
            this.qtyOnOrder = data["qtyOnOrder"];
            this.itemTypeId = data["itemTypeId"];
            this.assetId = data["assetId"];
            this.warehouseId = data["warehouseId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): InventoryItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new InventoryItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["reference"] = this.reference;
        data["qtyInWarehouse"] = this.qtyInWarehouse;
        data["qtyInAssets"] = this.qtyInAssets;
        data["restockLimit"] = this.restockLimit;
        data["qtyOnOrder"] = this.qtyOnOrder;
        data["itemTypeId"] = this.itemTypeId;
        data["assetId"] = this.assetId;
        data["warehouseId"] = this.warehouseId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IInventoryItemDto {
    name: string | undefined;
    reference: string | undefined;
    qtyInWarehouse: number | undefined;
    qtyInAssets: number | undefined;
    restockLimit: number | undefined;
    qtyOnOrder: number | undefined;
    itemTypeId: number | undefined;
    assetId: number | undefined;
    warehouseId: number | undefined;
    id: number | undefined;
}

export class GetInventoryItemForEditOutput implements IGetInventoryItemForEditOutput {
    inventoryItem!: CreateOrEditInventoryItemDto | undefined;
    itemTypeType!: string | undefined;
    assetReference!: string | undefined;
    warehouseName!: string | undefined;

    constructor(data?: IGetInventoryItemForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.inventoryItem = data["inventoryItem"] ? CreateOrEditInventoryItemDto.fromJS(data["inventoryItem"]) : <any>undefined;
            this.itemTypeType = data["itemTypeType"];
            this.assetReference = data["assetReference"];
            this.warehouseName = data["warehouseName"];
        }
    }

    static fromJS(data: any): GetInventoryItemForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetInventoryItemForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["inventoryItem"] = this.inventoryItem ? this.inventoryItem.toJSON() : <any>undefined;
        data["itemTypeType"] = this.itemTypeType;
        data["assetReference"] = this.assetReference;
        data["warehouseName"] = this.warehouseName;
        return data; 
    }
}

export interface IGetInventoryItemForEditOutput {
    inventoryItem: CreateOrEditInventoryItemDto | undefined;
    itemTypeType: string | undefined;
    assetReference: string | undefined;
    warehouseName: string | undefined;
}

export class CreateOrEditInventoryItemDto implements ICreateOrEditInventoryItemDto {
    name!: string;
    reference!: string | undefined;
    qtyInWarehouse!: number | undefined;
    restockLimit!: number | undefined;
    qtyOnOrder!: number | undefined;
    itemTypeId!: number | undefined;
    assetId!: number | undefined;
    warehouseId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditInventoryItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.reference = data["reference"];
            this.qtyInWarehouse = data["qtyInWarehouse"];
            this.restockLimit = data["restockLimit"];
            this.qtyOnOrder = data["qtyOnOrder"];
            this.itemTypeId = data["itemTypeId"];
            this.assetId = data["assetId"];
            this.warehouseId = data["warehouseId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditInventoryItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditInventoryItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["reference"] = this.reference;
        data["qtyInWarehouse"] = this.qtyInWarehouse;
        data["restockLimit"] = this.restockLimit;
        data["qtyOnOrder"] = this.qtyOnOrder;
        data["itemTypeId"] = this.itemTypeId;
        data["assetId"] = this.assetId;
        data["warehouseId"] = this.warehouseId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditInventoryItemDto {
    name: string;
    reference: string | undefined;
    qtyInWarehouse: number | undefined;
    restockLimit: number | undefined;
    qtyOnOrder: number | undefined;
    itemTypeId: number | undefined;
    assetId: number | undefined;
    warehouseId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfInventoryItemItemTypeLookupTableDto implements IPagedResultDtoOfInventoryItemItemTypeLookupTableDto {
    totalCount!: number | undefined;
    items!: InventoryItemItemTypeLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfInventoryItemItemTypeLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(InventoryItemItemTypeLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfInventoryItemItemTypeLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfInventoryItemItemTypeLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfInventoryItemItemTypeLookupTableDto {
    totalCount: number | undefined;
    items: InventoryItemItemTypeLookupTableDto[] | undefined;
}

export class InventoryItemItemTypeLookupTableDto implements IInventoryItemItemTypeLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IInventoryItemItemTypeLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): InventoryItemItemTypeLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new InventoryItemItemTypeLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IInventoryItemItemTypeLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfInventoryItemAssetLookupTableDto implements IPagedResultDtoOfInventoryItemAssetLookupTableDto {
    totalCount!: number | undefined;
    items!: InventoryItemAssetLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfInventoryItemAssetLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(InventoryItemAssetLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfInventoryItemAssetLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfInventoryItemAssetLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfInventoryItemAssetLookupTableDto {
    totalCount: number | undefined;
    items: InventoryItemAssetLookupTableDto[] | undefined;
}

export class InventoryItemAssetLookupTableDto implements IInventoryItemAssetLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IInventoryItemAssetLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): InventoryItemAssetLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new InventoryItemAssetLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IInventoryItemAssetLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfInventoryItemWarehouseLookupTableDto implements IPagedResultDtoOfInventoryItemWarehouseLookupTableDto {
    totalCount!: number | undefined;
    items!: InventoryItemWarehouseLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfInventoryItemWarehouseLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(InventoryItemWarehouseLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfInventoryItemWarehouseLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfInventoryItemWarehouseLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfInventoryItemWarehouseLookupTableDto {
    totalCount: number | undefined;
    items: InventoryItemWarehouseLookupTableDto[] | undefined;
}

export class InventoryItemWarehouseLookupTableDto implements IInventoryItemWarehouseLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IInventoryItemWarehouseLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): InventoryItemWarehouseLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new InventoryItemWarehouseLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IInventoryItemWarehouseLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class InvoiceDto implements IInvoiceDto {
    amount!: number | undefined;
    editionDisplayName!: string | undefined;
    invoiceNo!: string | undefined;
    invoiceDate!: moment.Moment | undefined;
    tenantLegalName!: string | undefined;
    tenantAddress!: string[] | undefined;
    tenantTaxNo!: string | undefined;
    hostLegalName!: string | undefined;
    hostAddress!: string[] | undefined;
    assetOwner!: AssetOwner | undefined;

    constructor(data?: IInvoiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.amount = data["amount"];
            this.editionDisplayName = data["editionDisplayName"];
            this.invoiceNo = data["invoiceNo"];
            this.invoiceDate = data["invoiceDate"] ? moment(data["invoiceDate"].toString()) : <any>undefined;
            this.tenantLegalName = data["tenantLegalName"];
            if (Array.isArray(data["tenantAddress"])) {
                this.tenantAddress = [] as any;
                for (let item of data["tenantAddress"])
                    this.tenantAddress!.push(item);
            }
            this.tenantTaxNo = data["tenantTaxNo"];
            this.hostLegalName = data["hostLegalName"];
            if (Array.isArray(data["hostAddress"])) {
                this.hostAddress = [] as any;
                for (let item of data["hostAddress"])
                    this.hostAddress!.push(item);
            }
            this.assetOwner = data["assetOwner"] ? AssetOwner.fromJS(data["assetOwner"]) : <any>undefined;
        }
    }

    static fromJS(data: any): InvoiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["editionDisplayName"] = this.editionDisplayName;
        data["invoiceNo"] = this.invoiceNo;
        data["invoiceDate"] = this.invoiceDate ? this.invoiceDate.toISOString() : <any>undefined;
        data["tenantLegalName"] = this.tenantLegalName;
        if (Array.isArray(this.tenantAddress)) {
            data["tenantAddress"] = [];
            for (let item of this.tenantAddress)
                data["tenantAddress"].push(item);
        }
        data["tenantTaxNo"] = this.tenantTaxNo;
        data["hostLegalName"] = this.hostLegalName;
        if (Array.isArray(this.hostAddress)) {
            data["hostAddress"] = [];
            for (let item of this.hostAddress)
                data["hostAddress"].push(item);
        }
        data["assetOwner"] = this.assetOwner ? this.assetOwner.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IInvoiceDto {
    amount: number | undefined;
    editionDisplayName: string | undefined;
    invoiceNo: string | undefined;
    invoiceDate: moment.Moment | undefined;
    tenantLegalName: string | undefined;
    tenantAddress: string[] | undefined;
    tenantTaxNo: string | undefined;
    hostLegalName: string | undefined;
    hostAddress: string[] | undefined;
    assetOwner: AssetOwner | undefined;
}

export class AssetOwner implements IAssetOwner {
    tenantId!: number | undefined;
    reference!: string;
    name!: string;
    identifier!: string | undefined;
    logoUrl!: string | undefined;
    website!: string | undefined;
    currencyId!: number | undefined;
    currencyFk!: Currency | undefined;
    ssicCodeId!: number | undefined;
    ssicCodeFk!: SsicCode | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IAssetOwner) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.reference = data["reference"];
            this.name = data["name"];
            this.identifier = data["identifier"];
            this.logoUrl = data["logoUrl"];
            this.website = data["website"];
            this.currencyId = data["currencyId"];
            this.currencyFk = data["currencyFk"] ? Currency.fromJS(data["currencyFk"]) : <any>undefined;
            this.ssicCodeId = data["ssicCodeId"];
            this.ssicCodeFk = data["ssicCodeFk"] ? SsicCode.fromJS(data["ssicCodeFk"]) : <any>undefined;
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): AssetOwner {
        data = typeof data === 'object' ? data : {};
        let result = new AssetOwner();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["reference"] = this.reference;
        data["name"] = this.name;
        data["identifier"] = this.identifier;
        data["logoUrl"] = this.logoUrl;
        data["website"] = this.website;
        data["currencyId"] = this.currencyId;
        data["currencyFk"] = this.currencyFk ? this.currencyFk.toJSON() : <any>undefined;
        data["ssicCodeId"] = this.ssicCodeId;
        data["ssicCodeFk"] = this.ssicCodeFk ? this.ssicCodeFk.toJSON() : <any>undefined;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IAssetOwner {
    tenantId: number | undefined;
    reference: string;
    name: string;
    identifier: string | undefined;
    logoUrl: string | undefined;
    website: string | undefined;
    currencyId: number | undefined;
    currencyFk: Currency | undefined;
    ssicCodeId: number | undefined;
    ssicCodeFk: SsicCode | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class Currency implements ICurrency {
    tenantId!: number | undefined;
    code!: string;
    name!: string;
    symbol!: string | undefined;
    country!: string;
    baseCountry!: string;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICurrency) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.code = data["code"];
            this.name = data["name"];
            this.symbol = data["symbol"];
            this.country = data["country"];
            this.baseCountry = data["baseCountry"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Currency {
        data = typeof data === 'object' ? data : {};
        let result = new Currency();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["name"] = this.name;
        data["symbol"] = this.symbol;
        data["country"] = this.country;
        data["baseCountry"] = this.baseCountry;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICurrency {
    tenantId: number | undefined;
    code: string;
    name: string;
    symbol: string | undefined;
    country: string;
    baseCountry: string;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class SsicCode implements ISsicCode {
    tenantId!: number | undefined;
    code!: string;
    ssic!: string;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ISsicCode) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.code = data["code"];
            this.ssic = data["ssic"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SsicCode {
        data = typeof data === 'object' ? data : {};
        let result = new SsicCode();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["code"] = this.code;
        data["ssic"] = this.ssic;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISsicCode {
    tenantId: number | undefined;
    code: string;
    ssic: string;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class CreateInvoiceDto implements ICreateInvoiceDto {
    subscriptionPaymentId!: number | undefined;

    constructor(data?: ICreateInvoiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.subscriptionPaymentId = data["subscriptionPaymentId"];
        }
    }

    static fromJS(data: any): CreateInvoiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateInvoiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subscriptionPaymentId"] = this.subscriptionPaymentId;
        return data; 
    }
}

export interface ICreateInvoiceDto {
    subscriptionPaymentId: number | undefined;
}

export class PagedResultDtoOfGetItemTypeForViewDto implements IPagedResultDtoOfGetItemTypeForViewDto {
    totalCount!: number | undefined;
    items!: GetItemTypeForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetItemTypeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetItemTypeForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetItemTypeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetItemTypeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetItemTypeForViewDto {
    totalCount: number | undefined;
    items: GetItemTypeForViewDto[] | undefined;
}

export class GetItemTypeForViewDto implements IGetItemTypeForViewDto {
    itemType!: ItemTypeDto | undefined;

    constructor(data?: IGetItemTypeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.itemType = data["itemType"] ? ItemTypeDto.fromJS(data["itemType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetItemTypeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetItemTypeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["itemType"] = this.itemType ? this.itemType.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetItemTypeForViewDto {
    itemType: ItemTypeDto | undefined;
}

export class ItemTypeDto implements IItemTypeDto {
    type!: string | undefined;
    description!: string | undefined;
    id!: number | undefined;

    constructor(data?: IItemTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.type = data["type"];
            this.description = data["description"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ItemTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new ItemTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }
}

export interface IItemTypeDto {
    type: string | undefined;
    description: string | undefined;
    id: number | undefined;
}

export class GetItemTypeForEditOutput implements IGetItemTypeForEditOutput {
    itemType!: CreateOrEditItemTypeDto | undefined;

    constructor(data?: IGetItemTypeForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.itemType = data["itemType"] ? CreateOrEditItemTypeDto.fromJS(data["itemType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetItemTypeForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetItemTypeForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["itemType"] = this.itemType ? this.itemType.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetItemTypeForEditOutput {
    itemType: CreateOrEditItemTypeDto | undefined;
}

export class CreateOrEditItemTypeDto implements ICreateOrEditItemTypeDto {
    type!: string;
    description!: string;
    id!: number | undefined;

    constructor(data?: ICreateOrEditItemTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.type = data["type"];
            this.description = data["description"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditItemTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditItemTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditItemTypeDto {
    type: string;
    description: string;
    id: number | undefined;
}

export class PagedResultDtoOfItemTypeLookupTableDto implements IPagedResultDtoOfItemTypeLookupTableDto {
    totalCount!: number | undefined;
    items!: ItemTypeLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfItemTypeLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ItemTypeLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfItemTypeLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfItemTypeLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfItemTypeLookupTableDto {
    totalCount: number | undefined;
    items: ItemTypeLookupTableDto[] | undefined;
}

export class ItemTypeLookupTableDto implements IItemTypeLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IItemTypeLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): ItemTypeLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new ItemTypeLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IItemTypeLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class GetLanguagesOutput implements IGetLanguagesOutput {
    defaultLanguageName!: string | undefined;
    items!: ApplicationLanguageListDto[] | undefined;

    constructor(data?: IGetLanguagesOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.defaultLanguageName = data["defaultLanguageName"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(ApplicationLanguageListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetLanguagesOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLanguagesOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["defaultLanguageName"] = this.defaultLanguageName;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetLanguagesOutput {
    defaultLanguageName: string | undefined;
    items: ApplicationLanguageListDto[] | undefined;
}

export class ApplicationLanguageListDto implements IApplicationLanguageListDto {
    tenantId!: number | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    icon!: string | undefined;
    isDisabled!: boolean | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IApplicationLanguageListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.icon = data["icon"];
            this.isDisabled = data["isDisabled"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): ApplicationLanguageListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationLanguageListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["icon"] = this.icon;
        data["isDisabled"] = this.isDisabled;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IApplicationLanguageListDto {
    tenantId: number | undefined;
    name: string | undefined;
    displayName: string | undefined;
    icon: string | undefined;
    isDisabled: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class GetLanguageForEditOutput implements IGetLanguageForEditOutput {
    language!: ApplicationLanguageEditDto | undefined;
    languageNames!: ComboboxItemDto[] | undefined;
    flags!: ComboboxItemDto[] | undefined;

    constructor(data?: IGetLanguageForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.language = data["language"] ? ApplicationLanguageEditDto.fromJS(data["language"]) : <any>undefined;
            if (Array.isArray(data["languageNames"])) {
                this.languageNames = [] as any;
                for (let item of data["languageNames"])
                    this.languageNames!.push(ComboboxItemDto.fromJS(item));
            }
            if (Array.isArray(data["flags"])) {
                this.flags = [] as any;
                for (let item of data["flags"])
                    this.flags!.push(ComboboxItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetLanguageForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLanguageForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["language"] = this.language ? this.language.toJSON() : <any>undefined;
        if (Array.isArray(this.languageNames)) {
            data["languageNames"] = [];
            for (let item of this.languageNames)
                data["languageNames"].push(item.toJSON());
        }
        if (Array.isArray(this.flags)) {
            data["flags"] = [];
            for (let item of this.flags)
                data["flags"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetLanguageForEditOutput {
    language: ApplicationLanguageEditDto | undefined;
    languageNames: ComboboxItemDto[] | undefined;
    flags: ComboboxItemDto[] | undefined;
}

export class ApplicationLanguageEditDto implements IApplicationLanguageEditDto {
    id!: number | undefined;
    name!: string;
    icon!: string | undefined;
    isEnabled!: boolean | undefined;

    constructor(data?: IApplicationLanguageEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.icon = data["icon"];
            this.isEnabled = data["isEnabled"];
        }
    }

    static fromJS(data: any): ApplicationLanguageEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationLanguageEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["icon"] = this.icon;
        data["isEnabled"] = this.isEnabled;
        return data; 
    }
}

export interface IApplicationLanguageEditDto {
    id: number | undefined;
    name: string;
    icon: string | undefined;
    isEnabled: boolean | undefined;
}

export class ComboboxItemDto implements IComboboxItemDto {
    value!: string | undefined;
    displayText!: string | undefined;
    isSelected!: boolean | undefined;

    constructor(data?: IComboboxItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.value = data["value"];
            this.displayText = data["displayText"];
            this.isSelected = data["isSelected"];
        }
    }

    static fromJS(data: any): ComboboxItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new ComboboxItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        data["displayText"] = this.displayText;
        data["isSelected"] = this.isSelected;
        return data; 
    }
}

export interface IComboboxItemDto {
    value: string | undefined;
    displayText: string | undefined;
    isSelected: boolean | undefined;
}

export class CreateOrUpdateLanguageInput implements ICreateOrUpdateLanguageInput {
    language!: ApplicationLanguageEditDto;

    constructor(data?: ICreateOrUpdateLanguageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.language = new ApplicationLanguageEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.language = data["language"] ? ApplicationLanguageEditDto.fromJS(data["language"]) : new ApplicationLanguageEditDto();
        }
    }

    static fromJS(data: any): CreateOrUpdateLanguageInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateLanguageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["language"] = this.language ? this.language.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICreateOrUpdateLanguageInput {
    language: ApplicationLanguageEditDto;
}

export class SetDefaultLanguageInput implements ISetDefaultLanguageInput {
    name!: string;

    constructor(data?: ISetDefaultLanguageInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
        }
    }

    static fromJS(data: any): SetDefaultLanguageInput {
        data = typeof data === 'object' ? data : {};
        let result = new SetDefaultLanguageInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        return data; 
    }
}

export interface ISetDefaultLanguageInput {
    name: string;
}

export class PagedResultDtoOfLanguageTextListDto implements IPagedResultDtoOfLanguageTextListDto {
    totalCount!: number | undefined;
    items!: LanguageTextListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfLanguageTextListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(LanguageTextListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLanguageTextListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfLanguageTextListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfLanguageTextListDto {
    totalCount: number | undefined;
    items: LanguageTextListDto[] | undefined;
}

export class LanguageTextListDto implements ILanguageTextListDto {
    key!: string | undefined;
    baseValue!: string | undefined;
    targetValue!: string | undefined;

    constructor(data?: ILanguageTextListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.key = data["key"];
            this.baseValue = data["baseValue"];
            this.targetValue = data["targetValue"];
        }
    }

    static fromJS(data: any): LanguageTextListDto {
        data = typeof data === 'object' ? data : {};
        let result = new LanguageTextListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["baseValue"] = this.baseValue;
        data["targetValue"] = this.targetValue;
        return data; 
    }
}

export interface ILanguageTextListDto {
    key: string | undefined;
    baseValue: string | undefined;
    targetValue: string | undefined;
}

export class UpdateLanguageTextInput implements IUpdateLanguageTextInput {
    languageName!: string;
    sourceName!: string;
    key!: string;
    value!: string;

    constructor(data?: IUpdateLanguageTextInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.languageName = data["languageName"];
            this.sourceName = data["sourceName"];
            this.key = data["key"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): UpdateLanguageTextInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateLanguageTextInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        data["sourceName"] = this.sourceName;
        data["key"] = this.key;
        data["value"] = this.value;
        return data; 
    }
}

export interface IUpdateLanguageTextInput {
    languageName: string;
    sourceName: string;
    key: string;
    value: string;
}

export class PagedResultDtoOfGetLeaseAgreementForViewDto implements IPagedResultDtoOfGetLeaseAgreementForViewDto {
    totalCount!: number | undefined;
    items!: GetLeaseAgreementForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetLeaseAgreementForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetLeaseAgreementForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetLeaseAgreementForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetLeaseAgreementForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetLeaseAgreementForViewDto {
    totalCount: number | undefined;
    items: GetLeaseAgreementForViewDto[] | undefined;
}

export class GetLeaseAgreementForViewDto implements IGetLeaseAgreementForViewDto {
    leaseAgreement!: LeaseAgreementDto | undefined;
    contactContactName!: string | undefined;
    assetOwnerName!: string | undefined;
    customerName!: string | undefined;

    constructor(data?: IGetLeaseAgreementForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.leaseAgreement = data["leaseAgreement"] ? LeaseAgreementDto.fromJS(data["leaseAgreement"]) : <any>undefined;
            this.contactContactName = data["contactContactName"];
            this.assetOwnerName = data["assetOwnerName"];
            this.customerName = data["customerName"];
        }
    }

    static fromJS(data: any): GetLeaseAgreementForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetLeaseAgreementForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["leaseAgreement"] = this.leaseAgreement ? this.leaseAgreement.toJSON() : <any>undefined;
        data["contactContactName"] = this.contactContactName;
        data["assetOwnerName"] = this.assetOwnerName;
        data["customerName"] = this.customerName;
        return data; 
    }
}

export interface IGetLeaseAgreementForViewDto {
    leaseAgreement: LeaseAgreementDto | undefined;
    contactContactName: string | undefined;
    assetOwnerName: string | undefined;
    customerName: string | undefined;
}

export class LeaseAgreementDto implements ILeaseAgreementDto {
    reference!: string | undefined;
    description!: string | undefined;
    title!: string | undefined;
    terms!: string | undefined;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    contactId!: number | undefined;
    assetOwnerId!: number | undefined;
    customerId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ILeaseAgreementDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reference = data["reference"];
            this.description = data["description"];
            this.title = data["title"];
            this.terms = data["terms"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.contactId = data["contactId"];
            this.assetOwnerId = data["assetOwnerId"];
            this.customerId = data["customerId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): LeaseAgreementDto {
        data = typeof data === 'object' ? data : {};
        let result = new LeaseAgreementDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reference"] = this.reference;
        data["description"] = this.description;
        data["title"] = this.title;
        data["terms"] = this.terms;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["contactId"] = this.contactId;
        data["assetOwnerId"] = this.assetOwnerId;
        data["customerId"] = this.customerId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ILeaseAgreementDto {
    reference: string | undefined;
    description: string | undefined;
    title: string | undefined;
    terms: string | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    contactId: number | undefined;
    assetOwnerId: number | undefined;
    customerId: number | undefined;
    id: number | undefined;
}

export class GetLeaseAgreementForEditOutput implements IGetLeaseAgreementForEditOutput {
    leaseAgreement!: CreateOrEditLeaseAgreementDto | undefined;
    contactContactName!: string | undefined;
    assetOwnerName!: string | undefined;
    customerName!: string | undefined;

    constructor(data?: IGetLeaseAgreementForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.leaseAgreement = data["leaseAgreement"] ? CreateOrEditLeaseAgreementDto.fromJS(data["leaseAgreement"]) : <any>undefined;
            this.contactContactName = data["contactContactName"];
            this.assetOwnerName = data["assetOwnerName"];
            this.customerName = data["customerName"];
        }
    }

    static fromJS(data: any): GetLeaseAgreementForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLeaseAgreementForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["leaseAgreement"] = this.leaseAgreement ? this.leaseAgreement.toJSON() : <any>undefined;
        data["contactContactName"] = this.contactContactName;
        data["assetOwnerName"] = this.assetOwnerName;
        data["customerName"] = this.customerName;
        return data; 
    }
}

export interface IGetLeaseAgreementForEditOutput {
    leaseAgreement: CreateOrEditLeaseAgreementDto | undefined;
    contactContactName: string | undefined;
    assetOwnerName: string | undefined;
    customerName: string | undefined;
}

export class CreateOrEditLeaseAgreementDto implements ICreateOrEditLeaseAgreementDto {
    reference!: string | undefined;
    description!: string;
    title!: string;
    terms!: string | undefined;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    contactId!: number | undefined;
    assetOwnerId!: number | undefined;
    customerId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditLeaseAgreementDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reference = data["reference"];
            this.description = data["description"];
            this.title = data["title"];
            this.terms = data["terms"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.contactId = data["contactId"];
            this.assetOwnerId = data["assetOwnerId"];
            this.customerId = data["customerId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditLeaseAgreementDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditLeaseAgreementDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reference"] = this.reference;
        data["description"] = this.description;
        data["title"] = this.title;
        data["terms"] = this.terms;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["contactId"] = this.contactId;
        data["assetOwnerId"] = this.assetOwnerId;
        data["customerId"] = this.customerId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditLeaseAgreementDto {
    reference: string | undefined;
    description: string;
    title: string;
    terms: string | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    contactId: number | undefined;
    assetOwnerId: number | undefined;
    customerId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfLeaseAgreementContactLookupTableDto implements IPagedResultDtoOfLeaseAgreementContactLookupTableDto {
    totalCount!: number | undefined;
    items!: LeaseAgreementContactLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfLeaseAgreementContactLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(LeaseAgreementContactLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLeaseAgreementContactLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfLeaseAgreementContactLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfLeaseAgreementContactLookupTableDto {
    totalCount: number | undefined;
    items: LeaseAgreementContactLookupTableDto[] | undefined;
}

export class LeaseAgreementContactLookupTableDto implements ILeaseAgreementContactLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: ILeaseAgreementContactLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): LeaseAgreementContactLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new LeaseAgreementContactLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface ILeaseAgreementContactLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfLeaseAgreementAssetOwnerLookupTableDto implements IPagedResultDtoOfLeaseAgreementAssetOwnerLookupTableDto {
    totalCount!: number | undefined;
    items!: LeaseAgreementAssetOwnerLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfLeaseAgreementAssetOwnerLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(LeaseAgreementAssetOwnerLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLeaseAgreementAssetOwnerLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfLeaseAgreementAssetOwnerLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfLeaseAgreementAssetOwnerLookupTableDto {
    totalCount: number | undefined;
    items: LeaseAgreementAssetOwnerLookupTableDto[] | undefined;
}

export class LeaseAgreementAssetOwnerLookupTableDto implements ILeaseAgreementAssetOwnerLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: ILeaseAgreementAssetOwnerLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): LeaseAgreementAssetOwnerLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new LeaseAgreementAssetOwnerLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface ILeaseAgreementAssetOwnerLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfLeaseAgreementCustomerLookupTableDto implements IPagedResultDtoOfLeaseAgreementCustomerLookupTableDto {
    totalCount!: number | undefined;
    items!: LeaseAgreementCustomerLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfLeaseAgreementCustomerLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(LeaseAgreementCustomerLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLeaseAgreementCustomerLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfLeaseAgreementCustomerLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfLeaseAgreementCustomerLookupTableDto {
    totalCount: number | undefined;
    items: LeaseAgreementCustomerLookupTableDto[] | undefined;
}

export class LeaseAgreementCustomerLookupTableDto implements ILeaseAgreementCustomerLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: ILeaseAgreementCustomerLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): LeaseAgreementCustomerLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new LeaseAgreementCustomerLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface ILeaseAgreementCustomerLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class LeaseAgreementCustomerAndAssetOwnerDto implements ILeaseAgreementCustomerAndAssetOwnerDto {
    customerInfo!: LeaseAgreementCustomerLookupTableDto | undefined;
    assetOwnerInfo!: LeaseAgreementAssetOwnerLookupTableDto | undefined;

    constructor(data?: ILeaseAgreementCustomerAndAssetOwnerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.customerInfo = data["customerInfo"] ? LeaseAgreementCustomerLookupTableDto.fromJS(data["customerInfo"]) : <any>undefined;
            this.assetOwnerInfo = data["assetOwnerInfo"] ? LeaseAgreementAssetOwnerLookupTableDto.fromJS(data["assetOwnerInfo"]) : <any>undefined;
        }
    }

    static fromJS(data: any): LeaseAgreementCustomerAndAssetOwnerDto {
        data = typeof data === 'object' ? data : {};
        let result = new LeaseAgreementCustomerAndAssetOwnerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["customerInfo"] = this.customerInfo ? this.customerInfo.toJSON() : <any>undefined;
        data["assetOwnerInfo"] = this.assetOwnerInfo ? this.assetOwnerInfo.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ILeaseAgreementCustomerAndAssetOwnerDto {
    customerInfo: LeaseAgreementCustomerLookupTableDto | undefined;
    assetOwnerInfo: LeaseAgreementAssetOwnerLookupTableDto | undefined;
}

export class GetLeaseItemForEditOutput implements IGetLeaseItemForEditOutput {
    leaseItem!: CreateOrEditLeaseItemDto | undefined;
    assetClassClass!: string | undefined;
    assetReference!: string | undefined;
    leaseAgreementTitle!: string | undefined;
    depositUom!: string | undefined;
    rentalUom!: string | undefined;

    constructor(data?: IGetLeaseItemForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.leaseItem = data["leaseItem"] ? CreateOrEditLeaseItemDto.fromJS(data["leaseItem"]) : <any>undefined;
            this.assetClassClass = data["assetClassClass"];
            this.assetReference = data["assetReference"];
            this.leaseAgreementTitle = data["leaseAgreementTitle"];
            this.depositUom = data["depositUom"];
            this.rentalUom = data["rentalUom"];
        }
    }

    static fromJS(data: any): GetLeaseItemForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLeaseItemForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["leaseItem"] = this.leaseItem ? this.leaseItem.toJSON() : <any>undefined;
        data["assetClassClass"] = this.assetClassClass;
        data["assetReference"] = this.assetReference;
        data["leaseAgreementTitle"] = this.leaseAgreementTitle;
        data["depositUom"] = this.depositUom;
        data["rentalUom"] = this.rentalUom;
        return data; 
    }
}

export interface IGetLeaseItemForEditOutput {
    leaseItem: CreateOrEditLeaseItemDto | undefined;
    assetClassClass: string | undefined;
    assetReference: string | undefined;
    leaseAgreementTitle: string | undefined;
    depositUom: string | undefined;
    rentalUom: string | undefined;
}

export class CreateOrEditLeaseItemDto implements ICreateOrEditLeaseItemDto {
    dateAllocated!: moment.Moment | undefined;
    allocationPercentage!: number | undefined;
    terms!: string | undefined;
    unitRentalRate!: number | undefined;
    unitDepositRate!: number | undefined;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    rentalUomRefId!: number | undefined;
    depositUomRefId!: number | undefined;
    item!: string | undefined;
    description!: string | undefined;
    assetClassId!: number | undefined;
    assetId!: number | undefined;
    leaseAgreementId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditLeaseItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.dateAllocated = data["dateAllocated"] ? moment(data["dateAllocated"].toString()) : <any>undefined;
            this.allocationPercentage = data["allocationPercentage"];
            this.terms = data["terms"];
            this.unitRentalRate = data["unitRentalRate"];
            this.unitDepositRate = data["unitDepositRate"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.rentalUomRefId = data["rentalUomRefId"];
            this.depositUomRefId = data["depositUomRefId"];
            this.item = data["item"];
            this.description = data["description"];
            this.assetClassId = data["assetClassId"];
            this.assetId = data["assetId"];
            this.leaseAgreementId = data["leaseAgreementId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditLeaseItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditLeaseItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dateAllocated"] = this.dateAllocated ? this.dateAllocated.toISOString() : <any>undefined;
        data["allocationPercentage"] = this.allocationPercentage;
        data["terms"] = this.terms;
        data["unitRentalRate"] = this.unitRentalRate;
        data["unitDepositRate"] = this.unitDepositRate;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["rentalUomRefId"] = this.rentalUomRefId;
        data["depositUomRefId"] = this.depositUomRefId;
        data["item"] = this.item;
        data["description"] = this.description;
        data["assetClassId"] = this.assetClassId;
        data["assetId"] = this.assetId;
        data["leaseAgreementId"] = this.leaseAgreementId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditLeaseItemDto {
    dateAllocated: moment.Moment | undefined;
    allocationPercentage: number | undefined;
    terms: string | undefined;
    unitRentalRate: number | undefined;
    unitDepositRate: number | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    rentalUomRefId: number | undefined;
    depositUomRefId: number | undefined;
    item: string | undefined;
    description: string | undefined;
    assetClassId: number | undefined;
    assetId: number | undefined;
    leaseAgreementId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfLeaseItemAssetClassLookupTableDto implements IPagedResultDtoOfLeaseItemAssetClassLookupTableDto {
    totalCount!: number | undefined;
    items!: LeaseItemAssetClassLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfLeaseItemAssetClassLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(LeaseItemAssetClassLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLeaseItemAssetClassLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfLeaseItemAssetClassLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfLeaseItemAssetClassLookupTableDto {
    totalCount: number | undefined;
    items: LeaseItemAssetClassLookupTableDto[] | undefined;
}

export class LeaseItemAssetClassLookupTableDto implements ILeaseItemAssetClassLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: ILeaseItemAssetClassLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): LeaseItemAssetClassLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new LeaseItemAssetClassLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface ILeaseItemAssetClassLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfLeaseItemAssetLookupTableDto implements IPagedResultDtoOfLeaseItemAssetLookupTableDto {
    totalCount!: number | undefined;
    items!: LeaseItemAssetLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfLeaseItemAssetLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(LeaseItemAssetLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLeaseItemAssetLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfLeaseItemAssetLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfLeaseItemAssetLookupTableDto {
    totalCount: number | undefined;
    items: LeaseItemAssetLookupTableDto[] | undefined;
}

export class LeaseItemAssetLookupTableDto implements ILeaseItemAssetLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: ILeaseItemAssetLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): LeaseItemAssetLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new LeaseItemAssetLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface ILeaseItemAssetLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfLeaseItemLeaseAgreementLookupTableDto implements IPagedResultDtoOfLeaseItemLeaseAgreementLookupTableDto {
    totalCount!: number | undefined;
    items!: LeaseItemLeaseAgreementLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfLeaseItemLeaseAgreementLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(LeaseItemLeaseAgreementLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLeaseItemLeaseAgreementLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfLeaseItemLeaseAgreementLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfLeaseItemLeaseAgreementLookupTableDto {
    totalCount: number | undefined;
    items: LeaseItemLeaseAgreementLookupTableDto[] | undefined;
}

export class LeaseItemLeaseAgreementLookupTableDto implements ILeaseItemLeaseAgreementLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: ILeaseItemLeaseAgreementLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): LeaseItemLeaseAgreementLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new LeaseItemLeaseAgreementLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface ILeaseItemLeaseAgreementLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfLeaseItemUomLookupTableDto implements IPagedResultDtoOfLeaseItemUomLookupTableDto {
    totalCount!: number | undefined;
    items!: LeaseItemUomLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfLeaseItemUomLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(LeaseItemUomLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLeaseItemUomLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfLeaseItemUomLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfLeaseItemUomLookupTableDto {
    totalCount: number | undefined;
    items: LeaseItemUomLookupTableDto[] | undefined;
}

export class LeaseItemUomLookupTableDto implements ILeaseItemUomLookupTableDto {
    id!: number | undefined;
    unitOfMeasurement!: string | undefined;

    constructor(data?: ILeaseItemUomLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.unitOfMeasurement = data["unitOfMeasurement"];
        }
    }

    static fromJS(data: any): LeaseItemUomLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new LeaseItemUomLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["unitOfMeasurement"] = this.unitOfMeasurement;
        return data; 
    }
}

export interface ILeaseItemUomLookupTableDto {
    id: number | undefined;
    unitOfMeasurement: string | undefined;
}

export class CreateOrEditLocationDto implements ICreateOrEditLocationDto {
    locationName!: string | undefined;
    userId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditLocationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.locationName = data["locationName"];
            this.userId = data["userId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditLocationDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditLocationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["locationName"] = this.locationName;
        data["userId"] = this.userId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditLocationDto {
    locationName: string | undefined;
    userId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfGetLocationForViewDto implements IPagedResultDtoOfGetLocationForViewDto {
    totalCount!: number | undefined;
    items!: GetLocationForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetLocationForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetLocationForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetLocationForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetLocationForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetLocationForViewDto {
    totalCount: number | undefined;
    items: GetLocationForViewDto[] | undefined;
}

export class GetLocationForViewDto implements IGetLocationForViewDto {
    location!: LocationDto | undefined;
    userName!: string | undefined;

    constructor(data?: IGetLocationForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.location = data["location"] ? LocationDto.fromJS(data["location"]) : <any>undefined;
            this.userName = data["userName"];
        }
    }

    static fromJS(data: any): GetLocationForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetLocationForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        data["userName"] = this.userName;
        return data; 
    }
}

export interface IGetLocationForViewDto {
    location: LocationDto | undefined;
    userName: string | undefined;
}

export class LocationDto implements ILocationDto {
    locationName!: string | undefined;
    userId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ILocationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.locationName = data["locationName"];
            this.userId = data["userId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): LocationDto {
        data = typeof data === 'object' ? data : {};
        let result = new LocationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["locationName"] = this.locationName;
        data["userId"] = this.userId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ILocationDto {
    locationName: string | undefined;
    userId: number | undefined;
    id: number | undefined;
}

export class GetLocationForEditOutput implements IGetLocationForEditOutput {
    location!: CreateOrEditLocationDto | undefined;
    userName!: string | undefined;

    constructor(data?: IGetLocationForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.location = data["location"] ? CreateOrEditLocationDto.fromJS(data["location"]) : <any>undefined;
            this.userName = data["userName"];
        }
    }

    static fromJS(data: any): GetLocationForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLocationForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["location"] = this.location ? this.location.toJSON() : <any>undefined;
        data["userName"] = this.userName;
        return data; 
    }
}

export interface IGetLocationForEditOutput {
    location: CreateOrEditLocationDto | undefined;
    userName: string | undefined;
}

export class PagedResultDtoOfGetMaintenancePlanForViewDto implements IPagedResultDtoOfGetMaintenancePlanForViewDto {
    totalCount!: number | undefined;
    items!: GetMaintenancePlanForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetMaintenancePlanForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetMaintenancePlanForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetMaintenancePlanForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetMaintenancePlanForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetMaintenancePlanForViewDto {
    totalCount: number | undefined;
    items: GetMaintenancePlanForViewDto[] | undefined;
}

export class GetMaintenancePlanForViewDto implements IGetMaintenancePlanForViewDto {
    maintenancePlan!: MaintenancePlanDto | undefined;
    workOrderPriorityPriority!: string | undefined;
    workOrderTypeType!: string | undefined;

    constructor(data?: IGetMaintenancePlanForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.maintenancePlan = data["maintenancePlan"] ? MaintenancePlanDto.fromJS(data["maintenancePlan"]) : <any>undefined;
            this.workOrderPriorityPriority = data["workOrderPriorityPriority"];
            this.workOrderTypeType = data["workOrderTypeType"];
        }
    }

    static fromJS(data: any): GetMaintenancePlanForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetMaintenancePlanForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maintenancePlan"] = this.maintenancePlan ? this.maintenancePlan.toJSON() : <any>undefined;
        data["workOrderPriorityPriority"] = this.workOrderPriorityPriority;
        data["workOrderTypeType"] = this.workOrderTypeType;
        return data; 
    }
}

export interface IGetMaintenancePlanForViewDto {
    maintenancePlan: MaintenancePlanDto | undefined;
    workOrderPriorityPriority: string | undefined;
    workOrderTypeType: string | undefined;
}

export class MaintenancePlanDto implements IMaintenancePlanDto {
    subject!: string | undefined;
    description!: string | undefined;
    remarks!: string | undefined;
    workOrderPriorityId!: number | undefined;
    workOrderTypeId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IMaintenancePlanDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.subject = data["subject"];
            this.description = data["description"];
            this.remarks = data["remarks"];
            this.workOrderPriorityId = data["workOrderPriorityId"];
            this.workOrderTypeId = data["workOrderTypeId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): MaintenancePlanDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaintenancePlanDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subject"] = this.subject;
        data["description"] = this.description;
        data["remarks"] = this.remarks;
        data["workOrderPriorityId"] = this.workOrderPriorityId;
        data["workOrderTypeId"] = this.workOrderTypeId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IMaintenancePlanDto {
    subject: string | undefined;
    description: string | undefined;
    remarks: string | undefined;
    workOrderPriorityId: number | undefined;
    workOrderTypeId: number | undefined;
    id: number | undefined;
}

export class GetMaintenancePlanForEditOutput implements IGetMaintenancePlanForEditOutput {
    maintenancePlan!: CreateOrEditMaintenancePlanDto | undefined;
    workOrderPriorityPriority!: string | undefined;
    workOrderTypeType!: string | undefined;

    constructor(data?: IGetMaintenancePlanForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.maintenancePlan = data["maintenancePlan"] ? CreateOrEditMaintenancePlanDto.fromJS(data["maintenancePlan"]) : <any>undefined;
            this.workOrderPriorityPriority = data["workOrderPriorityPriority"];
            this.workOrderTypeType = data["workOrderTypeType"];
        }
    }

    static fromJS(data: any): GetMaintenancePlanForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetMaintenancePlanForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maintenancePlan"] = this.maintenancePlan ? this.maintenancePlan.toJSON() : <any>undefined;
        data["workOrderPriorityPriority"] = this.workOrderPriorityPriority;
        data["workOrderTypeType"] = this.workOrderTypeType;
        return data; 
    }
}

export interface IGetMaintenancePlanForEditOutput {
    maintenancePlan: CreateOrEditMaintenancePlanDto | undefined;
    workOrderPriorityPriority: string | undefined;
    workOrderTypeType: string | undefined;
}

export class CreateOrEditMaintenancePlanDto implements ICreateOrEditMaintenancePlanDto {
    subject!: string;
    description!: string | undefined;
    remarks!: string | undefined;
    workOrderPriorityId!: number | undefined;
    workOrderTypeId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditMaintenancePlanDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.subject = data["subject"];
            this.description = data["description"];
            this.remarks = data["remarks"];
            this.workOrderPriorityId = data["workOrderPriorityId"];
            this.workOrderTypeId = data["workOrderTypeId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditMaintenancePlanDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditMaintenancePlanDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["subject"] = this.subject;
        data["description"] = this.description;
        data["remarks"] = this.remarks;
        data["workOrderPriorityId"] = this.workOrderPriorityId;
        data["workOrderTypeId"] = this.workOrderTypeId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditMaintenancePlanDto {
    subject: string;
    description: string | undefined;
    remarks: string | undefined;
    workOrderPriorityId: number | undefined;
    workOrderTypeId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfMaintenancePlanWorkOrderPriorityLookupTableDto implements IPagedResultDtoOfMaintenancePlanWorkOrderPriorityLookupTableDto {
    totalCount!: number | undefined;
    items!: MaintenancePlanWorkOrderPriorityLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfMaintenancePlanWorkOrderPriorityLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(MaintenancePlanWorkOrderPriorityLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfMaintenancePlanWorkOrderPriorityLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfMaintenancePlanWorkOrderPriorityLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfMaintenancePlanWorkOrderPriorityLookupTableDto {
    totalCount: number | undefined;
    items: MaintenancePlanWorkOrderPriorityLookupTableDto[] | undefined;
}

export class MaintenancePlanWorkOrderPriorityLookupTableDto implements IMaintenancePlanWorkOrderPriorityLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IMaintenancePlanWorkOrderPriorityLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): MaintenancePlanWorkOrderPriorityLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaintenancePlanWorkOrderPriorityLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IMaintenancePlanWorkOrderPriorityLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfMaintenancePlanWorkOrderTypeLookupTableDto implements IPagedResultDtoOfMaintenancePlanWorkOrderTypeLookupTableDto {
    totalCount!: number | undefined;
    items!: MaintenancePlanWorkOrderTypeLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfMaintenancePlanWorkOrderTypeLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(MaintenancePlanWorkOrderTypeLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfMaintenancePlanWorkOrderTypeLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfMaintenancePlanWorkOrderTypeLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfMaintenancePlanWorkOrderTypeLookupTableDto {
    totalCount: number | undefined;
    items: MaintenancePlanWorkOrderTypeLookupTableDto[] | undefined;
}

export class MaintenancePlanWorkOrderTypeLookupTableDto implements IMaintenancePlanWorkOrderTypeLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IMaintenancePlanWorkOrderTypeLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): MaintenancePlanWorkOrderTypeLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaintenancePlanWorkOrderTypeLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IMaintenancePlanWorkOrderTypeLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetMaintenanceStepForViewDto implements IPagedResultDtoOfGetMaintenanceStepForViewDto {
    totalCount!: number | undefined;
    items!: GetMaintenanceStepForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetMaintenanceStepForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetMaintenanceStepForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetMaintenanceStepForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetMaintenanceStepForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetMaintenanceStepForViewDto {
    totalCount: number | undefined;
    items: GetMaintenanceStepForViewDto[] | undefined;
}

export class GetMaintenanceStepForViewDto implements IGetMaintenanceStepForViewDto {
    maintenanceStep!: MaintenanceStepDto | undefined;
    maintenancePlanSubject!: string | undefined;
    itemTypeType!: string | undefined;
    workOrderActionAction!: string | undefined;

    constructor(data?: IGetMaintenanceStepForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.maintenanceStep = data["maintenanceStep"] ? MaintenanceStepDto.fromJS(data["maintenanceStep"]) : <any>undefined;
            this.maintenancePlanSubject = data["maintenancePlanSubject"];
            this.itemTypeType = data["itemTypeType"];
            this.workOrderActionAction = data["workOrderActionAction"];
        }
    }

    static fromJS(data: any): GetMaintenanceStepForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetMaintenanceStepForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maintenanceStep"] = this.maintenanceStep ? this.maintenanceStep.toJSON() : <any>undefined;
        data["maintenancePlanSubject"] = this.maintenancePlanSubject;
        data["itemTypeType"] = this.itemTypeType;
        data["workOrderActionAction"] = this.workOrderActionAction;
        return data; 
    }
}

export interface IGetMaintenanceStepForViewDto {
    maintenanceStep: MaintenanceStepDto | undefined;
    maintenancePlanSubject: string | undefined;
    itemTypeType: string | undefined;
    workOrderActionAction: string | undefined;
}

export class MaintenanceStepDto implements IMaintenanceStepDto {
    comments!: string | undefined;
    quantity!: number | undefined;
    cost!: number | undefined;
    price!: number | undefined;
    maintenancePlanId!: number | undefined;
    itemTypeId!: number | undefined;
    workOrderActionId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IMaintenanceStepDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.comments = data["comments"];
            this.quantity = data["quantity"];
            this.cost = data["cost"];
            this.price = data["price"];
            this.maintenancePlanId = data["maintenancePlanId"];
            this.itemTypeId = data["itemTypeId"];
            this.workOrderActionId = data["workOrderActionId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): MaintenanceStepDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaintenanceStepDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["comments"] = this.comments;
        data["quantity"] = this.quantity;
        data["cost"] = this.cost;
        data["price"] = this.price;
        data["maintenancePlanId"] = this.maintenancePlanId;
        data["itemTypeId"] = this.itemTypeId;
        data["workOrderActionId"] = this.workOrderActionId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IMaintenanceStepDto {
    comments: string | undefined;
    quantity: number | undefined;
    cost: number | undefined;
    price: number | undefined;
    maintenancePlanId: number | undefined;
    itemTypeId: number | undefined;
    workOrderActionId: number | undefined;
    id: number | undefined;
}

export class GetMaintenanceStepForEditOutput implements IGetMaintenanceStepForEditOutput {
    maintenanceStep!: CreateOrEditMaintenanceStepDto | undefined;
    maintenancePlanSubject!: string | undefined;
    itemTypeType!: string | undefined;
    workOrderActionAction!: string | undefined;

    constructor(data?: IGetMaintenanceStepForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.maintenanceStep = data["maintenanceStep"] ? CreateOrEditMaintenanceStepDto.fromJS(data["maintenanceStep"]) : <any>undefined;
            this.maintenancePlanSubject = data["maintenancePlanSubject"];
            this.itemTypeType = data["itemTypeType"];
            this.workOrderActionAction = data["workOrderActionAction"];
        }
    }

    static fromJS(data: any): GetMaintenanceStepForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetMaintenanceStepForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["maintenanceStep"] = this.maintenanceStep ? this.maintenanceStep.toJSON() : <any>undefined;
        data["maintenancePlanSubject"] = this.maintenancePlanSubject;
        data["itemTypeType"] = this.itemTypeType;
        data["workOrderActionAction"] = this.workOrderActionAction;
        return data; 
    }
}

export interface IGetMaintenanceStepForEditOutput {
    maintenanceStep: CreateOrEditMaintenanceStepDto | undefined;
    maintenancePlanSubject: string | undefined;
    itemTypeType: string | undefined;
    workOrderActionAction: string | undefined;
}

export class CreateOrEditMaintenanceStepDto implements ICreateOrEditMaintenanceStepDto {
    comments!: string | undefined;
    quantity!: number | undefined;
    cost!: number | undefined;
    price!: number | undefined;
    maintenancePlanId!: number | undefined;
    itemTypeId!: number | undefined;
    workOrderActionId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditMaintenanceStepDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.comments = data["comments"];
            this.quantity = data["quantity"];
            this.cost = data["cost"];
            this.price = data["price"];
            this.maintenancePlanId = data["maintenancePlanId"];
            this.itemTypeId = data["itemTypeId"];
            this.workOrderActionId = data["workOrderActionId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditMaintenanceStepDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditMaintenanceStepDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["comments"] = this.comments;
        data["quantity"] = this.quantity;
        data["cost"] = this.cost;
        data["price"] = this.price;
        data["maintenancePlanId"] = this.maintenancePlanId;
        data["itemTypeId"] = this.itemTypeId;
        data["workOrderActionId"] = this.workOrderActionId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditMaintenanceStepDto {
    comments: string | undefined;
    quantity: number | undefined;
    cost: number | undefined;
    price: number | undefined;
    maintenancePlanId: number | undefined;
    itemTypeId: number | undefined;
    workOrderActionId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfMaintenanceStepMaintenancePlanLookupTableDto implements IPagedResultDtoOfMaintenanceStepMaintenancePlanLookupTableDto {
    totalCount!: number | undefined;
    items!: MaintenanceStepMaintenancePlanLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfMaintenanceStepMaintenancePlanLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(MaintenanceStepMaintenancePlanLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfMaintenanceStepMaintenancePlanLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfMaintenanceStepMaintenancePlanLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfMaintenanceStepMaintenancePlanLookupTableDto {
    totalCount: number | undefined;
    items: MaintenanceStepMaintenancePlanLookupTableDto[] | undefined;
}

export class MaintenanceStepMaintenancePlanLookupTableDto implements IMaintenanceStepMaintenancePlanLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IMaintenanceStepMaintenancePlanLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): MaintenanceStepMaintenancePlanLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaintenanceStepMaintenancePlanLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IMaintenanceStepMaintenancePlanLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfMaintenanceStepItemTypeLookupTableDto implements IPagedResultDtoOfMaintenanceStepItemTypeLookupTableDto {
    totalCount!: number | undefined;
    items!: MaintenanceStepItemTypeLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfMaintenanceStepItemTypeLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(MaintenanceStepItemTypeLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfMaintenanceStepItemTypeLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfMaintenanceStepItemTypeLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfMaintenanceStepItemTypeLookupTableDto {
    totalCount: number | undefined;
    items: MaintenanceStepItemTypeLookupTableDto[] | undefined;
}

export class MaintenanceStepItemTypeLookupTableDto implements IMaintenanceStepItemTypeLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IMaintenanceStepItemTypeLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): MaintenanceStepItemTypeLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaintenanceStepItemTypeLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IMaintenanceStepItemTypeLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfMaintenanceStepWorkOrderActionLookupTableDto implements IPagedResultDtoOfMaintenanceStepWorkOrderActionLookupTableDto {
    totalCount!: number | undefined;
    items!: MaintenanceStepWorkOrderActionLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfMaintenanceStepWorkOrderActionLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(MaintenanceStepWorkOrderActionLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfMaintenanceStepWorkOrderActionLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfMaintenanceStepWorkOrderActionLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfMaintenanceStepWorkOrderActionLookupTableDto {
    totalCount: number | undefined;
    items: MaintenanceStepWorkOrderActionLookupTableDto[] | undefined;
}

export class MaintenanceStepWorkOrderActionLookupTableDto implements IMaintenanceStepWorkOrderActionLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IMaintenanceStepWorkOrderActionLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): MaintenanceStepWorkOrderActionLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new MaintenanceStepWorkOrderActionLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IMaintenanceStepWorkOrderActionLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export enum UserNotificationState {
    Unread = 0,
    Read = 1,
}

export class GetNotificationsOutput implements IGetNotificationsOutput {
    unreadCount!: number | undefined;
    totalCount!: number | undefined;
    items!: UserNotification[] | undefined;

    constructor(data?: IGetNotificationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.unreadCount = data["unreadCount"];
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(UserNotification.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetNotificationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetNotificationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["unreadCount"] = this.unreadCount;
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetNotificationsOutput {
    unreadCount: number | undefined;
    totalCount: number | undefined;
    items: UserNotification[] | undefined;
}

export class UserNotification implements IUserNotification {
    tenantId!: number | undefined;
    userId!: number | undefined;
    state!: UserNotificationState | undefined;
    notification!: TenantNotification | undefined;
    id!: string | undefined;

    constructor(data?: IUserNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.state = data["state"];
            this.notification = data["notification"] ? TenantNotification.fromJS(data["notification"]) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserNotification {
        data = typeof data === 'object' ? data : {};
        let result = new UserNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["state"] = this.state;
        data["notification"] = this.notification ? this.notification.toJSON() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserNotification {
    tenantId: number | undefined;
    userId: number | undefined;
    state: UserNotificationState | undefined;
    notification: TenantNotification | undefined;
    id: string | undefined;
}

export class TenantNotification implements ITenantNotification {
    tenantId!: number | undefined;
    notificationName!: string | undefined;
    data!: NotificationData | undefined;
    entityType!: string | undefined;
    entityTypeName!: string | undefined;
    entityId!: any | undefined;
    severity!: NotificationSeverity | undefined;
    creationTime!: moment.Moment | undefined;
    id!: string | undefined;

    constructor(data?: ITenantNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.notificationName = data["notificationName"];
            this.data = data["data"] ? NotificationData.fromJS(data["data"]) : <any>undefined;
            this.entityType = data["entityType"];
            this.entityTypeName = data["entityTypeName"];
            this.entityId = data["entityId"];
            this.severity = data["severity"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantNotification {
        data = typeof data === 'object' ? data : {};
        let result = new TenantNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["notificationName"] = this.notificationName;
        data["data"] = this.data ? this.data.toJSON() : <any>undefined;
        data["entityType"] = this.entityType;
        data["entityTypeName"] = this.entityTypeName;
        data["entityId"] = this.entityId;
        data["severity"] = this.severity;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITenantNotification {
    tenantId: number | undefined;
    notificationName: string | undefined;
    data: NotificationData | undefined;
    entityType: string | undefined;
    entityTypeName: string | undefined;
    entityId: any | undefined;
    severity: NotificationSeverity | undefined;
    creationTime: moment.Moment | undefined;
    id: string | undefined;
}

export class NotificationData implements INotificationData {
    readonly type!: string | undefined;
    properties!: { [key: string]: any; } | undefined;

    constructor(data?: INotificationData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            (<any>this).type = data["type"];
            if (data["properties"]) {
                this.properties = {} as any;
                for (let key in data["properties"]) {
                    if (data["properties"].hasOwnProperty(key))
                        this.properties![key] = data["properties"][key];
                }
            }
        }
    }

    static fromJS(data: any): NotificationData {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        if (this.properties) {
            data["properties"] = {};
            for (let key in this.properties) {
                if (this.properties.hasOwnProperty(key))
                    data["properties"][key] = this.properties[key];
            }
        }
        return data; 
    }
}

export interface INotificationData {
    type: string | undefined;
    properties: { [key: string]: any; } | undefined;
}

export enum NotificationSeverity {
    Info = 0,
    Success = 1,
    Warn = 2,
    Error = 3,
    Fatal = 4,
}

export class EntityDtoOfGuid implements IEntityDtoOfGuid {
    id!: string | undefined;

    constructor(data?: IEntityDtoOfGuid) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityDtoOfGuid {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDtoOfGuid();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IEntityDtoOfGuid {
    id: string | undefined;
}

export class GetNotificationSettingsOutput implements IGetNotificationSettingsOutput {
    receiveNotifications!: boolean | undefined;
    notifications!: NotificationSubscriptionWithDisplayNameDto[] | undefined;

    constructor(data?: IGetNotificationSettingsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.receiveNotifications = data["receiveNotifications"];
            if (Array.isArray(data["notifications"])) {
                this.notifications = [] as any;
                for (let item of data["notifications"])
                    this.notifications!.push(NotificationSubscriptionWithDisplayNameDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetNotificationSettingsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetNotificationSettingsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["receiveNotifications"] = this.receiveNotifications;
        if (Array.isArray(this.notifications)) {
            data["notifications"] = [];
            for (let item of this.notifications)
                data["notifications"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetNotificationSettingsOutput {
    receiveNotifications: boolean | undefined;
    notifications: NotificationSubscriptionWithDisplayNameDto[] | undefined;
}

export class NotificationSubscriptionWithDisplayNameDto implements INotificationSubscriptionWithDisplayNameDto {
    displayName!: string | undefined;
    description!: string | undefined;
    name!: string;
    isSubscribed!: boolean | undefined;

    constructor(data?: INotificationSubscriptionWithDisplayNameDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.name = data["name"];
            this.isSubscribed = data["isSubscribed"];
        }
    }

    static fromJS(data: any): NotificationSubscriptionWithDisplayNameDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSubscriptionWithDisplayNameDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["name"] = this.name;
        data["isSubscribed"] = this.isSubscribed;
        return data; 
    }
}

export interface INotificationSubscriptionWithDisplayNameDto {
    displayName: string | undefined;
    description: string | undefined;
    name: string;
    isSubscribed: boolean | undefined;
}

export class UpdateNotificationSettingsInput implements IUpdateNotificationSettingsInput {
    receiveNotifications!: boolean | undefined;
    notifications!: NotificationSubscriptionDto[] | undefined;

    constructor(data?: IUpdateNotificationSettingsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.receiveNotifications = data["receiveNotifications"];
            if (Array.isArray(data["notifications"])) {
                this.notifications = [] as any;
                for (let item of data["notifications"])
                    this.notifications!.push(NotificationSubscriptionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateNotificationSettingsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateNotificationSettingsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["receiveNotifications"] = this.receiveNotifications;
        if (Array.isArray(this.notifications)) {
            data["notifications"] = [];
            for (let item of this.notifications)
                data["notifications"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUpdateNotificationSettingsInput {
    receiveNotifications: boolean | undefined;
    notifications: NotificationSubscriptionDto[] | undefined;
}

export class NotificationSubscriptionDto implements INotificationSubscriptionDto {
    name!: string;
    isSubscribed!: boolean | undefined;

    constructor(data?: INotificationSubscriptionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.isSubscribed = data["isSubscribed"];
        }
    }

    static fromJS(data: any): NotificationSubscriptionDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationSubscriptionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["isSubscribed"] = this.isSubscribed;
        return data; 
    }
}

export interface INotificationSubscriptionDto {
    name: string;
    isSubscribed: boolean | undefined;
}

export class ListResultDtoOfOrganizationUnitDto implements IListResultDtoOfOrganizationUnitDto {
    items!: OrganizationUnitDto[] | undefined;

    constructor(data?: IListResultDtoOfOrganizationUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(OrganizationUnitDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfOrganizationUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfOrganizationUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfOrganizationUnitDto {
    items: OrganizationUnitDto[] | undefined;
}

export class OrganizationUnitDto implements IOrganizationUnitDto {
    parentId!: number | undefined;
    code!: string | undefined;
    displayName!: string | undefined;
    memberCount!: number | undefined;
    roleCount!: number | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IOrganizationUnitDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentId = data["parentId"];
            this.code = data["code"];
            this.displayName = data["displayName"];
            this.memberCount = data["memberCount"];
            this.roleCount = data["roleCount"];
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OrganizationUnitDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["code"] = this.code;
        data["displayName"] = this.displayName;
        data["memberCount"] = this.memberCount;
        data["roleCount"] = this.roleCount;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IOrganizationUnitDto {
    parentId: number | undefined;
    code: string | undefined;
    displayName: string | undefined;
    memberCount: number | undefined;
    roleCount: number | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfOrganizationUnitUserListDto implements IPagedResultDtoOfOrganizationUnitUserListDto {
    totalCount!: number | undefined;
    items!: OrganizationUnitUserListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfOrganizationUnitUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(OrganizationUnitUserListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfOrganizationUnitUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfOrganizationUnitUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfOrganizationUnitUserListDto {
    totalCount: number | undefined;
    items: OrganizationUnitUserListDto[] | undefined;
}

export class OrganizationUnitUserListDto implements IOrganizationUnitUserListDto {
    name!: string | undefined;
    surname!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    profilePictureId!: string | undefined;
    addedTime!: moment.Moment | undefined;
    id!: number | undefined;

    constructor(data?: IOrganizationUnitUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.profilePictureId = data["profilePictureId"];
            this.addedTime = data["addedTime"] ? moment(data["addedTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OrganizationUnitUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["profilePictureId"] = this.profilePictureId;
        data["addedTime"] = this.addedTime ? this.addedTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IOrganizationUnitUserListDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    profilePictureId: string | undefined;
    addedTime: moment.Moment | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfOrganizationUnitRoleListDto implements IPagedResultDtoOfOrganizationUnitRoleListDto {
    totalCount!: number | undefined;
    items!: OrganizationUnitRoleListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfOrganizationUnitRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(OrganizationUnitRoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfOrganizationUnitRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfOrganizationUnitRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfOrganizationUnitRoleListDto {
    totalCount: number | undefined;
    items: OrganizationUnitRoleListDto[] | undefined;
}

export class OrganizationUnitRoleListDto implements IOrganizationUnitRoleListDto {
    displayName!: string | undefined;
    name!: string | undefined;
    addedTime!: moment.Moment | undefined;
    id!: number | undefined;

    constructor(data?: IOrganizationUnitRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.displayName = data["displayName"];
            this.name = data["name"];
            this.addedTime = data["addedTime"] ? moment(data["addedTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): OrganizationUnitRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationUnitRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["name"] = this.name;
        data["addedTime"] = this.addedTime ? this.addedTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IOrganizationUnitRoleListDto {
    displayName: string | undefined;
    name: string | undefined;
    addedTime: moment.Moment | undefined;
    id: number | undefined;
}

export class CreateOrganizationUnitInput implements ICreateOrganizationUnitInput {
    parentId!: number | undefined;
    displayName!: string;

    constructor(data?: ICreateOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentId = data["parentId"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): CreateOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentId"] = this.parentId;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface ICreateOrganizationUnitInput {
    parentId: number | undefined;
    displayName: string;
}

export class UpdateOrganizationUnitInput implements IUpdateOrganizationUnitInput {
    id!: number | undefined;
    displayName!: string;

    constructor(data?: IUpdateOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): UpdateOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IUpdateOrganizationUnitInput {
    id: number | undefined;
    displayName: string;
}

export class MoveOrganizationUnitInput implements IMoveOrganizationUnitInput {
    id!: number | undefined;
    newParentId!: number | undefined;

    constructor(data?: IMoveOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.newParentId = data["newParentId"];
        }
    }

    static fromJS(data: any): MoveOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new MoveOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["newParentId"] = this.newParentId;
        return data; 
    }
}

export interface IMoveOrganizationUnitInput {
    id: number | undefined;
    newParentId: number | undefined;
}

export class UsersToOrganizationUnitInput implements IUsersToOrganizationUnitInput {
    userIds!: number[] | undefined;
    organizationUnitId!: number | undefined;

    constructor(data?: IUsersToOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["userIds"])) {
                this.userIds = [] as any;
                for (let item of data["userIds"])
                    this.userIds!.push(item);
            }
            this.organizationUnitId = data["organizationUnitId"];
        }
    }

    static fromJS(data: any): UsersToOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new UsersToOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.userIds)) {
            data["userIds"] = [];
            for (let item of this.userIds)
                data["userIds"].push(item);
        }
        data["organizationUnitId"] = this.organizationUnitId;
        return data; 
    }
}

export interface IUsersToOrganizationUnitInput {
    userIds: number[] | undefined;
    organizationUnitId: number | undefined;
}

export class RolesToOrganizationUnitInput implements IRolesToOrganizationUnitInput {
    roleIds!: number[] | undefined;
    organizationUnitId!: number | undefined;

    constructor(data?: IRolesToOrganizationUnitInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["roleIds"])) {
                this.roleIds = [] as any;
                for (let item of data["roleIds"])
                    this.roleIds!.push(item);
            }
            this.organizationUnitId = data["organizationUnitId"];
        }
    }

    static fromJS(data: any): RolesToOrganizationUnitInput {
        data = typeof data === 'object' ? data : {};
        let result = new RolesToOrganizationUnitInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.roleIds)) {
            data["roleIds"] = [];
            for (let item of this.roleIds)
                data["roleIds"].push(item);
        }
        data["organizationUnitId"] = this.organizationUnitId;
        return data; 
    }
}

export interface IRolesToOrganizationUnitInput {
    roleIds: number[] | undefined;
    organizationUnitId: number | undefined;
}

export class FindOrganizationUnitUsersInput implements IFindOrganizationUnitUsersInput {
    organizationUnitId!: number | undefined;
    maxResultCount!: number | undefined;
    skipCount!: number | undefined;
    filter!: string | undefined;

    constructor(data?: IFindOrganizationUnitUsersInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.organizationUnitId = data["organizationUnitId"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
            this.filter = data["filter"];
        }
    }

    static fromJS(data: any): FindOrganizationUnitUsersInput {
        data = typeof data === 'object' ? data : {};
        let result = new FindOrganizationUnitUsersInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationUnitId"] = this.organizationUnitId;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data; 
    }
}

export interface IFindOrganizationUnitUsersInput {
    organizationUnitId: number | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
    filter: string | undefined;
}

export class FindOrganizationUnitRolesInput implements IFindOrganizationUnitRolesInput {
    organizationUnitId!: number | undefined;
    maxResultCount!: number | undefined;
    skipCount!: number | undefined;
    filter!: string | undefined;

    constructor(data?: IFindOrganizationUnitRolesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.organizationUnitId = data["organizationUnitId"];
            this.maxResultCount = data["maxResultCount"];
            this.skipCount = data["skipCount"];
            this.filter = data["filter"];
        }
    }

    static fromJS(data: any): FindOrganizationUnitRolesInput {
        data = typeof data === 'object' ? data : {};
        let result = new FindOrganizationUnitRolesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["organizationUnitId"] = this.organizationUnitId;
        data["maxResultCount"] = this.maxResultCount;
        data["skipCount"] = this.skipCount;
        data["filter"] = this.filter;
        return data; 
    }
}

export interface IFindOrganizationUnitRolesInput {
    organizationUnitId: number | undefined;
    maxResultCount: number | undefined;
    skipCount: number | undefined;
    filter: string | undefined;
}

export class PaymentInfoDto implements IPaymentInfoDto {
    edition!: EditionSelectDto | undefined;
    additionalPrice!: number | undefined;

    constructor(data?: IPaymentInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.edition = data["edition"] ? EditionSelectDto.fromJS(data["edition"]) : <any>undefined;
            this.additionalPrice = data["additionalPrice"];
        }
    }

    static fromJS(data: any): PaymentInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        data["additionalPrice"] = this.additionalPrice;
        return data; 
    }
}

export interface IPaymentInfoDto {
    edition: EditionSelectDto | undefined;
    additionalPrice: number | undefined;
}

export class EditionSelectDto implements IEditionSelectDto {
    id!: number | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    expiringEditionId!: number | undefined;
    dailyPrice!: number | undefined;
    weeklyPrice!: number | undefined;
    monthlyPrice!: number | undefined;
    annualPrice!: number | undefined;
    trialDayCount!: number | undefined;
    waitingDayAfterExpire!: number | undefined;
    isFree!: boolean | undefined;
    additionalData!: AdditionalData | undefined;

    constructor(data?: IEditionSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.expiringEditionId = data["expiringEditionId"];
            this.dailyPrice = data["dailyPrice"];
            this.weeklyPrice = data["weeklyPrice"];
            this.monthlyPrice = data["monthlyPrice"];
            this.annualPrice = data["annualPrice"];
            this.trialDayCount = data["trialDayCount"];
            this.waitingDayAfterExpire = data["waitingDayAfterExpire"];
            this.isFree = data["isFree"];
            this.additionalData = data["additionalData"] ? AdditionalData.fromJS(data["additionalData"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EditionSelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["expiringEditionId"] = this.expiringEditionId;
        data["dailyPrice"] = this.dailyPrice;
        data["weeklyPrice"] = this.weeklyPrice;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["trialDayCount"] = this.trialDayCount;
        data["waitingDayAfterExpire"] = this.waitingDayAfterExpire;
        data["isFree"] = this.isFree;
        data["additionalData"] = this.additionalData ? this.additionalData.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IEditionSelectDto {
    id: number | undefined;
    name: string | undefined;
    displayName: string | undefined;
    expiringEditionId: number | undefined;
    dailyPrice: number | undefined;
    weeklyPrice: number | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    trialDayCount: number | undefined;
    waitingDayAfterExpire: number | undefined;
    isFree: boolean | undefined;
    additionalData: AdditionalData | undefined;
}

export class CreatePaymentDto implements ICreatePaymentDto {
    editionId!: number | undefined;
    editionPaymentType!: EditionPaymentType | undefined;
    paymentPeriodType!: PaymentPeriodType | undefined;
    subscriptionPaymentGatewayType!: SubscriptionPaymentGatewayType | undefined;
    recurringPaymentEnabled!: boolean | undefined;
    successUrl!: string | undefined;
    errorUrl!: string | undefined;

    constructor(data?: ICreatePaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.editionId = data["editionId"];
            this.editionPaymentType = data["editionPaymentType"];
            this.paymentPeriodType = data["paymentPeriodType"];
            this.subscriptionPaymentGatewayType = data["subscriptionPaymentGatewayType"];
            this.recurringPaymentEnabled = data["recurringPaymentEnabled"];
            this.successUrl = data["successUrl"];
            this.errorUrl = data["errorUrl"];
        }
    }

    static fromJS(data: any): CreatePaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreatePaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["editionId"] = this.editionId;
        data["editionPaymentType"] = this.editionPaymentType;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["subscriptionPaymentGatewayType"] = this.subscriptionPaymentGatewayType;
        data["recurringPaymentEnabled"] = this.recurringPaymentEnabled;
        data["successUrl"] = this.successUrl;
        data["errorUrl"] = this.errorUrl;
        return data; 
    }
}

export interface ICreatePaymentDto {
    editionId: number | undefined;
    editionPaymentType: EditionPaymentType | undefined;
    paymentPeriodType: PaymentPeriodType | undefined;
    subscriptionPaymentGatewayType: SubscriptionPaymentGatewayType | undefined;
    recurringPaymentEnabled: boolean | undefined;
    successUrl: string | undefined;
    errorUrl: string | undefined;
}

export enum PaymentPeriodType {
    Daily = 1,
    Weekly = 7,
    Monthly = 30,
    Annual = 365,
}

export enum EditionPaymentType {
    NewRegistration = 0,
    BuyNow = 1,
    Upgrade = 2,
    Extend = 3,
}

export enum SubscriptionPaymentGatewayType {
    Paypal = 1,
    Stripe = 2,
}

export class CancelPaymentDto implements ICancelPaymentDto {
    paymentId!: string | undefined;
    gateway!: SubscriptionPaymentGatewayType | undefined;

    constructor(data?: ICancelPaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.paymentId = data["paymentId"];
            this.gateway = data["gateway"];
        }
    }

    static fromJS(data: any): CancelPaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CancelPaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentId"] = this.paymentId;
        data["gateway"] = this.gateway;
        return data; 
    }
}

export interface ICancelPaymentDto {
    paymentId: string | undefined;
    gateway: SubscriptionPaymentGatewayType | undefined;
}

export class PagedResultDtoOfSubscriptionPaymentListDto implements IPagedResultDtoOfSubscriptionPaymentListDto {
    totalCount!: number | undefined;
    items!: SubscriptionPaymentListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfSubscriptionPaymentListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(SubscriptionPaymentListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSubscriptionPaymentListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSubscriptionPaymentListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfSubscriptionPaymentListDto {
    totalCount: number | undefined;
    items: SubscriptionPaymentListDto[] | undefined;
}

export class SubscriptionPaymentListDto implements ISubscriptionPaymentListDto {
    gateway!: string | undefined;
    amount!: number | undefined;
    editionId!: number | undefined;
    dayCount!: number | undefined;
    paymentPeriodType!: string | undefined;
    paymentId!: string | undefined;
    payerId!: string | undefined;
    status!: string | undefined;
    editionDisplayName!: string | undefined;
    tenantId!: number | undefined;
    invoiceNo!: string | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ISubscriptionPaymentListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.gateway = data["gateway"];
            this.amount = data["amount"];
            this.editionId = data["editionId"];
            this.dayCount = data["dayCount"];
            this.paymentPeriodType = data["paymentPeriodType"];
            this.paymentId = data["paymentId"];
            this.payerId = data["payerId"];
            this.status = data["status"];
            this.editionDisplayName = data["editionDisplayName"];
            this.tenantId = data["tenantId"];
            this.invoiceNo = data["invoiceNo"];
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SubscriptionPaymentListDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPaymentListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gateway"] = this.gateway;
        data["amount"] = this.amount;
        data["editionId"] = this.editionId;
        data["dayCount"] = this.dayCount;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["paymentId"] = this.paymentId;
        data["payerId"] = this.payerId;
        data["status"] = this.status;
        data["editionDisplayName"] = this.editionDisplayName;
        data["tenantId"] = this.tenantId;
        data["invoiceNo"] = this.invoiceNo;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISubscriptionPaymentListDto {
    gateway: string | undefined;
    amount: number | undefined;
    editionId: number | undefined;
    dayCount: number | undefined;
    paymentPeriodType: string | undefined;
    paymentId: string | undefined;
    payerId: string | undefined;
    status: string | undefined;
    editionDisplayName: string | undefined;
    tenantId: number | undefined;
    invoiceNo: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class PaymentGatewayModel implements IPaymentGatewayModel {
    gatewayType!: SubscriptionPaymentGatewayType | undefined;
    supportsRecurringPayments!: boolean | undefined;

    constructor(data?: IPaymentGatewayModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.gatewayType = data["gatewayType"];
            this.supportsRecurringPayments = data["supportsRecurringPayments"];
        }
    }

    static fromJS(data: any): PaymentGatewayModel {
        data = typeof data === 'object' ? data : {};
        let result = new PaymentGatewayModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["gatewayType"] = this.gatewayType;
        data["supportsRecurringPayments"] = this.supportsRecurringPayments;
        return data; 
    }
}

export interface IPaymentGatewayModel {
    gatewayType: SubscriptionPaymentGatewayType | undefined;
    supportsRecurringPayments: boolean | undefined;
}

export class SubscriptionPaymentDto implements ISubscriptionPaymentDto {
    description!: string | undefined;
    gateway!: SubscriptionPaymentGatewayType | undefined;
    amount!: number | undefined;
    editionId!: number | undefined;
    tenantId!: number | undefined;
    dayCount!: number | undefined;
    paymentPeriodType!: PaymentPeriodType | undefined;
    paymentId!: string | undefined;
    payerId!: string | undefined;
    editionDisplayName!: string | undefined;
    invoiceNo!: number | undefined;
    status!: SubscriptionPaymentStatus | undefined;
    isRecurring!: boolean | undefined;
    externalPaymentId!: string | undefined;
    successUrl!: string | undefined;
    errorUrl!: string | undefined;
    id!: number | undefined;

    constructor(data?: ISubscriptionPaymentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.description = data["description"];
            this.gateway = data["gateway"];
            this.amount = data["amount"];
            this.editionId = data["editionId"];
            this.tenantId = data["tenantId"];
            this.dayCount = data["dayCount"];
            this.paymentPeriodType = data["paymentPeriodType"];
            this.paymentId = data["paymentId"];
            this.payerId = data["payerId"];
            this.editionDisplayName = data["editionDisplayName"];
            this.invoiceNo = data["invoiceNo"];
            this.status = data["status"];
            this.isRecurring = data["isRecurring"];
            this.externalPaymentId = data["externalPaymentId"];
            this.successUrl = data["successUrl"];
            this.errorUrl = data["errorUrl"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SubscriptionPaymentDto {
        data = typeof data === 'object' ? data : {};
        let result = new SubscriptionPaymentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["gateway"] = this.gateway;
        data["amount"] = this.amount;
        data["editionId"] = this.editionId;
        data["tenantId"] = this.tenantId;
        data["dayCount"] = this.dayCount;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["paymentId"] = this.paymentId;
        data["payerId"] = this.payerId;
        data["editionDisplayName"] = this.editionDisplayName;
        data["invoiceNo"] = this.invoiceNo;
        data["status"] = this.status;
        data["isRecurring"] = this.isRecurring;
        data["externalPaymentId"] = this.externalPaymentId;
        data["successUrl"] = this.successUrl;
        data["errorUrl"] = this.errorUrl;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISubscriptionPaymentDto {
    description: string | undefined;
    gateway: SubscriptionPaymentGatewayType | undefined;
    amount: number | undefined;
    editionId: number | undefined;
    tenantId: number | undefined;
    dayCount: number | undefined;
    paymentPeriodType: PaymentPeriodType | undefined;
    paymentId: string | undefined;
    payerId: string | undefined;
    editionDisplayName: string | undefined;
    invoiceNo: number | undefined;
    status: SubscriptionPaymentStatus | undefined;
    isRecurring: boolean | undefined;
    externalPaymentId: string | undefined;
    successUrl: string | undefined;
    errorUrl: string | undefined;
    id: number | undefined;
}

export enum SubscriptionPaymentStatus {
    NotPaid = 1,
    Paid = 2,
    Failed = 3,
    Cancelled = 4,
    Completed = 5,
}

export class PayPalConfigurationDto implements IPayPalConfigurationDto {
    clientId!: string | undefined;
    demoUsername!: string | undefined;
    demoPassword!: string | undefined;

    constructor(data?: IPayPalConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.clientId = data["clientId"];
            this.demoUsername = data["demoUsername"];
            this.demoPassword = data["demoPassword"];
        }
    }

    static fromJS(data: any): PayPalConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new PayPalConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["clientId"] = this.clientId;
        data["demoUsername"] = this.demoUsername;
        data["demoPassword"] = this.demoPassword;
        return data; 
    }
}

export interface IPayPalConfigurationDto {
    clientId: string | undefined;
    demoUsername: string | undefined;
    demoPassword: string | undefined;
}

export class ListResultDtoOfFlatPermissionWithLevelDto implements IListResultDtoOfFlatPermissionWithLevelDto {
    items!: FlatPermissionWithLevelDto[] | undefined;

    constructor(data?: IListResultDtoOfFlatPermissionWithLevelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(FlatPermissionWithLevelDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfFlatPermissionWithLevelDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfFlatPermissionWithLevelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfFlatPermissionWithLevelDto {
    items: FlatPermissionWithLevelDto[] | undefined;
}

export class FlatPermissionWithLevelDto implements IFlatPermissionWithLevelDto {
    level!: number | undefined;
    parentName!: string | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;
    isGrantedByDefault!: boolean | undefined;

    constructor(data?: IFlatPermissionWithLevelDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.level = data["level"];
            this.parentName = data["parentName"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.isGrantedByDefault = data["isGrantedByDefault"];
        }
    }

    static fromJS(data: any): FlatPermissionWithLevelDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionWithLevelDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["level"] = this.level;
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isGrantedByDefault"] = this.isGrantedByDefault;
        return data; 
    }
}

export interface IFlatPermissionWithLevelDto {
    level: number | undefined;
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isGrantedByDefault: boolean | undefined;
}

export class CurrentUserProfileEditDto implements ICurrentUserProfileEditDto {
    name!: string;
    surname!: string;
    userName!: string;
    emailAddress!: string;
    phoneNumber!: string | undefined;
    isPhoneNumberConfirmed!: boolean | undefined;
    timezone!: string | undefined;
    qrCodeSetupImageUrl!: string | undefined;
    isGoogleAuthenticatorEnabled!: boolean | undefined;

    constructor(data?: ICurrentUserProfileEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.phoneNumber = data["phoneNumber"];
            this.isPhoneNumberConfirmed = data["isPhoneNumberConfirmed"];
            this.timezone = data["timezone"];
            this.qrCodeSetupImageUrl = data["qrCodeSetupImageUrl"];
            this.isGoogleAuthenticatorEnabled = data["isGoogleAuthenticatorEnabled"];
        }
    }

    static fromJS(data: any): CurrentUserProfileEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentUserProfileEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["isPhoneNumberConfirmed"] = this.isPhoneNumberConfirmed;
        data["timezone"] = this.timezone;
        data["qrCodeSetupImageUrl"] = this.qrCodeSetupImageUrl;
        data["isGoogleAuthenticatorEnabled"] = this.isGoogleAuthenticatorEnabled;
        return data; 
    }
}

export interface ICurrentUserProfileEditDto {
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    phoneNumber: string | undefined;
    isPhoneNumberConfirmed: boolean | undefined;
    timezone: string | undefined;
    qrCodeSetupImageUrl: string | undefined;
    isGoogleAuthenticatorEnabled: boolean | undefined;
}

export class UpdateGoogleAuthenticatorKeyOutput implements IUpdateGoogleAuthenticatorKeyOutput {
    qrCodeSetupImageUrl!: string | undefined;

    constructor(data?: IUpdateGoogleAuthenticatorKeyOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.qrCodeSetupImageUrl = data["qrCodeSetupImageUrl"];
        }
    }

    static fromJS(data: any): UpdateGoogleAuthenticatorKeyOutput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateGoogleAuthenticatorKeyOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["qrCodeSetupImageUrl"] = this.qrCodeSetupImageUrl;
        return data; 
    }
}

export interface IUpdateGoogleAuthenticatorKeyOutput {
    qrCodeSetupImageUrl: string | undefined;
}

export class SendVerificationSmsInputDto implements ISendVerificationSmsInputDto {
    phoneNumber!: string | undefined;

    constructor(data?: ISendVerificationSmsInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.phoneNumber = data["phoneNumber"];
        }
    }

    static fromJS(data: any): SendVerificationSmsInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new SendVerificationSmsInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["phoneNumber"] = this.phoneNumber;
        return data; 
    }
}

export interface ISendVerificationSmsInputDto {
    phoneNumber: string | undefined;
}

export class VerifySmsCodeInputDto implements IVerifySmsCodeInputDto {
    code!: string | undefined;
    phoneNumber!: string | undefined;

    constructor(data?: IVerifySmsCodeInputDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.phoneNumber = data["phoneNumber"];
        }
    }

    static fromJS(data: any): VerifySmsCodeInputDto {
        data = typeof data === 'object' ? data : {};
        let result = new VerifySmsCodeInputDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["phoneNumber"] = this.phoneNumber;
        return data; 
    }
}

export interface IVerifySmsCodeInputDto {
    code: string | undefined;
    phoneNumber: string | undefined;
}

export class ChangePasswordInput implements IChangePasswordInput {
    currentPassword!: string;
    newPassword!: string;

    constructor(data?: IChangePasswordInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.currentPassword = data["currentPassword"];
            this.newPassword = data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordInput {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        return data; 
    }
}

export interface IChangePasswordInput {
    currentPassword: string;
    newPassword: string;
}

export class UpdateProfilePictureInput implements IUpdateProfilePictureInput {
    fileToken!: string;
    x!: number | undefined;
    y!: number | undefined;
    width!: number | undefined;
    height!: number | undefined;

    constructor(data?: IUpdateProfilePictureInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fileToken = data["fileToken"];
            this.x = data["x"];
            this.y = data["y"];
            this.width = data["width"];
            this.height = data["height"];
        }
    }

    static fromJS(data: any): UpdateProfilePictureInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateProfilePictureInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileToken"] = this.fileToken;
        data["x"] = this.x;
        data["y"] = this.y;
        data["width"] = this.width;
        data["height"] = this.height;
        return data; 
    }
}

export interface IUpdateProfilePictureInput {
    fileToken: string;
    x: number | undefined;
    y: number | undefined;
    width: number | undefined;
    height: number | undefined;
}

export class GetPasswordComplexitySettingOutput implements IGetPasswordComplexitySettingOutput {
    setting!: PasswordComplexitySetting | undefined;

    constructor(data?: IGetPasswordComplexitySettingOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.setting = data["setting"] ? PasswordComplexitySetting.fromJS(data["setting"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetPasswordComplexitySettingOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetPasswordComplexitySettingOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["setting"] = this.setting ? this.setting.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetPasswordComplexitySettingOutput {
    setting: PasswordComplexitySetting | undefined;
}

export class GetProfilePictureOutput implements IGetProfilePictureOutput {
    profilePicture!: string | undefined;

    constructor(data?: IGetProfilePictureOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.profilePicture = data["profilePicture"];
        }
    }

    static fromJS(data: any): GetProfilePictureOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetProfilePictureOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["profilePicture"] = this.profilePicture;
        return data; 
    }
}

export interface IGetProfilePictureOutput {
    profilePicture: string | undefined;
}

export class ChangeUserLanguageDto implements IChangeUserLanguageDto {
    languageName!: string;

    constructor(data?: IChangeUserLanguageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.languageName = data["languageName"];
        }
    }

    static fromJS(data: any): ChangeUserLanguageDto {
        data = typeof data === 'object' ? data : {};
        let result = new ChangeUserLanguageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["languageName"] = this.languageName;
        return data; 
    }
}

export interface IChangeUserLanguageDto {
    languageName: string;
}

export class GetQuotationDetailForEditOutput implements IGetQuotationDetailForEditOutput {
    quotationDetail!: CreateOrEditQuotationDetailDto | undefined;
    itemTypeType!: string | undefined;
    quotationTitle!: string | undefined;
    uomUnitOfMeasurement!: string | undefined;

    constructor(data?: IGetQuotationDetailForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.quotationDetail = data["quotationDetail"] ? CreateOrEditQuotationDetailDto.fromJS(data["quotationDetail"]) : <any>undefined;
            this.itemTypeType = data["itemTypeType"];
            this.quotationTitle = data["quotationTitle"];
            this.uomUnitOfMeasurement = data["uomUnitOfMeasurement"];
        }
    }

    static fromJS(data: any): GetQuotationDetailForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetQuotationDetailForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["quotationDetail"] = this.quotationDetail ? this.quotationDetail.toJSON() : <any>undefined;
        data["itemTypeType"] = this.itemTypeType;
        data["quotationTitle"] = this.quotationTitle;
        data["uomUnitOfMeasurement"] = this.uomUnitOfMeasurement;
        return data; 
    }
}

export interface IGetQuotationDetailForEditOutput {
    quotationDetail: CreateOrEditQuotationDetailDto | undefined;
    itemTypeType: string | undefined;
    quotationTitle: string | undefined;
    uomUnitOfMeasurement: string | undefined;
}

export class CreateOrEditQuotationDetailDto implements ICreateOrEditQuotationDetailDto {
    description!: string;
    quantity!: number | undefined;
    unitPrice!: number | undefined;
    cost!: number | undefined;
    tax!: number | undefined;
    charge!: number | undefined;
    discount!: number | undefined;
    markUp!: number | undefined;
    isTaxable!: boolean | undefined;
    isChargeable!: boolean | undefined;
    isAdHoc!: boolean | undefined;
    isStandbyReplacementUnit!: boolean | undefined;
    isOptionalItem!: boolean | undefined;
    remark!: string | undefined;
    loc8GUID!: string | undefined;
    itemTypeId!: number | undefined;
    quotationId!: number | undefined;
    uomId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditQuotationDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.description = data["description"];
            this.quantity = data["quantity"];
            this.unitPrice = data["unitPrice"];
            this.cost = data["cost"];
            this.tax = data["tax"];
            this.charge = data["charge"];
            this.discount = data["discount"];
            this.markUp = data["markUp"];
            this.isTaxable = data["isTaxable"];
            this.isChargeable = data["isChargeable"];
            this.isAdHoc = data["isAdHoc"];
            this.isStandbyReplacementUnit = data["isStandbyReplacementUnit"];
            this.isOptionalItem = data["isOptionalItem"];
            this.remark = data["remark"];
            this.loc8GUID = data["loc8GUID"];
            this.itemTypeId = data["itemTypeId"];
            this.quotationId = data["quotationId"];
            this.uomId = data["uomId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditQuotationDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditQuotationDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["quantity"] = this.quantity;
        data["unitPrice"] = this.unitPrice;
        data["cost"] = this.cost;
        data["tax"] = this.tax;
        data["charge"] = this.charge;
        data["discount"] = this.discount;
        data["markUp"] = this.markUp;
        data["isTaxable"] = this.isTaxable;
        data["isChargeable"] = this.isChargeable;
        data["isAdHoc"] = this.isAdHoc;
        data["isStandbyReplacementUnit"] = this.isStandbyReplacementUnit;
        data["isOptionalItem"] = this.isOptionalItem;
        data["remark"] = this.remark;
        data["loc8GUID"] = this.loc8GUID;
        data["itemTypeId"] = this.itemTypeId;
        data["quotationId"] = this.quotationId;
        data["uomId"] = this.uomId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditQuotationDetailDto {
    description: string;
    quantity: number | undefined;
    unitPrice: number | undefined;
    cost: number | undefined;
    tax: number | undefined;
    charge: number | undefined;
    discount: number | undefined;
    markUp: number | undefined;
    isTaxable: boolean | undefined;
    isChargeable: boolean | undefined;
    isAdHoc: boolean | undefined;
    isStandbyReplacementUnit: boolean | undefined;
    isOptionalItem: boolean | undefined;
    remark: string | undefined;
    loc8GUID: string | undefined;
    itemTypeId: number | undefined;
    quotationId: number | undefined;
    uomId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfQuotationDetailQuotationLookupTableDto implements IPagedResultDtoOfQuotationDetailQuotationLookupTableDto {
    totalCount!: number | undefined;
    items!: QuotationDetailQuotationLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfQuotationDetailQuotationLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(QuotationDetailQuotationLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfQuotationDetailQuotationLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfQuotationDetailQuotationLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfQuotationDetailQuotationLookupTableDto {
    totalCount: number | undefined;
    items: QuotationDetailQuotationLookupTableDto[] | undefined;
}

export class QuotationDetailQuotationLookupTableDto implements IQuotationDetailQuotationLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IQuotationDetailQuotationLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): QuotationDetailQuotationLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuotationDetailQuotationLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IQuotationDetailQuotationLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfQuotationDetailWorkOrderLookupTableDto implements IPagedResultDtoOfQuotationDetailWorkOrderLookupTableDto {
    totalCount!: number | undefined;
    items!: QuotationDetailWorkOrderLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfQuotationDetailWorkOrderLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(QuotationDetailWorkOrderLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfQuotationDetailWorkOrderLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfQuotationDetailWorkOrderLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfQuotationDetailWorkOrderLookupTableDto {
    totalCount: number | undefined;
    items: QuotationDetailWorkOrderLookupTableDto[] | undefined;
}

export class QuotationDetailWorkOrderLookupTableDto implements IQuotationDetailWorkOrderLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IQuotationDetailWorkOrderLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): QuotationDetailWorkOrderLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuotationDetailWorkOrderLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IQuotationDetailWorkOrderLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class QuotationPdfDto implements IQuotationPdfDto {
    assetOwnerInfo!: AssetOwnerDto | undefined;
    assetOwnerAddress!: AddressDto | undefined;
    assetOwnerContact!: ContactDto | undefined;
    quotationInfo!: QuotationDto | undefined;
    quotationDetailList!: PdfQuotationDetailListDto | undefined;
    vendorInfo!: VendorDto | undefined;
    vendorAddress!: AddressDto | undefined;
    vendorContact!: ContactDto | undefined;
    authenticationKey!: string | undefined;

    constructor(data?: IQuotationPdfDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.assetOwnerInfo = data["assetOwnerInfo"] ? AssetOwnerDto.fromJS(data["assetOwnerInfo"]) : <any>undefined;
            this.assetOwnerAddress = data["assetOwnerAddress"] ? AddressDto.fromJS(data["assetOwnerAddress"]) : <any>undefined;
            this.assetOwnerContact = data["assetOwnerContact"] ? ContactDto.fromJS(data["assetOwnerContact"]) : <any>undefined;
            this.quotationInfo = data["quotationInfo"] ? QuotationDto.fromJS(data["quotationInfo"]) : <any>undefined;
            this.quotationDetailList = data["quotationDetailList"] ? PdfQuotationDetailListDto.fromJS(data["quotationDetailList"]) : <any>undefined;
            this.vendorInfo = data["vendorInfo"] ? VendorDto.fromJS(data["vendorInfo"]) : <any>undefined;
            this.vendorAddress = data["vendorAddress"] ? AddressDto.fromJS(data["vendorAddress"]) : <any>undefined;
            this.vendorContact = data["vendorContact"] ? ContactDto.fromJS(data["vendorContact"]) : <any>undefined;
            this.authenticationKey = data["authenticationKey"];
        }
    }

    static fromJS(data: any): QuotationPdfDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuotationPdfDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["assetOwnerInfo"] = this.assetOwnerInfo ? this.assetOwnerInfo.toJSON() : <any>undefined;
        data["assetOwnerAddress"] = this.assetOwnerAddress ? this.assetOwnerAddress.toJSON() : <any>undefined;
        data["assetOwnerContact"] = this.assetOwnerContact ? this.assetOwnerContact.toJSON() : <any>undefined;
        data["quotationInfo"] = this.quotationInfo ? this.quotationInfo.toJSON() : <any>undefined;
        data["quotationDetailList"] = this.quotationDetailList ? this.quotationDetailList.toJSON() : <any>undefined;
        data["vendorInfo"] = this.vendorInfo ? this.vendorInfo.toJSON() : <any>undefined;
        data["vendorAddress"] = this.vendorAddress ? this.vendorAddress.toJSON() : <any>undefined;
        data["vendorContact"] = this.vendorContact ? this.vendorContact.toJSON() : <any>undefined;
        data["authenticationKey"] = this.authenticationKey;
        return data; 
    }
}

export interface IQuotationPdfDto {
    assetOwnerInfo: AssetOwnerDto | undefined;
    assetOwnerAddress: AddressDto | undefined;
    assetOwnerContact: ContactDto | undefined;
    quotationInfo: QuotationDto | undefined;
    quotationDetailList: PdfQuotationDetailListDto | undefined;
    vendorInfo: VendorDto | undefined;
    vendorAddress: AddressDto | undefined;
    vendorContact: ContactDto | undefined;
    authenticationKey: string | undefined;
}

export class PdfQuotationDetailListDto implements IPdfQuotationDetailListDto {
    detailList!: PdfQuotationDetailForViewDto[] | undefined;
    totalTax!: number | undefined;
    totalAmount!: number | undefined;

    constructor(data?: IPdfQuotationDetailListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["detailList"])) {
                this.detailList = [] as any;
                for (let item of data["detailList"])
                    this.detailList!.push(PdfQuotationDetailForViewDto.fromJS(item));
            }
            this.totalTax = data["totalTax"];
            this.totalAmount = data["totalAmount"];
        }
    }

    static fromJS(data: any): PdfQuotationDetailListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PdfQuotationDetailListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.detailList)) {
            data["detailList"] = [];
            for (let item of this.detailList)
                data["detailList"].push(item.toJSON());
        }
        data["totalTax"] = this.totalTax;
        data["totalAmount"] = this.totalAmount;
        return data; 
    }
}

export interface IPdfQuotationDetailListDto {
    detailList: PdfQuotationDetailForViewDto[] | undefined;
    totalTax: number | undefined;
    totalAmount: number | undefined;
}

export class VendorDto implements IVendorDto {
    reference!: string | undefined;
    name!: string | undefined;
    identifier!: string | undefined;
    logoUrl!: string | undefined;
    website!: string | undefined;
    vendorLoc8GUID!: string | undefined;
    ssicCodeId!: number | undefined;
    currencyId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IVendorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reference = data["reference"];
            this.name = data["name"];
            this.identifier = data["identifier"];
            this.logoUrl = data["logoUrl"];
            this.website = data["website"];
            this.vendorLoc8GUID = data["vendorLoc8GUID"];
            this.ssicCodeId = data["ssicCodeId"];
            this.currencyId = data["currencyId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): VendorDto {
        data = typeof data === 'object' ? data : {};
        let result = new VendorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reference"] = this.reference;
        data["name"] = this.name;
        data["identifier"] = this.identifier;
        data["logoUrl"] = this.logoUrl;
        data["website"] = this.website;
        data["vendorLoc8GUID"] = this.vendorLoc8GUID;
        data["ssicCodeId"] = this.ssicCodeId;
        data["currencyId"] = this.currencyId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IVendorDto {
    reference: string | undefined;
    name: string | undefined;
    identifier: string | undefined;
    logoUrl: string | undefined;
    website: string | undefined;
    vendorLoc8GUID: string | undefined;
    ssicCodeId: number | undefined;
    currencyId: number | undefined;
    id: number | undefined;
}

export class PdfQuotationDetailForViewDto implements IPdfQuotationDetailForViewDto {
    quotationDetail!: PdfQuotationDetailDto | undefined;
    itemTypeType!: string | undefined;
    uomUnitOfMeasurement!: string | undefined;

    constructor(data?: IPdfQuotationDetailForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.quotationDetail = data["quotationDetail"] ? PdfQuotationDetailDto.fromJS(data["quotationDetail"]) : <any>undefined;
            this.itemTypeType = data["itemTypeType"];
            this.uomUnitOfMeasurement = data["uomUnitOfMeasurement"];
        }
    }

    static fromJS(data: any): PdfQuotationDetailForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PdfQuotationDetailForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["quotationDetail"] = this.quotationDetail ? this.quotationDetail.toJSON() : <any>undefined;
        data["itemTypeType"] = this.itemTypeType;
        data["uomUnitOfMeasurement"] = this.uomUnitOfMeasurement;
        return data; 
    }
}

export interface IPdfQuotationDetailForViewDto {
    quotationDetail: PdfQuotationDetailDto | undefined;
    itemTypeType: string | undefined;
    uomUnitOfMeasurement: string | undefined;
}

export class PdfQuotationDetailDto implements IPdfQuotationDetailDto {
    id!: number | undefined;
    quotationId!: number | undefined;
    description!: string | undefined;
    quantity!: number | undefined;
    calculatedUnitPrice!: number | undefined;
    calculatedAmount!: number | undefined;
    unitPrice!: number | undefined;
    cost!: number | undefined;
    tax!: number | undefined;
    charge!: number | undefined;
    discount!: number | undefined;
    markUp!: number | undefined;
    remark!: string | undefined;

    constructor(data?: IPdfQuotationDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.quotationId = data["quotationId"];
            this.description = data["description"];
            this.quantity = data["quantity"];
            this.calculatedUnitPrice = data["calculatedUnitPrice"];
            this.calculatedAmount = data["calculatedAmount"];
            this.unitPrice = data["unitPrice"];
            this.cost = data["cost"];
            this.tax = data["tax"];
            this.charge = data["charge"];
            this.discount = data["discount"];
            this.markUp = data["markUp"];
            this.remark = data["remark"];
        }
    }

    static fromJS(data: any): PdfQuotationDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new PdfQuotationDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["quotationId"] = this.quotationId;
        data["description"] = this.description;
        data["quantity"] = this.quantity;
        data["calculatedUnitPrice"] = this.calculatedUnitPrice;
        data["calculatedAmount"] = this.calculatedAmount;
        data["unitPrice"] = this.unitPrice;
        data["cost"] = this.cost;
        data["tax"] = this.tax;
        data["charge"] = this.charge;
        data["discount"] = this.discount;
        data["markUp"] = this.markUp;
        data["remark"] = this.remark;
        return data; 
    }
}

export interface IPdfQuotationDetailDto {
    id: number | undefined;
    quotationId: number | undefined;
    description: string | undefined;
    quantity: number | undefined;
    calculatedUnitPrice: number | undefined;
    calculatedAmount: number | undefined;
    unitPrice: number | undefined;
    cost: number | undefined;
    tax: number | undefined;
    charge: number | undefined;
    discount: number | undefined;
    markUp: number | undefined;
    remark: string | undefined;
}

export class PagedResultDtoOfGetQuotationForViewDto implements IPagedResultDtoOfGetQuotationForViewDto {
    totalCount!: number | undefined;
    items!: GetQuotationForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetQuotationForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetQuotationForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetQuotationForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetQuotationForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetQuotationForViewDto {
    totalCount: number | undefined;
    items: GetQuotationForViewDto[] | undefined;
}

export class GetQuotationForEditOutput implements IGetQuotationForEditOutput {
    quotation!: CreateOrEditQuotationDto | undefined;
    supportContractTitle!: string | undefined;
    quotationStatusStatus!: string | undefined;
    workOrderSubject!: string | undefined;
    assetReference!: string | undefined;
    assetClassClass!: string | undefined;
    supportTypeType!: string | undefined;
    supportItemDescription!: string | undefined;
    aO_Address!: AddressDto | undefined;

    constructor(data?: IGetQuotationForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.quotation = data["quotation"] ? CreateOrEditQuotationDto.fromJS(data["quotation"]) : <any>undefined;
            this.supportContractTitle = data["supportContractTitle"];
            this.quotationStatusStatus = data["quotationStatusStatus"];
            this.workOrderSubject = data["workOrderSubject"];
            this.assetReference = data["assetReference"];
            this.assetClassClass = data["assetClassClass"];
            this.supportTypeType = data["supportTypeType"];
            this.supportItemDescription = data["supportItemDescription"];
            this.aO_Address = data["aO_Address"] ? AddressDto.fromJS(data["aO_Address"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetQuotationForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetQuotationForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["quotation"] = this.quotation ? this.quotation.toJSON() : <any>undefined;
        data["supportContractTitle"] = this.supportContractTitle;
        data["quotationStatusStatus"] = this.quotationStatusStatus;
        data["workOrderSubject"] = this.workOrderSubject;
        data["assetReference"] = this.assetReference;
        data["assetClassClass"] = this.assetClassClass;
        data["supportTypeType"] = this.supportTypeType;
        data["supportItemDescription"] = this.supportItemDescription;
        data["aO_Address"] = this.aO_Address ? this.aO_Address.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetQuotationForEditOutput {
    quotation: CreateOrEditQuotationDto | undefined;
    supportContractTitle: string | undefined;
    quotationStatusStatus: string | undefined;
    workOrderSubject: string | undefined;
    assetReference: string | undefined;
    assetClassClass: string | undefined;
    supportTypeType: string | undefined;
    supportItemDescription: string | undefined;
    aO_Address: AddressDto | undefined;
}

export class CreateOrEditQuotationDto implements ICreateOrEditQuotationDto {
    reference!: string;
    title!: string;
    description!: string | undefined;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    totalTax!: number | undefined;
    totalPrice!: number | undefined;
    totalDiscount!: number | undefined;
    totalCharge!: number | undefined;
    version!: number | undefined;
    isFinal!: boolean | undefined;
    remark!: string | undefined;
    requoteRefId!: number | undefined;
    quotationLoc8GUID!: string | undefined;
    acknowledgedBy!: string | undefined;
    acknowledgedAt!: moment.Moment | undefined;
    supportContractId!: number | undefined;
    quotationStatusId!: number | undefined;
    workOrderId!: number | undefined;
    assetId!: number | undefined;
    assetClassId!: number | undefined;
    supportTypeId!: number | undefined;
    supportItemId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditQuotationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reference = data["reference"];
            this.title = data["title"];
            this.description = data["description"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.totalTax = data["totalTax"];
            this.totalPrice = data["totalPrice"];
            this.totalDiscount = data["totalDiscount"];
            this.totalCharge = data["totalCharge"];
            this.version = data["version"];
            this.isFinal = data["isFinal"];
            this.remark = data["remark"];
            this.requoteRefId = data["requoteRefId"];
            this.quotationLoc8GUID = data["quotationLoc8GUID"];
            this.acknowledgedBy = data["acknowledgedBy"];
            this.acknowledgedAt = data["acknowledgedAt"] ? moment(data["acknowledgedAt"].toString()) : <any>undefined;
            this.supportContractId = data["supportContractId"];
            this.quotationStatusId = data["quotationStatusId"];
            this.workOrderId = data["workOrderId"];
            this.assetId = data["assetId"];
            this.assetClassId = data["assetClassId"];
            this.supportTypeId = data["supportTypeId"];
            this.supportItemId = data["supportItemId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditQuotationDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditQuotationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reference"] = this.reference;
        data["title"] = this.title;
        data["description"] = this.description;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["totalTax"] = this.totalTax;
        data["totalPrice"] = this.totalPrice;
        data["totalDiscount"] = this.totalDiscount;
        data["totalCharge"] = this.totalCharge;
        data["version"] = this.version;
        data["isFinal"] = this.isFinal;
        data["remark"] = this.remark;
        data["requoteRefId"] = this.requoteRefId;
        data["quotationLoc8GUID"] = this.quotationLoc8GUID;
        data["acknowledgedBy"] = this.acknowledgedBy;
        data["acknowledgedAt"] = this.acknowledgedAt ? this.acknowledgedAt.toISOString() : <any>undefined;
        data["supportContractId"] = this.supportContractId;
        data["quotationStatusId"] = this.quotationStatusId;
        data["workOrderId"] = this.workOrderId;
        data["assetId"] = this.assetId;
        data["assetClassId"] = this.assetClassId;
        data["supportTypeId"] = this.supportTypeId;
        data["supportItemId"] = this.supportItemId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditQuotationDto {
    reference: string;
    title: string;
    description: string | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    totalTax: number | undefined;
    totalPrice: number | undefined;
    totalDiscount: number | undefined;
    totalCharge: number | undefined;
    version: number | undefined;
    isFinal: boolean | undefined;
    remark: string | undefined;
    requoteRefId: number | undefined;
    quotationLoc8GUID: string | undefined;
    acknowledgedBy: string | undefined;
    acknowledgedAt: moment.Moment | undefined;
    supportContractId: number | undefined;
    quotationStatusId: number | undefined;
    workOrderId: number | undefined;
    assetId: number | undefined;
    assetClassId: number | undefined;
    supportTypeId: number | undefined;
    supportItemId: number | undefined;
    id: number | undefined;
}

export class CreateQuotationWithDetailDto implements ICreateQuotationWithDetailDto {
    reference!: string;
    title!: string;
    quotationDescription!: string | undefined;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    totalTax!: number | undefined;
    totalPrice!: number | undefined;
    totalDiscount!: number | undefined;
    totalCharge!: number | undefined;
    version!: number | undefined;
    isFinal!: boolean | undefined;
    quotationRemark!: string | undefined;
    requoteRefId!: number | undefined;
    quotationLoc8GUID!: string | undefined;
    quotationAttachments!: string | undefined;
    acknowledgedBy!: string | undefined;
    acknowledgedAt!: moment.Moment | undefined;
    supportContractId!: number | undefined;
    quotationStatusId!: number | undefined;
    rfqId!: number | undefined;
    detailDescription!: string;
    quantity!: number | undefined;
    unitPrice!: number | undefined;
    cost!: number | undefined;
    tax!: number | undefined;
    charge!: number | undefined;
    discount!: number | undefined;
    markUp!: number | undefined;
    isChargeable!: boolean | undefined;
    isTaxable!: boolean | undefined;
    isAdHoc!: boolean | undefined;
    isStandbyReplacementUnit!: boolean | undefined;
    isOptionalItem!: boolean | undefined;
    detailRemark!: string | undefined;
    detailLoc8GUID!: string | undefined;
    detailAttachments!: string | undefined;
    assetId!: number | undefined;
    assetClassId!: number | undefined;
    itemTypeId!: number | undefined;
    supportTypeId!: number | undefined;
    quotationId!: number | undefined;
    uomId!: number | undefined;
    supportItemId!: number | undefined;
    workOrderId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateQuotationWithDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reference = data["reference"];
            this.title = data["title"];
            this.quotationDescription = data["quotationDescription"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.totalTax = data["totalTax"];
            this.totalPrice = data["totalPrice"];
            this.totalDiscount = data["totalDiscount"];
            this.totalCharge = data["totalCharge"];
            this.version = data["version"];
            this.isFinal = data["isFinal"];
            this.quotationRemark = data["quotationRemark"];
            this.requoteRefId = data["requoteRefId"];
            this.quotationLoc8GUID = data["quotationLoc8GUID"];
            this.quotationAttachments = data["quotationAttachments"];
            this.acknowledgedBy = data["acknowledgedBy"];
            this.acknowledgedAt = data["acknowledgedAt"] ? moment(data["acknowledgedAt"].toString()) : <any>undefined;
            this.supportContractId = data["supportContractId"];
            this.quotationStatusId = data["quotationStatusId"];
            this.rfqId = data["rfqId"];
            this.detailDescription = data["detailDescription"];
            this.quantity = data["quantity"];
            this.unitPrice = data["unitPrice"];
            this.cost = data["cost"];
            this.tax = data["tax"];
            this.charge = data["charge"];
            this.discount = data["discount"];
            this.markUp = data["markUp"];
            this.isChargeable = data["isChargeable"];
            this.isTaxable = data["isTaxable"];
            this.isAdHoc = data["isAdHoc"];
            this.isStandbyReplacementUnit = data["isStandbyReplacementUnit"];
            this.isOptionalItem = data["isOptionalItem"];
            this.detailRemark = data["detailRemark"];
            this.detailLoc8GUID = data["detailLoc8GUID"];
            this.detailAttachments = data["detailAttachments"];
            this.assetId = data["assetId"];
            this.assetClassId = data["assetClassId"];
            this.itemTypeId = data["itemTypeId"];
            this.supportTypeId = data["supportTypeId"];
            this.quotationId = data["quotationId"];
            this.uomId = data["uomId"];
            this.supportItemId = data["supportItemId"];
            this.workOrderId = data["workOrderId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateQuotationWithDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateQuotationWithDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reference"] = this.reference;
        data["title"] = this.title;
        data["quotationDescription"] = this.quotationDescription;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["totalTax"] = this.totalTax;
        data["totalPrice"] = this.totalPrice;
        data["totalDiscount"] = this.totalDiscount;
        data["totalCharge"] = this.totalCharge;
        data["version"] = this.version;
        data["isFinal"] = this.isFinal;
        data["quotationRemark"] = this.quotationRemark;
        data["requoteRefId"] = this.requoteRefId;
        data["quotationLoc8GUID"] = this.quotationLoc8GUID;
        data["quotationAttachments"] = this.quotationAttachments;
        data["acknowledgedBy"] = this.acknowledgedBy;
        data["acknowledgedAt"] = this.acknowledgedAt ? this.acknowledgedAt.toISOString() : <any>undefined;
        data["supportContractId"] = this.supportContractId;
        data["quotationStatusId"] = this.quotationStatusId;
        data["rfqId"] = this.rfqId;
        data["detailDescription"] = this.detailDescription;
        data["quantity"] = this.quantity;
        data["unitPrice"] = this.unitPrice;
        data["cost"] = this.cost;
        data["tax"] = this.tax;
        data["charge"] = this.charge;
        data["discount"] = this.discount;
        data["markUp"] = this.markUp;
        data["isChargeable"] = this.isChargeable;
        data["isTaxable"] = this.isTaxable;
        data["isAdHoc"] = this.isAdHoc;
        data["isStandbyReplacementUnit"] = this.isStandbyReplacementUnit;
        data["isOptionalItem"] = this.isOptionalItem;
        data["detailRemark"] = this.detailRemark;
        data["detailLoc8GUID"] = this.detailLoc8GUID;
        data["detailAttachments"] = this.detailAttachments;
        data["assetId"] = this.assetId;
        data["assetClassId"] = this.assetClassId;
        data["itemTypeId"] = this.itemTypeId;
        data["supportTypeId"] = this.supportTypeId;
        data["quotationId"] = this.quotationId;
        data["uomId"] = this.uomId;
        data["supportItemId"] = this.supportItemId;
        data["workOrderId"] = this.workOrderId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateQuotationWithDetailDto {
    reference: string;
    title: string;
    quotationDescription: string | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    totalTax: number | undefined;
    totalPrice: number | undefined;
    totalDiscount: number | undefined;
    totalCharge: number | undefined;
    version: number | undefined;
    isFinal: boolean | undefined;
    quotationRemark: string | undefined;
    requoteRefId: number | undefined;
    quotationLoc8GUID: string | undefined;
    quotationAttachments: string | undefined;
    acknowledgedBy: string | undefined;
    acknowledgedAt: moment.Moment | undefined;
    supportContractId: number | undefined;
    quotationStatusId: number | undefined;
    rfqId: number | undefined;
    detailDescription: string;
    quantity: number | undefined;
    unitPrice: number | undefined;
    cost: number | undefined;
    tax: number | undefined;
    charge: number | undefined;
    discount: number | undefined;
    markUp: number | undefined;
    isChargeable: boolean | undefined;
    isTaxable: boolean | undefined;
    isAdHoc: boolean | undefined;
    isStandbyReplacementUnit: boolean | undefined;
    isOptionalItem: boolean | undefined;
    detailRemark: string | undefined;
    detailLoc8GUID: string | undefined;
    detailAttachments: string | undefined;
    assetId: number | undefined;
    assetClassId: number | undefined;
    itemTypeId: number | undefined;
    supportTypeId: number | undefined;
    quotationId: number | undefined;
    uomId: number | undefined;
    supportItemId: number | undefined;
    workOrderId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfQuotationSupportContractLookupTableDto implements IPagedResultDtoOfQuotationSupportContractLookupTableDto {
    totalCount!: number | undefined;
    items!: QuotationSupportContractLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfQuotationSupportContractLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(QuotationSupportContractLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfQuotationSupportContractLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfQuotationSupportContractLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfQuotationSupportContractLookupTableDto {
    totalCount: number | undefined;
    items: QuotationSupportContractLookupTableDto[] | undefined;
}

export class QuotationSupportContractLookupTableDto implements IQuotationSupportContractLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IQuotationSupportContractLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): QuotationSupportContractLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuotationSupportContractLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IQuotationSupportContractLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfQuotationQuotationStatusLookupTableDto implements IPagedResultDtoOfQuotationQuotationStatusLookupTableDto {
    totalCount!: number | undefined;
    items!: QuotationQuotationStatusLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfQuotationQuotationStatusLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(QuotationQuotationStatusLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfQuotationQuotationStatusLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfQuotationQuotationStatusLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfQuotationQuotationStatusLookupTableDto {
    totalCount: number | undefined;
    items: QuotationQuotationStatusLookupTableDto[] | undefined;
}

export class QuotationQuotationStatusLookupTableDto implements IQuotationQuotationStatusLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IQuotationQuotationStatusLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): QuotationQuotationStatusLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuotationQuotationStatusLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IQuotationQuotationStatusLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfQuotationWorkOrderLookupTableDto implements IPagedResultDtoOfQuotationWorkOrderLookupTableDto {
    totalCount!: number | undefined;
    items!: QuotationWorkOrderLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfQuotationWorkOrderLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(QuotationWorkOrderLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfQuotationWorkOrderLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfQuotationWorkOrderLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfQuotationWorkOrderLookupTableDto {
    totalCount: number | undefined;
    items: QuotationWorkOrderLookupTableDto[] | undefined;
}

export class QuotationWorkOrderLookupTableDto implements IQuotationWorkOrderLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IQuotationWorkOrderLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): QuotationWorkOrderLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuotationWorkOrderLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IQuotationWorkOrderLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfQuotationAssetLookupTableDto implements IPagedResultDtoOfQuotationAssetLookupTableDto {
    totalCount!: number | undefined;
    items!: QuotationAssetLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfQuotationAssetLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(QuotationAssetLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfQuotationAssetLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfQuotationAssetLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfQuotationAssetLookupTableDto {
    totalCount: number | undefined;
    items: QuotationAssetLookupTableDto[] | undefined;
}

export class QuotationAssetLookupTableDto implements IQuotationAssetLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IQuotationAssetLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): QuotationAssetLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuotationAssetLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IQuotationAssetLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfQuotationAssetClassLookupTableDto implements IPagedResultDtoOfQuotationAssetClassLookupTableDto {
    totalCount!: number | undefined;
    items!: QuotationAssetClassLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfQuotationAssetClassLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(QuotationAssetClassLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfQuotationAssetClassLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfQuotationAssetClassLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfQuotationAssetClassLookupTableDto {
    totalCount: number | undefined;
    items: QuotationAssetClassLookupTableDto[] | undefined;
}

export class QuotationAssetClassLookupTableDto implements IQuotationAssetClassLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IQuotationAssetClassLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): QuotationAssetClassLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuotationAssetClassLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IQuotationAssetClassLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfQuotationSupportTypeLookupTableDto implements IPagedResultDtoOfQuotationSupportTypeLookupTableDto {
    totalCount!: number | undefined;
    items!: QuotationSupportTypeLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfQuotationSupportTypeLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(QuotationSupportTypeLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfQuotationSupportTypeLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfQuotationSupportTypeLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfQuotationSupportTypeLookupTableDto {
    totalCount: number | undefined;
    items: QuotationSupportTypeLookupTableDto[] | undefined;
}

export class QuotationSupportTypeLookupTableDto implements IQuotationSupportTypeLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IQuotationSupportTypeLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): QuotationSupportTypeLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuotationSupportTypeLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IQuotationSupportTypeLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfQuotationSupportItemLookupTableDto implements IPagedResultDtoOfQuotationSupportItemLookupTableDto {
    totalCount!: number | undefined;
    items!: QuotationSupportItemLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfQuotationSupportItemLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(QuotationSupportItemLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfQuotationSupportItemLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfQuotationSupportItemLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfQuotationSupportItemLookupTableDto {
    totalCount: number | undefined;
    items: QuotationSupportItemLookupTableDto[] | undefined;
}

export class QuotationSupportItemLookupTableDto implements IQuotationSupportItemLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IQuotationSupportItemLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): QuotationSupportItemLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuotationSupportItemLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IQuotationSupportItemLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class QuotationAssetAndSupportItemListDto implements IQuotationAssetAndSupportItemListDto {
    assetList!: QuotationAssetLookupTableDto[] | undefined;
    assetClassList!: QuotationAssetClassLookupTableDto[] | undefined;
    supportContractList!: QuotationSupportContractLookupTableDto[] | undefined;
    supportItemList!: QuotationSupportItemLookupTableDto[] | undefined;
    supportTypeList!: QuotationSupportTypeLookupTableDto[] | undefined;
    aO_Address!: AddressDto | undefined;

    constructor(data?: IQuotationAssetAndSupportItemListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["assetList"])) {
                this.assetList = [] as any;
                for (let item of data["assetList"])
                    this.assetList!.push(QuotationAssetLookupTableDto.fromJS(item));
            }
            if (Array.isArray(data["assetClassList"])) {
                this.assetClassList = [] as any;
                for (let item of data["assetClassList"])
                    this.assetClassList!.push(QuotationAssetClassLookupTableDto.fromJS(item));
            }
            if (Array.isArray(data["supportContractList"])) {
                this.supportContractList = [] as any;
                for (let item of data["supportContractList"])
                    this.supportContractList!.push(QuotationSupportContractLookupTableDto.fromJS(item));
            }
            if (Array.isArray(data["supportItemList"])) {
                this.supportItemList = [] as any;
                for (let item of data["supportItemList"])
                    this.supportItemList!.push(QuotationSupportItemLookupTableDto.fromJS(item));
            }
            if (Array.isArray(data["supportTypeList"])) {
                this.supportTypeList = [] as any;
                for (let item of data["supportTypeList"])
                    this.supportTypeList!.push(QuotationSupportTypeLookupTableDto.fromJS(item));
            }
            this.aO_Address = data["aO_Address"] ? AddressDto.fromJS(data["aO_Address"]) : <any>undefined;
        }
    }

    static fromJS(data: any): QuotationAssetAndSupportItemListDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuotationAssetAndSupportItemListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.assetList)) {
            data["assetList"] = [];
            for (let item of this.assetList)
                data["assetList"].push(item.toJSON());
        }
        if (Array.isArray(this.assetClassList)) {
            data["assetClassList"] = [];
            for (let item of this.assetClassList)
                data["assetClassList"].push(item.toJSON());
        }
        if (Array.isArray(this.supportContractList)) {
            data["supportContractList"] = [];
            for (let item of this.supportContractList)
                data["supportContractList"].push(item.toJSON());
        }
        if (Array.isArray(this.supportItemList)) {
            data["supportItemList"] = [];
            for (let item of this.supportItemList)
                data["supportItemList"].push(item.toJSON());
        }
        if (Array.isArray(this.supportTypeList)) {
            data["supportTypeList"] = [];
            for (let item of this.supportTypeList)
                data["supportTypeList"].push(item.toJSON());
        }
        data["aO_Address"] = this.aO_Address ? this.aO_Address.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IQuotationAssetAndSupportItemListDto {
    assetList: QuotationAssetLookupTableDto[] | undefined;
    assetClassList: QuotationAssetClassLookupTableDto[] | undefined;
    supportContractList: QuotationSupportContractLookupTableDto[] | undefined;
    supportItemList: QuotationSupportItemLookupTableDto[] | undefined;
    supportTypeList: QuotationSupportTypeLookupTableDto[] | undefined;
    aO_Address: AddressDto | undefined;
}

export class PagedResultDtoOfGetQuotationStatusForViewDto implements IPagedResultDtoOfGetQuotationStatusForViewDto {
    totalCount!: number | undefined;
    items!: GetQuotationStatusForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetQuotationStatusForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetQuotationStatusForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetQuotationStatusForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetQuotationStatusForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetQuotationStatusForViewDto {
    totalCount: number | undefined;
    items: GetQuotationStatusForViewDto[] | undefined;
}

export class GetQuotationStatusForViewDto implements IGetQuotationStatusForViewDto {
    quotationStatus!: QuotationStatusDto | undefined;

    constructor(data?: IGetQuotationStatusForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.quotationStatus = data["quotationStatus"] ? QuotationStatusDto.fromJS(data["quotationStatus"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetQuotationStatusForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetQuotationStatusForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["quotationStatus"] = this.quotationStatus ? this.quotationStatus.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetQuotationStatusForViewDto {
    quotationStatus: QuotationStatusDto | undefined;
}

export class QuotationStatusDto implements IQuotationStatusDto {
    status!: string | undefined;
    description!: string | undefined;
    id!: number | undefined;

    constructor(data?: IQuotationStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"];
            this.description = data["description"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): QuotationStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new QuotationStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }
}

export interface IQuotationStatusDto {
    status: string | undefined;
    description: string | undefined;
    id: number | undefined;
}

export class GetQuotationStatusForEditOutput implements IGetQuotationStatusForEditOutput {
    quotationStatus!: CreateOrEditQuotationStatusDto | undefined;

    constructor(data?: IGetQuotationStatusForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.quotationStatus = data["quotationStatus"] ? CreateOrEditQuotationStatusDto.fromJS(data["quotationStatus"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetQuotationStatusForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetQuotationStatusForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["quotationStatus"] = this.quotationStatus ? this.quotationStatus.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetQuotationStatusForEditOutput {
    quotationStatus: CreateOrEditQuotationStatusDto | undefined;
}

export class CreateOrEditQuotationStatusDto implements ICreateOrEditQuotationStatusDto {
    status!: string;
    description!: string;
    id!: number | undefined;

    constructor(data?: ICreateOrEditQuotationStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"];
            this.description = data["description"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditQuotationStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditQuotationStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditQuotationStatusDto {
    status: string;
    description: string;
    id: number | undefined;
}

export class PagedResultDtoOfGetRfqForViewDto implements IPagedResultDtoOfGetRfqForViewDto {
    totalCount!: number | undefined;
    items!: GetRfqForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetRfqForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetRfqForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetRfqForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetRfqForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetRfqForViewDto {
    totalCount: number | undefined;
    items: GetRfqForViewDto[] | undefined;
}

export class GetRfqForViewDto implements IGetRfqForViewDto {
    rfq!: RfqDto | undefined;
    rfqTypeType!: string | undefined;
    assetOwnerName!: string | undefined;
    customerName!: string | undefined;
    assetClassClass!: string | undefined;
    incidentDescription!: string | undefined;
    vendorName!: string | undefined;
    userName!: string | undefined;

    constructor(data?: IGetRfqForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.rfq = data["rfq"] ? RfqDto.fromJS(data["rfq"]) : <any>undefined;
            this.rfqTypeType = data["rfqTypeType"];
            this.assetOwnerName = data["assetOwnerName"];
            this.customerName = data["customerName"];
            this.assetClassClass = data["assetClassClass"];
            this.incidentDescription = data["incidentDescription"];
            this.vendorName = data["vendorName"];
            this.userName = data["userName"];
        }
    }

    static fromJS(data: any): GetRfqForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetRfqForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rfq"] = this.rfq ? this.rfq.toJSON() : <any>undefined;
        data["rfqTypeType"] = this.rfqTypeType;
        data["assetOwnerName"] = this.assetOwnerName;
        data["customerName"] = this.customerName;
        data["assetClassClass"] = this.assetClassClass;
        data["incidentDescription"] = this.incidentDescription;
        data["vendorName"] = this.vendorName;
        data["userName"] = this.userName;
        return data; 
    }
}

export interface IGetRfqForViewDto {
    rfq: RfqDto | undefined;
    rfqTypeType: string | undefined;
    assetOwnerName: string | undefined;
    customerName: string | undefined;
    assetClassClass: string | undefined;
    incidentDescription: string | undefined;
    vendorName: string | undefined;
    userName: string | undefined;
}

export class RfqDto implements IRfqDto {
    title!: string | undefined;
    requestDate!: moment.Moment | undefined;
    requiredBy!: moment.Moment | undefined;
    description!: string | undefined;
    requirements!: string | undefined;
    rfqTypeId!: number | undefined;
    assetOwnerId!: number | undefined;
    customerId!: number | undefined;
    assetClassId!: number | undefined;
    incidentId!: number | undefined;
    vendorId!: number | undefined;
    userId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IRfqDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.title = data["title"];
            this.requestDate = data["requestDate"] ? moment(data["requestDate"].toString()) : <any>undefined;
            this.requiredBy = data["requiredBy"] ? moment(data["requiredBy"].toString()) : <any>undefined;
            this.description = data["description"];
            this.requirements = data["requirements"];
            this.rfqTypeId = data["rfqTypeId"];
            this.assetOwnerId = data["assetOwnerId"];
            this.customerId = data["customerId"];
            this.assetClassId = data["assetClassId"];
            this.incidentId = data["incidentId"];
            this.vendorId = data["vendorId"];
            this.userId = data["userId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RfqDto {
        data = typeof data === 'object' ? data : {};
        let result = new RfqDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["requestDate"] = this.requestDate ? this.requestDate.toISOString() : <any>undefined;
        data["requiredBy"] = this.requiredBy ? this.requiredBy.toISOString() : <any>undefined;
        data["description"] = this.description;
        data["requirements"] = this.requirements;
        data["rfqTypeId"] = this.rfqTypeId;
        data["assetOwnerId"] = this.assetOwnerId;
        data["customerId"] = this.customerId;
        data["assetClassId"] = this.assetClassId;
        data["incidentId"] = this.incidentId;
        data["vendorId"] = this.vendorId;
        data["userId"] = this.userId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IRfqDto {
    title: string | undefined;
    requestDate: moment.Moment | undefined;
    requiredBy: moment.Moment | undefined;
    description: string | undefined;
    requirements: string | undefined;
    rfqTypeId: number | undefined;
    assetOwnerId: number | undefined;
    customerId: number | undefined;
    assetClassId: number | undefined;
    incidentId: number | undefined;
    vendorId: number | undefined;
    userId: number | undefined;
    id: number | undefined;
}

export class GetRfqForEditOutput implements IGetRfqForEditOutput {
    rfq!: CreateOrEditRfqDto | undefined;
    rfqTypeType!: string | undefined;
    assetOwnerName!: string | undefined;
    customerName!: string | undefined;
    assetClassClass!: string | undefined;
    incidentDescription!: string | undefined;
    vendorName!: string | undefined;
    userName!: string | undefined;

    constructor(data?: IGetRfqForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.rfq = data["rfq"] ? CreateOrEditRfqDto.fromJS(data["rfq"]) : <any>undefined;
            this.rfqTypeType = data["rfqTypeType"];
            this.assetOwnerName = data["assetOwnerName"];
            this.customerName = data["customerName"];
            this.assetClassClass = data["assetClassClass"];
            this.incidentDescription = data["incidentDescription"];
            this.vendorName = data["vendorName"];
            this.userName = data["userName"];
        }
    }

    static fromJS(data: any): GetRfqForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRfqForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rfq"] = this.rfq ? this.rfq.toJSON() : <any>undefined;
        data["rfqTypeType"] = this.rfqTypeType;
        data["assetOwnerName"] = this.assetOwnerName;
        data["customerName"] = this.customerName;
        data["assetClassClass"] = this.assetClassClass;
        data["incidentDescription"] = this.incidentDescription;
        data["vendorName"] = this.vendorName;
        data["userName"] = this.userName;
        return data; 
    }
}

export interface IGetRfqForEditOutput {
    rfq: CreateOrEditRfqDto | undefined;
    rfqTypeType: string | undefined;
    assetOwnerName: string | undefined;
    customerName: string | undefined;
    assetClassClass: string | undefined;
    incidentDescription: string | undefined;
    vendorName: string | undefined;
    userName: string | undefined;
}

export class CreateOrEditRfqDto implements ICreateOrEditRfqDto {
    title!: string;
    requestDate!: moment.Moment | undefined;
    requiredBy!: moment.Moment | undefined;
    description!: string;
    requirements!: string;
    rfqTypeId!: number | undefined;
    assetOwnerId!: number | undefined;
    customerId!: number | undefined;
    assetClassId!: number | undefined;
    incidentId!: number | undefined;
    vendorId!: number | undefined;
    userId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditRfqDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.title = data["title"];
            this.requestDate = data["requestDate"] ? moment(data["requestDate"].toString()) : <any>undefined;
            this.requiredBy = data["requiredBy"] ? moment(data["requiredBy"].toString()) : <any>undefined;
            this.description = data["description"];
            this.requirements = data["requirements"];
            this.rfqTypeId = data["rfqTypeId"];
            this.assetOwnerId = data["assetOwnerId"];
            this.customerId = data["customerId"];
            this.assetClassId = data["assetClassId"];
            this.incidentId = data["incidentId"];
            this.vendorId = data["vendorId"];
            this.userId = data["userId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditRfqDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditRfqDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["requestDate"] = this.requestDate ? this.requestDate.toISOString() : <any>undefined;
        data["requiredBy"] = this.requiredBy ? this.requiredBy.toISOString() : <any>undefined;
        data["description"] = this.description;
        data["requirements"] = this.requirements;
        data["rfqTypeId"] = this.rfqTypeId;
        data["assetOwnerId"] = this.assetOwnerId;
        data["customerId"] = this.customerId;
        data["assetClassId"] = this.assetClassId;
        data["incidentId"] = this.incidentId;
        data["vendorId"] = this.vendorId;
        data["userId"] = this.userId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditRfqDto {
    title: string;
    requestDate: moment.Moment | undefined;
    requiredBy: moment.Moment | undefined;
    description: string;
    requirements: string;
    rfqTypeId: number | undefined;
    assetOwnerId: number | undefined;
    customerId: number | undefined;
    assetClassId: number | undefined;
    incidentId: number | undefined;
    vendorId: number | undefined;
    userId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfRfqRfqTypeLookupTableDto implements IPagedResultDtoOfRfqRfqTypeLookupTableDto {
    totalCount!: number | undefined;
    items!: RfqRfqTypeLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfRfqRfqTypeLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(RfqRfqTypeLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfRfqRfqTypeLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfRfqRfqTypeLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfRfqRfqTypeLookupTableDto {
    totalCount: number | undefined;
    items: RfqRfqTypeLookupTableDto[] | undefined;
}

export class RfqRfqTypeLookupTableDto implements IRfqRfqTypeLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IRfqRfqTypeLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): RfqRfqTypeLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new RfqRfqTypeLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IRfqRfqTypeLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfRfqAssetOwnerLookupTableDto implements IPagedResultDtoOfRfqAssetOwnerLookupTableDto {
    totalCount!: number | undefined;
    items!: RfqAssetOwnerLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfRfqAssetOwnerLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(RfqAssetOwnerLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfRfqAssetOwnerLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfRfqAssetOwnerLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfRfqAssetOwnerLookupTableDto {
    totalCount: number | undefined;
    items: RfqAssetOwnerLookupTableDto[] | undefined;
}

export class RfqAssetOwnerLookupTableDto implements IRfqAssetOwnerLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IRfqAssetOwnerLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): RfqAssetOwnerLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new RfqAssetOwnerLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IRfqAssetOwnerLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfRfqCustomerLookupTableDto implements IPagedResultDtoOfRfqCustomerLookupTableDto {
    totalCount!: number | undefined;
    items!: RfqCustomerLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfRfqCustomerLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(RfqCustomerLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfRfqCustomerLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfRfqCustomerLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfRfqCustomerLookupTableDto {
    totalCount: number | undefined;
    items: RfqCustomerLookupTableDto[] | undefined;
}

export class RfqCustomerLookupTableDto implements IRfqCustomerLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IRfqCustomerLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): RfqCustomerLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new RfqCustomerLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IRfqCustomerLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfRfqAssetClassLookupTableDto implements IPagedResultDtoOfRfqAssetClassLookupTableDto {
    totalCount!: number | undefined;
    items!: RfqAssetClassLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfRfqAssetClassLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(RfqAssetClassLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfRfqAssetClassLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfRfqAssetClassLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfRfqAssetClassLookupTableDto {
    totalCount: number | undefined;
    items: RfqAssetClassLookupTableDto[] | undefined;
}

export class RfqAssetClassLookupTableDto implements IRfqAssetClassLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IRfqAssetClassLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): RfqAssetClassLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new RfqAssetClassLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IRfqAssetClassLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfRfqIncidentLookupTableDto implements IPagedResultDtoOfRfqIncidentLookupTableDto {
    totalCount!: number | undefined;
    items!: RfqIncidentLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfRfqIncidentLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(RfqIncidentLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfRfqIncidentLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfRfqIncidentLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfRfqIncidentLookupTableDto {
    totalCount: number | undefined;
    items: RfqIncidentLookupTableDto[] | undefined;
}

export class RfqIncidentLookupTableDto implements IRfqIncidentLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IRfqIncidentLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): RfqIncidentLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new RfqIncidentLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IRfqIncidentLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfRfqVendorLookupTableDto implements IPagedResultDtoOfRfqVendorLookupTableDto {
    totalCount!: number | undefined;
    items!: RfqVendorLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfRfqVendorLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(RfqVendorLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfRfqVendorLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfRfqVendorLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfRfqVendorLookupTableDto {
    totalCount: number | undefined;
    items: RfqVendorLookupTableDto[] | undefined;
}

export class RfqVendorLookupTableDto implements IRfqVendorLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IRfqVendorLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): RfqVendorLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new RfqVendorLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IRfqVendorLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfRfqUserLookupTableDto implements IPagedResultDtoOfRfqUserLookupTableDto {
    totalCount!: number | undefined;
    items!: RfqUserLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfRfqUserLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(RfqUserLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfRfqUserLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfRfqUserLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfRfqUserLookupTableDto {
    totalCount: number | undefined;
    items: RfqUserLookupTableDto[] | undefined;
}

export class RfqUserLookupTableDto implements IRfqUserLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IRfqUserLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): RfqUserLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new RfqUserLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IRfqUserLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetRfqTypeForViewDto implements IPagedResultDtoOfGetRfqTypeForViewDto {
    totalCount!: number | undefined;
    items!: GetRfqTypeForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetRfqTypeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetRfqTypeForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetRfqTypeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetRfqTypeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetRfqTypeForViewDto {
    totalCount: number | undefined;
    items: GetRfqTypeForViewDto[] | undefined;
}

export class GetRfqTypeForViewDto implements IGetRfqTypeForViewDto {
    rfqType!: RfqTypeDto | undefined;

    constructor(data?: IGetRfqTypeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.rfqType = data["rfqType"] ? RfqTypeDto.fromJS(data["rfqType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetRfqTypeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetRfqTypeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rfqType"] = this.rfqType ? this.rfqType.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetRfqTypeForViewDto {
    rfqType: RfqTypeDto | undefined;
}

export class RfqTypeDto implements IRfqTypeDto {
    type!: string | undefined;
    description!: string | undefined;
    id!: number | undefined;

    constructor(data?: IRfqTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.type = data["type"];
            this.description = data["description"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RfqTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new RfqTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }
}

export interface IRfqTypeDto {
    type: string | undefined;
    description: string | undefined;
    id: number | undefined;
}

export class GetRfqTypeForEditOutput implements IGetRfqTypeForEditOutput {
    rfqType!: CreateOrEditRfqTypeDto | undefined;

    constructor(data?: IGetRfqTypeForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.rfqType = data["rfqType"] ? CreateOrEditRfqTypeDto.fromJS(data["rfqType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetRfqTypeForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRfqTypeForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rfqType"] = this.rfqType ? this.rfqType.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetRfqTypeForEditOutput {
    rfqType: CreateOrEditRfqTypeDto | undefined;
}

export class CreateOrEditRfqTypeDto implements ICreateOrEditRfqTypeDto {
    type!: string;
    description!: string;
    id!: number | undefined;

    constructor(data?: ICreateOrEditRfqTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.type = data["type"];
            this.description = data["description"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditRfqTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditRfqTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditRfqTypeDto {
    type: string;
    description: string;
    id: number | undefined;
}

export class ListResultDtoOfRoleListDto implements IListResultDtoOfRoleListDto {
    items!: RoleListDto[] | undefined;

    constructor(data?: IListResultDtoOfRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(RoleListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfRoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfRoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfRoleListDto {
    items: RoleListDto[] | undefined;
}

export class RoleListDto implements IRoleListDto {
    name!: string | undefined;
    displayName!: string | undefined;
    isStatic!: boolean | undefined;
    isDefault!: boolean | undefined;
    creationTime!: moment.Moment | undefined;
    id!: number | undefined;

    constructor(data?: IRoleListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.isStatic = data["isStatic"];
            this.isDefault = data["isDefault"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): RoleListDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["isStatic"] = this.isStatic;
        data["isDefault"] = this.isDefault;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IRoleListDto {
    name: string | undefined;
    displayName: string | undefined;
    isStatic: boolean | undefined;
    isDefault: boolean | undefined;
    creationTime: moment.Moment | undefined;
    id: number | undefined;
}

export class GetRoleForEditOutput implements IGetRoleForEditOutput {
    role!: RoleEditDto | undefined;
    permissions!: FlatPermissionDto[] | undefined;
    grantedPermissionNames!: string[] | undefined;

    constructor(data?: IGetRoleForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.role = data["role"] ? RoleEditDto.fromJS(data["role"]) : <any>undefined;
            if (Array.isArray(data["permissions"])) {
                this.permissions = [] as any;
                for (let item of data["permissions"])
                    this.permissions!.push(FlatPermissionDto.fromJS(item));
            }
            if (Array.isArray(data["grantedPermissionNames"])) {
                this.grantedPermissionNames = [] as any;
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames!.push(item);
            }
        }
    }

    static fromJS(data: any): GetRoleForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRoleForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (Array.isArray(this.grantedPermissionNames)) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }
}

export interface IGetRoleForEditOutput {
    role: RoleEditDto | undefined;
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
}

export class RoleEditDto implements IRoleEditDto {
    id!: number | undefined;
    displayName!: string;
    isDefault!: boolean | undefined;

    constructor(data?: IRoleEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
            this.isDefault = data["isDefault"];
        }
    }

    static fromJS(data: any): RoleEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        data["isDefault"] = this.isDefault;
        return data; 
    }
}

export interface IRoleEditDto {
    id: number | undefined;
    displayName: string;
    isDefault: boolean | undefined;
}

export class FlatPermissionDto implements IFlatPermissionDto {
    parentName!: string | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;
    isGrantedByDefault!: boolean | undefined;

    constructor(data?: IFlatPermissionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentName = data["parentName"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.isGrantedByDefault = data["isGrantedByDefault"];
        }
    }

    static fromJS(data: any): FlatPermissionDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatPermissionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["isGrantedByDefault"] = this.isGrantedByDefault;
        return data; 
    }
}

export interface IFlatPermissionDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    isGrantedByDefault: boolean | undefined;
}

export class CreateOrUpdateRoleInput implements ICreateOrUpdateRoleInput {
    role!: RoleEditDto;
    grantedPermissionNames!: string[];

    constructor(data?: ICreateOrUpdateRoleInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.role = new RoleEditDto();
            this.grantedPermissionNames = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.role = data["role"] ? RoleEditDto.fromJS(data["role"]) : new RoleEditDto();
            if (Array.isArray(data["grantedPermissionNames"])) {
                this.grantedPermissionNames = [] as any;
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateOrUpdateRoleInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateRoleInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["role"] = this.role ? this.role.toJSON() : <any>undefined;
        if (Array.isArray(this.grantedPermissionNames)) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }
}

export interface ICreateOrUpdateRoleInput {
    role: RoleEditDto;
    grantedPermissionNames: string[];
}

export class GetCurrentLoginInformationsOutput implements IGetCurrentLoginInformationsOutput {
    user!: UserLoginInfoDto | undefined;
    tenant!: TenantLoginInfoDto | undefined;
    application!: ApplicationInfoDto | undefined;
    theme!: UiCustomizationSettingsDto | undefined;

    constructor(data?: IGetCurrentLoginInformationsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.user = data["user"] ? UserLoginInfoDto.fromJS(data["user"]) : <any>undefined;
            this.tenant = data["tenant"] ? TenantLoginInfoDto.fromJS(data["tenant"]) : <any>undefined;
            this.application = data["application"] ? ApplicationInfoDto.fromJS(data["application"]) : <any>undefined;
            this.theme = data["theme"] ? UiCustomizationSettingsDto.fromJS(data["theme"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetCurrentLoginInformationsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetCurrentLoginInformationsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["tenant"] = this.tenant ? this.tenant.toJSON() : <any>undefined;
        data["application"] = this.application ? this.application.toJSON() : <any>undefined;
        data["theme"] = this.theme ? this.theme.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetCurrentLoginInformationsOutput {
    user: UserLoginInfoDto | undefined;
    tenant: TenantLoginInfoDto | undefined;
    application: ApplicationInfoDto | undefined;
    theme: UiCustomizationSettingsDto | undefined;
}

export class UserLoginInfoDto implements IUserLoginInfoDto {
    name!: string | undefined;
    surname!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    profilePictureId!: string | undefined;
    id!: number | undefined;

    constructor(data?: IUserLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.profilePictureId = data["profilePictureId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["profilePictureId"] = this.profilePictureId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserLoginInfoDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    profilePictureId: string | undefined;
    id: number | undefined;
}

export class TenantLoginInfoDto implements ITenantLoginInfoDto {
    tenancyName!: string | undefined;
    name!: string | undefined;
    logoId!: string | undefined;
    logoFileType!: string | undefined;
    customCssId!: string | undefined;
    subscriptionEndDateUtc!: moment.Moment | undefined;
    isInTrialPeriod!: boolean | undefined;
    subscriptionPaymentType!: SubscriptionPaymentType | undefined;
    edition!: EditionInfoDto | undefined;
    creationTime!: moment.Moment | undefined;
    paymentPeriodType!: PaymentPeriodType | undefined;
    subscriptionDateString!: string | undefined;
    creationTimeString!: string | undefined;
    id!: number | undefined;

    constructor(data?: ITenantLoginInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.logoId = data["logoId"];
            this.logoFileType = data["logoFileType"];
            this.customCssId = data["customCssId"];
            this.subscriptionEndDateUtc = data["subscriptionEndDateUtc"] ? moment(data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.isInTrialPeriod = data["isInTrialPeriod"];
            this.subscriptionPaymentType = data["subscriptionPaymentType"];
            this.edition = data["edition"] ? EditionInfoDto.fromJS(data["edition"]) : <any>undefined;
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.paymentPeriodType = data["paymentPeriodType"];
            this.subscriptionDateString = data["subscriptionDateString"];
            this.creationTimeString = data["creationTimeString"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantLoginInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantLoginInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["logoId"] = this.logoId;
        data["logoFileType"] = this.logoFileType;
        data["customCssId"] = this.customCssId;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toISOString() : <any>undefined;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        data["subscriptionPaymentType"] = this.subscriptionPaymentType;
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["paymentPeriodType"] = this.paymentPeriodType;
        data["subscriptionDateString"] = this.subscriptionDateString;
        data["creationTimeString"] = this.creationTimeString;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITenantLoginInfoDto {
    tenancyName: string | undefined;
    name: string | undefined;
    logoId: string | undefined;
    logoFileType: string | undefined;
    customCssId: string | undefined;
    subscriptionEndDateUtc: moment.Moment | undefined;
    isInTrialPeriod: boolean | undefined;
    subscriptionPaymentType: SubscriptionPaymentType | undefined;
    edition: EditionInfoDto | undefined;
    creationTime: moment.Moment | undefined;
    paymentPeriodType: PaymentPeriodType | undefined;
    subscriptionDateString: string | undefined;
    creationTimeString: string | undefined;
    id: number | undefined;
}

export class ApplicationInfoDto implements IApplicationInfoDto {
    version!: string | undefined;
    releaseDate!: moment.Moment | undefined;
    currency!: string | undefined;
    currencySign!: string | undefined;
    allowTenantsToChangeEmailSettings!: boolean | undefined;
    features!: { [key: string]: boolean; } | undefined;

    constructor(data?: IApplicationInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.version = data["version"];
            this.releaseDate = data["releaseDate"] ? moment(data["releaseDate"].toString()) : <any>undefined;
            this.currency = data["currency"];
            this.currencySign = data["currencySign"];
            this.allowTenantsToChangeEmailSettings = data["allowTenantsToChangeEmailSettings"];
            if (data["features"]) {
                this.features = {} as any;
                for (let key in data["features"]) {
                    if (data["features"].hasOwnProperty(key))
                        this.features![key] = data["features"][key];
                }
            }
        }
    }

    static fromJS(data: any): ApplicationInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["version"] = this.version;
        data["releaseDate"] = this.releaseDate ? this.releaseDate.toISOString() : <any>undefined;
        data["currency"] = this.currency;
        data["currencySign"] = this.currencySign;
        data["allowTenantsToChangeEmailSettings"] = this.allowTenantsToChangeEmailSettings;
        if (this.features) {
            data["features"] = {};
            for (let key in this.features) {
                if (this.features.hasOwnProperty(key))
                    data["features"][key] = this.features[key];
            }
        }
        return data; 
    }
}

export interface IApplicationInfoDto {
    version: string | undefined;
    releaseDate: moment.Moment | undefined;
    currency: string | undefined;
    currencySign: string | undefined;
    allowTenantsToChangeEmailSettings: boolean | undefined;
    features: { [key: string]: boolean; } | undefined;
}

export class UiCustomizationSettingsDto implements IUiCustomizationSettingsDto {
    baseSettings!: ThemeSettingsDto | undefined;
    isLeftMenuUsed!: boolean | undefined;
    isTopMenuUsed!: boolean | undefined;
    isTabMenuUsed!: boolean | undefined;
    allowMenuScroll!: boolean | undefined;

    constructor(data?: IUiCustomizationSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.baseSettings = data["baseSettings"] ? ThemeSettingsDto.fromJS(data["baseSettings"]) : <any>undefined;
            this.isLeftMenuUsed = data["isLeftMenuUsed"];
            this.isTopMenuUsed = data["isTopMenuUsed"];
            this.isTabMenuUsed = data["isTabMenuUsed"];
            this.allowMenuScroll = data["allowMenuScroll"];
        }
    }

    static fromJS(data: any): UiCustomizationSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new UiCustomizationSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["baseSettings"] = this.baseSettings ? this.baseSettings.toJSON() : <any>undefined;
        data["isLeftMenuUsed"] = this.isLeftMenuUsed;
        data["isTopMenuUsed"] = this.isTopMenuUsed;
        data["isTabMenuUsed"] = this.isTabMenuUsed;
        data["allowMenuScroll"] = this.allowMenuScroll;
        return data; 
    }
}

export interface IUiCustomizationSettingsDto {
    baseSettings: ThemeSettingsDto | undefined;
    isLeftMenuUsed: boolean | undefined;
    isTopMenuUsed: boolean | undefined;
    isTabMenuUsed: boolean | undefined;
    allowMenuScroll: boolean | undefined;
}

export enum SubscriptionPaymentType {
    Manual = 0,
    RecurringAutomatic = 1,
    RecurringManual = 2,
}

export class EditionInfoDto implements IEditionInfoDto {
    displayName!: string | undefined;
    trialDayCount!: number | undefined;
    monthlyPrice!: number | undefined;
    annualPrice!: number | undefined;
    isHighestEdition!: boolean | undefined;
    isFree!: boolean | undefined;
    id!: number | undefined;

    constructor(data?: IEditionInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.displayName = data["displayName"];
            this.trialDayCount = data["trialDayCount"];
            this.monthlyPrice = data["monthlyPrice"];
            this.annualPrice = data["annualPrice"];
            this.isHighestEdition = data["isHighestEdition"];
            this.isFree = data["isFree"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EditionInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["displayName"] = this.displayName;
        data["trialDayCount"] = this.trialDayCount;
        data["monthlyPrice"] = this.monthlyPrice;
        data["annualPrice"] = this.annualPrice;
        data["isHighestEdition"] = this.isHighestEdition;
        data["isFree"] = this.isFree;
        data["id"] = this.id;
        return data; 
    }
}

export interface IEditionInfoDto {
    displayName: string | undefined;
    trialDayCount: number | undefined;
    monthlyPrice: number | undefined;
    annualPrice: number | undefined;
    isHighestEdition: boolean | undefined;
    isFree: boolean | undefined;
    id: number | undefined;
}

export class ThemeSettingsDto implements IThemeSettingsDto {
    theme!: string | undefined;
    layout!: ThemeLayoutSettingsDto | undefined;
    header!: ThemeHeaderSettingsDto | undefined;
    subHeader!: ThemeSubHeaderSettingsDto | undefined;
    menu!: ThemeMenuSettingsDto | undefined;
    footer!: ThemeFooterSettingsDto | undefined;

    constructor(data?: IThemeSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.theme = data["theme"];
            this.layout = data["layout"] ? ThemeLayoutSettingsDto.fromJS(data["layout"]) : <any>undefined;
            this.header = data["header"] ? ThemeHeaderSettingsDto.fromJS(data["header"]) : <any>undefined;
            this.subHeader = data["subHeader"] ? ThemeSubHeaderSettingsDto.fromJS(data["subHeader"]) : <any>undefined;
            this.menu = data["menu"] ? ThemeMenuSettingsDto.fromJS(data["menu"]) : <any>undefined;
            this.footer = data["footer"] ? ThemeFooterSettingsDto.fromJS(data["footer"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ThemeSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["theme"] = this.theme;
        data["layout"] = this.layout ? this.layout.toJSON() : <any>undefined;
        data["header"] = this.header ? this.header.toJSON() : <any>undefined;
        data["subHeader"] = this.subHeader ? this.subHeader.toJSON() : <any>undefined;
        data["menu"] = this.menu ? this.menu.toJSON() : <any>undefined;
        data["footer"] = this.footer ? this.footer.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IThemeSettingsDto {
    theme: string | undefined;
    layout: ThemeLayoutSettingsDto | undefined;
    header: ThemeHeaderSettingsDto | undefined;
    subHeader: ThemeSubHeaderSettingsDto | undefined;
    menu: ThemeMenuSettingsDto | undefined;
    footer: ThemeFooterSettingsDto | undefined;
}

export class ThemeLayoutSettingsDto implements IThemeLayoutSettingsDto {
    layoutType!: string | undefined;

    constructor(data?: IThemeLayoutSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.layoutType = data["layoutType"];
        }
    }

    static fromJS(data: any): ThemeLayoutSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeLayoutSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["layoutType"] = this.layoutType;
        return data; 
    }
}

export interface IThemeLayoutSettingsDto {
    layoutType: string | undefined;
}

export class ThemeHeaderSettingsDto implements IThemeHeaderSettingsDto {
    desktopFixedHeader!: boolean | undefined;
    mobileFixedHeader!: boolean | undefined;
    headerSkin!: string | undefined;
    minimizeDesktopHeaderType!: string | undefined;
    headerMenuArrows!: boolean | undefined;

    constructor(data?: IThemeHeaderSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.desktopFixedHeader = data["desktopFixedHeader"];
            this.mobileFixedHeader = data["mobileFixedHeader"];
            this.headerSkin = data["headerSkin"];
            this.minimizeDesktopHeaderType = data["minimizeDesktopHeaderType"];
            this.headerMenuArrows = data["headerMenuArrows"];
        }
    }

    static fromJS(data: any): ThemeHeaderSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeHeaderSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["desktopFixedHeader"] = this.desktopFixedHeader;
        data["mobileFixedHeader"] = this.mobileFixedHeader;
        data["headerSkin"] = this.headerSkin;
        data["minimizeDesktopHeaderType"] = this.minimizeDesktopHeaderType;
        data["headerMenuArrows"] = this.headerMenuArrows;
        return data; 
    }
}

export interface IThemeHeaderSettingsDto {
    desktopFixedHeader: boolean | undefined;
    mobileFixedHeader: boolean | undefined;
    headerSkin: string | undefined;
    minimizeDesktopHeaderType: string | undefined;
    headerMenuArrows: boolean | undefined;
}

export class ThemeSubHeaderSettingsDto implements IThemeSubHeaderSettingsDto {
    fixedSubHeader!: boolean | undefined;
    subheaderStyle!: string | undefined;

    constructor(data?: IThemeSubHeaderSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fixedSubHeader = data["fixedSubHeader"];
            this.subheaderStyle = data["subheaderStyle"];
        }
    }

    static fromJS(data: any): ThemeSubHeaderSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeSubHeaderSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fixedSubHeader"] = this.fixedSubHeader;
        data["subheaderStyle"] = this.subheaderStyle;
        return data; 
    }
}

export interface IThemeSubHeaderSettingsDto {
    fixedSubHeader: boolean | undefined;
    subheaderStyle: string | undefined;
}

export class ThemeMenuSettingsDto implements IThemeMenuSettingsDto {
    position!: string | undefined;
    asideSkin!: string | undefined;
    fixedAside!: boolean | undefined;
    allowAsideMinimizing!: boolean | undefined;
    defaultMinimizedAside!: boolean | undefined;
    submenuToggle!: string | undefined;

    constructor(data?: IThemeMenuSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.position = data["position"];
            this.asideSkin = data["asideSkin"];
            this.fixedAside = data["fixedAside"];
            this.allowAsideMinimizing = data["allowAsideMinimizing"];
            this.defaultMinimizedAside = data["defaultMinimizedAside"];
            this.submenuToggle = data["submenuToggle"];
        }
    }

    static fromJS(data: any): ThemeMenuSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeMenuSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["position"] = this.position;
        data["asideSkin"] = this.asideSkin;
        data["fixedAside"] = this.fixedAside;
        data["allowAsideMinimizing"] = this.allowAsideMinimizing;
        data["defaultMinimizedAside"] = this.defaultMinimizedAside;
        data["submenuToggle"] = this.submenuToggle;
        return data; 
    }
}

export interface IThemeMenuSettingsDto {
    position: string | undefined;
    asideSkin: string | undefined;
    fixedAside: boolean | undefined;
    allowAsideMinimizing: boolean | undefined;
    defaultMinimizedAside: boolean | undefined;
    submenuToggle: string | undefined;
}

export class ThemeFooterSettingsDto implements IThemeFooterSettingsDto {
    fixedFooter!: boolean | undefined;

    constructor(data?: IThemeFooterSettingsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.fixedFooter = data["fixedFooter"];
        }
    }

    static fromJS(data: any): ThemeFooterSettingsDto {
        data = typeof data === 'object' ? data : {};
        let result = new ThemeFooterSettingsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fixedFooter"] = this.fixedFooter;
        return data; 
    }
}

export interface IThemeFooterSettingsDto {
    fixedFooter: boolean | undefined;
}

export class UpdateUserSignInTokenOutput implements IUpdateUserSignInTokenOutput {
    signInToken!: string | undefined;
    encodedUserId!: string | undefined;
    encodedTenantId!: string | undefined;

    constructor(data?: IUpdateUserSignInTokenOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.signInToken = data["signInToken"];
            this.encodedUserId = data["encodedUserId"];
            this.encodedTenantId = data["encodedTenantId"];
        }
    }

    static fromJS(data: any): UpdateUserSignInTokenOutput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserSignInTokenOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["signInToken"] = this.signInToken;
        data["encodedUserId"] = this.encodedUserId;
        data["encodedTenantId"] = this.encodedTenantId;
        return data; 
    }
}

export interface IUpdateUserSignInTokenOutput {
    signInToken: string | undefined;
    encodedUserId: string | undefined;
    encodedTenantId: string | undefined;
}

export class PagedResultDtoOfGetSsicCodeForViewDto implements IPagedResultDtoOfGetSsicCodeForViewDto {
    totalCount!: number | undefined;
    items!: GetSsicCodeForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetSsicCodeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetSsicCodeForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetSsicCodeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetSsicCodeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetSsicCodeForViewDto {
    totalCount: number | undefined;
    items: GetSsicCodeForViewDto[] | undefined;
}

export class GetSsicCodeForViewDto implements IGetSsicCodeForViewDto {
    ssicCode!: SsicCodeDto | undefined;

    constructor(data?: IGetSsicCodeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ssicCode = data["ssicCode"] ? SsicCodeDto.fromJS(data["ssicCode"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetSsicCodeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetSsicCodeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ssicCode"] = this.ssicCode ? this.ssicCode.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetSsicCodeForViewDto {
    ssicCode: SsicCodeDto | undefined;
}

export class SsicCodeDto implements ISsicCodeDto {
    code!: string | undefined;
    ssic!: string | undefined;
    id!: number | undefined;

    constructor(data?: ISsicCodeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.ssic = data["ssic"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SsicCodeDto {
        data = typeof data === 'object' ? data : {};
        let result = new SsicCodeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["ssic"] = this.ssic;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISsicCodeDto {
    code: string | undefined;
    ssic: string | undefined;
    id: number | undefined;
}

export class GetSsicCodeForEditOutput implements IGetSsicCodeForEditOutput {
    ssicCode!: CreateOrEditSsicCodeDto | undefined;

    constructor(data?: IGetSsicCodeForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.ssicCode = data["ssicCode"] ? CreateOrEditSsicCodeDto.fromJS(data["ssicCode"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetSsicCodeForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSsicCodeForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ssicCode"] = this.ssicCode ? this.ssicCode.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetSsicCodeForEditOutput {
    ssicCode: CreateOrEditSsicCodeDto | undefined;
}

export class CreateOrEditSsicCodeDto implements ICreateOrEditSsicCodeDto {
    code!: string;
    ssic!: string;
    id!: number | undefined;

    constructor(data?: ICreateOrEditSsicCodeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.ssic = data["ssic"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditSsicCodeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditSsicCodeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["ssic"] = this.ssic;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditSsicCodeDto {
    code: string;
    ssic: string;
    id: number | undefined;
}

export class StripeConfirmPaymentInput implements IStripeConfirmPaymentInput {
    paymentId!: number | undefined;
    stripeToken!: string | undefined;

    constructor(data?: IStripeConfirmPaymentInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.paymentId = data["paymentId"];
            this.stripeToken = data["stripeToken"];
        }
    }

    static fromJS(data: any): StripeConfirmPaymentInput {
        data = typeof data === 'object' ? data : {};
        let result = new StripeConfirmPaymentInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentId"] = this.paymentId;
        data["stripeToken"] = this.stripeToken;
        return data; 
    }
}

export interface IStripeConfirmPaymentInput {
    paymentId: number | undefined;
    stripeToken: string | undefined;
}

export class StripeCreateSubscriptionInput implements IStripeCreateSubscriptionInput {
    paymentId!: number | undefined;
    stripeToken!: string | undefined;

    constructor(data?: IStripeCreateSubscriptionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.paymentId = data["paymentId"];
            this.stripeToken = data["stripeToken"];
        }
    }

    static fromJS(data: any): StripeCreateSubscriptionInput {
        data = typeof data === 'object' ? data : {};
        let result = new StripeCreateSubscriptionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentId"] = this.paymentId;
        data["stripeToken"] = this.stripeToken;
        return data; 
    }
}

export interface IStripeCreateSubscriptionInput {
    paymentId: number | undefined;
    stripeToken: string | undefined;
}

export class StripeUpdateSubscriptionInput implements IStripeUpdateSubscriptionInput {
    paymentId!: number | undefined;

    constructor(data?: IStripeUpdateSubscriptionInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.paymentId = data["paymentId"];
        }
    }

    static fromJS(data: any): StripeUpdateSubscriptionInput {
        data = typeof data === 'object' ? data : {};
        let result = new StripeUpdateSubscriptionInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paymentId"] = this.paymentId;
        return data; 
    }
}

export interface IStripeUpdateSubscriptionInput {
    paymentId: number | undefined;
}

export class StripeConfigurationDto implements IStripeConfigurationDto {
    publishableKey!: string | undefined;

    constructor(data?: IStripeConfigurationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.publishableKey = data["publishableKey"];
        }
    }

    static fromJS(data: any): StripeConfigurationDto {
        data = typeof data === 'object' ? data : {};
        let result = new StripeConfigurationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["publishableKey"] = this.publishableKey;
        return data; 
    }
}

export interface IStripeConfigurationDto {
    publishableKey: string | undefined;
}

export class PagedResultDtoOfGetSupportContractForViewDto implements IPagedResultDtoOfGetSupportContractForViewDto {
    totalCount!: number | undefined;
    items!: GetSupportContractForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetSupportContractForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetSupportContractForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetSupportContractForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetSupportContractForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetSupportContractForViewDto {
    totalCount: number | undefined;
    items: GetSupportContractForViewDto[] | undefined;
}

export class GetSupportContractForViewDto implements IGetSupportContractForViewDto {
    supportContract!: SupportContractDto | undefined;
    vendorName!: string | undefined;
    assetOwnerName!: string | undefined;

    constructor(data?: IGetSupportContractForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.supportContract = data["supportContract"] ? SupportContractDto.fromJS(data["supportContract"]) : <any>undefined;
            this.vendorName = data["vendorName"];
            this.assetOwnerName = data["assetOwnerName"];
        }
    }

    static fromJS(data: any): GetSupportContractForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetSupportContractForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["supportContract"] = this.supportContract ? this.supportContract.toJSON() : <any>undefined;
        data["vendorName"] = this.vendorName;
        data["assetOwnerName"] = this.assetOwnerName;
        return data; 
    }
}

export interface IGetSupportContractForViewDto {
    supportContract: SupportContractDto | undefined;
    vendorName: string | undefined;
    assetOwnerName: string | undefined;
}

export class SupportContractDto implements ISupportContractDto {
    title!: string | undefined;
    reference!: string | undefined;
    description!: string | undefined;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    isRFQTemplate!: boolean | undefined;
    isAcknowledged!: boolean | undefined;
    acknowledgedBy!: string | undefined;
    acknowledgedAt!: moment.Moment | undefined;
    vendorId!: number | undefined;
    assetOwnerId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ISupportContractDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.title = data["title"];
            this.reference = data["reference"];
            this.description = data["description"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.isRFQTemplate = data["isRFQTemplate"];
            this.isAcknowledged = data["isAcknowledged"];
            this.acknowledgedBy = data["acknowledgedBy"];
            this.acknowledgedAt = data["acknowledgedAt"] ? moment(data["acknowledgedAt"].toString()) : <any>undefined;
            this.vendorId = data["vendorId"];
            this.assetOwnerId = data["assetOwnerId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SupportContractDto {
        data = typeof data === 'object' ? data : {};
        let result = new SupportContractDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["reference"] = this.reference;
        data["description"] = this.description;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["isRFQTemplate"] = this.isRFQTemplate;
        data["isAcknowledged"] = this.isAcknowledged;
        data["acknowledgedBy"] = this.acknowledgedBy;
        data["acknowledgedAt"] = this.acknowledgedAt ? this.acknowledgedAt.toISOString() : <any>undefined;
        data["vendorId"] = this.vendorId;
        data["assetOwnerId"] = this.assetOwnerId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISupportContractDto {
    title: string | undefined;
    reference: string | undefined;
    description: string | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    isRFQTemplate: boolean | undefined;
    isAcknowledged: boolean | undefined;
    acknowledgedBy: string | undefined;
    acknowledgedAt: moment.Moment | undefined;
    vendorId: number | undefined;
    assetOwnerId: number | undefined;
    id: number | undefined;
}

export class GetSupportContractForEditOutput implements IGetSupportContractForEditOutput {
    supportContract!: CreateOrEditSupportContractDto | undefined;
    vendorName!: string | undefined;
    assetOwnerName!: string | undefined;

    constructor(data?: IGetSupportContractForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.supportContract = data["supportContract"] ? CreateOrEditSupportContractDto.fromJS(data["supportContract"]) : <any>undefined;
            this.vendorName = data["vendorName"];
            this.assetOwnerName = data["assetOwnerName"];
        }
    }

    static fromJS(data: any): GetSupportContractForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSupportContractForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["supportContract"] = this.supportContract ? this.supportContract.toJSON() : <any>undefined;
        data["vendorName"] = this.vendorName;
        data["assetOwnerName"] = this.assetOwnerName;
        return data; 
    }
}

export interface IGetSupportContractForEditOutput {
    supportContract: CreateOrEditSupportContractDto | undefined;
    vendorName: string | undefined;
    assetOwnerName: string | undefined;
}

export class CreateOrEditSupportContractDto implements ICreateOrEditSupportContractDto {
    title!: string;
    reference!: string | undefined;
    description!: string;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    isRFQTemplate!: boolean | undefined;
    isAcknowledged!: boolean | undefined;
    acknowledgedBy!: string | undefined;
    acknowledgedAt!: moment.Moment | undefined;
    vendorId!: number | undefined;
    assetOwnerId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditSupportContractDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.title = data["title"];
            this.reference = data["reference"];
            this.description = data["description"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.isRFQTemplate = data["isRFQTemplate"];
            this.isAcknowledged = data["isAcknowledged"];
            this.acknowledgedBy = data["acknowledgedBy"];
            this.acknowledgedAt = data["acknowledgedAt"] ? moment(data["acknowledgedAt"].toString()) : <any>undefined;
            this.vendorId = data["vendorId"];
            this.assetOwnerId = data["assetOwnerId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditSupportContractDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditSupportContractDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["reference"] = this.reference;
        data["description"] = this.description;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["isRFQTemplate"] = this.isRFQTemplate;
        data["isAcknowledged"] = this.isAcknowledged;
        data["acknowledgedBy"] = this.acknowledgedBy;
        data["acknowledgedAt"] = this.acknowledgedAt ? this.acknowledgedAt.toISOString() : <any>undefined;
        data["vendorId"] = this.vendorId;
        data["assetOwnerId"] = this.assetOwnerId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditSupportContractDto {
    title: string;
    reference: string | undefined;
    description: string;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    isRFQTemplate: boolean | undefined;
    isAcknowledged: boolean | undefined;
    acknowledgedBy: string | undefined;
    acknowledgedAt: moment.Moment | undefined;
    vendorId: number | undefined;
    assetOwnerId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfSupportContractVendorLookupTableDto implements IPagedResultDtoOfSupportContractVendorLookupTableDto {
    totalCount!: number | undefined;
    items!: SupportContractVendorLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfSupportContractVendorLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(SupportContractVendorLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSupportContractVendorLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSupportContractVendorLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfSupportContractVendorLookupTableDto {
    totalCount: number | undefined;
    items: SupportContractVendorLookupTableDto[] | undefined;
}

export class SupportContractVendorLookupTableDto implements ISupportContractVendorLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: ISupportContractVendorLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): SupportContractVendorLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new SupportContractVendorLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface ISupportContractVendorLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfSupportContractAssetOwnerLookupTableDto implements IPagedResultDtoOfSupportContractAssetOwnerLookupTableDto {
    totalCount!: number | undefined;
    items!: SupportContractAssetOwnerLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfSupportContractAssetOwnerLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(SupportContractAssetOwnerLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSupportContractAssetOwnerLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSupportContractAssetOwnerLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfSupportContractAssetOwnerLookupTableDto {
    totalCount: number | undefined;
    items: SupportContractAssetOwnerLookupTableDto[] | undefined;
}

export class SupportContractAssetOwnerLookupTableDto implements ISupportContractAssetOwnerLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: ISupportContractAssetOwnerLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): SupportContractAssetOwnerLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new SupportContractAssetOwnerLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface ISupportContractAssetOwnerLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class GetSupportItemForEditOutput implements IGetSupportItemForEditOutput {
    supportItem!: CreateOrEditSupportItemDto | undefined;
    assetReference!: string | undefined;
    assetClassClass!: string | undefined;
    uomUnitOfMeasurement!: string | undefined;
    supportContractTitle!: string | undefined;
    consumableTypeType!: string | undefined;
    supportTypeType!: string | undefined;

    constructor(data?: IGetSupportItemForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.supportItem = data["supportItem"] ? CreateOrEditSupportItemDto.fromJS(data["supportItem"]) : <any>undefined;
            this.assetReference = data["assetReference"];
            this.assetClassClass = data["assetClassClass"];
            this.uomUnitOfMeasurement = data["uomUnitOfMeasurement"];
            this.supportContractTitle = data["supportContractTitle"];
            this.consumableTypeType = data["consumableTypeType"];
            this.supportTypeType = data["supportTypeType"];
        }
    }

    static fromJS(data: any): GetSupportItemForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSupportItemForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["supportItem"] = this.supportItem ? this.supportItem.toJSON() : <any>undefined;
        data["assetReference"] = this.assetReference;
        data["assetClassClass"] = this.assetClassClass;
        data["uomUnitOfMeasurement"] = this.uomUnitOfMeasurement;
        data["supportContractTitle"] = this.supportContractTitle;
        data["consumableTypeType"] = this.consumableTypeType;
        data["supportTypeType"] = this.supportTypeType;
        return data; 
    }
}

export interface IGetSupportItemForEditOutput {
    supportItem: CreateOrEditSupportItemDto | undefined;
    assetReference: string | undefined;
    assetClassClass: string | undefined;
    uomUnitOfMeasurement: string | undefined;
    supportContractTitle: string | undefined;
    consumableTypeType: string | undefined;
    supportTypeType: string | undefined;
}

export class CreateOrEditSupportItemDto implements ICreateOrEditSupportItemDto {
    description!: string;
    unitPrice!: number | undefined;
    frequency!: number | undefined;
    isAdHoc!: boolean | undefined;
    isChargeable!: boolean | undefined;
    isStandbyReplacementUnit!: boolean | undefined;
    assetId!: number | undefined;
    assetClassId!: number | undefined;
    uomId!: number | undefined;
    supportContractId!: number | undefined;
    consumableTypeId!: number | undefined;
    supportTypeId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditSupportItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.description = data["description"];
            this.unitPrice = data["unitPrice"];
            this.frequency = data["frequency"];
            this.isAdHoc = data["isAdHoc"];
            this.isChargeable = data["isChargeable"];
            this.isStandbyReplacementUnit = data["isStandbyReplacementUnit"];
            this.assetId = data["assetId"];
            this.assetClassId = data["assetClassId"];
            this.uomId = data["uomId"];
            this.supportContractId = data["supportContractId"];
            this.consumableTypeId = data["consumableTypeId"];
            this.supportTypeId = data["supportTypeId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditSupportItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditSupportItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["description"] = this.description;
        data["unitPrice"] = this.unitPrice;
        data["frequency"] = this.frequency;
        data["isAdHoc"] = this.isAdHoc;
        data["isChargeable"] = this.isChargeable;
        data["isStandbyReplacementUnit"] = this.isStandbyReplacementUnit;
        data["assetId"] = this.assetId;
        data["assetClassId"] = this.assetClassId;
        data["uomId"] = this.uomId;
        data["supportContractId"] = this.supportContractId;
        data["consumableTypeId"] = this.consumableTypeId;
        data["supportTypeId"] = this.supportTypeId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditSupportItemDto {
    description: string;
    unitPrice: number | undefined;
    frequency: number | undefined;
    isAdHoc: boolean | undefined;
    isChargeable: boolean | undefined;
    isStandbyReplacementUnit: boolean | undefined;
    assetId: number | undefined;
    assetClassId: number | undefined;
    uomId: number | undefined;
    supportContractId: number | undefined;
    consumableTypeId: number | undefined;
    supportTypeId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfSupportItemAssetLookupTableDto implements IPagedResultDtoOfSupportItemAssetLookupTableDto {
    totalCount!: number | undefined;
    items!: SupportItemAssetLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfSupportItemAssetLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(SupportItemAssetLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSupportItemAssetLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSupportItemAssetLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfSupportItemAssetLookupTableDto {
    totalCount: number | undefined;
    items: SupportItemAssetLookupTableDto[] | undefined;
}

export class SupportItemAssetLookupTableDto implements ISupportItemAssetLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: ISupportItemAssetLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): SupportItemAssetLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new SupportItemAssetLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface ISupportItemAssetLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfSupportItemAssetClassLookupTableDto implements IPagedResultDtoOfSupportItemAssetClassLookupTableDto {
    totalCount!: number | undefined;
    items!: SupportItemAssetClassLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfSupportItemAssetClassLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(SupportItemAssetClassLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSupportItemAssetClassLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSupportItemAssetClassLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfSupportItemAssetClassLookupTableDto {
    totalCount: number | undefined;
    items: SupportItemAssetClassLookupTableDto[] | undefined;
}

export class SupportItemAssetClassLookupTableDto implements ISupportItemAssetClassLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: ISupportItemAssetClassLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): SupportItemAssetClassLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new SupportItemAssetClassLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface ISupportItemAssetClassLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfSupportItemSupportContractLookupTableDto implements IPagedResultDtoOfSupportItemSupportContractLookupTableDto {
    totalCount!: number | undefined;
    items!: SupportItemSupportContractLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfSupportItemSupportContractLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(SupportItemSupportContractLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSupportItemSupportContractLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSupportItemSupportContractLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfSupportItemSupportContractLookupTableDto {
    totalCount: number | undefined;
    items: SupportItemSupportContractLookupTableDto[] | undefined;
}

export class SupportItemSupportContractLookupTableDto implements ISupportItemSupportContractLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: ISupportItemSupportContractLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): SupportItemSupportContractLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new SupportItemSupportContractLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface ISupportItemSupportContractLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfSupportItemConsumableTypeLookupTableDto implements IPagedResultDtoOfSupportItemConsumableTypeLookupTableDto {
    totalCount!: number | undefined;
    items!: SupportItemConsumableTypeLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfSupportItemConsumableTypeLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(SupportItemConsumableTypeLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSupportItemConsumableTypeLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSupportItemConsumableTypeLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfSupportItemConsumableTypeLookupTableDto {
    totalCount: number | undefined;
    items: SupportItemConsumableTypeLookupTableDto[] | undefined;
}

export class SupportItemConsumableTypeLookupTableDto implements ISupportItemConsumableTypeLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: ISupportItemConsumableTypeLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): SupportItemConsumableTypeLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new SupportItemConsumableTypeLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface ISupportItemConsumableTypeLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfSupportItemSupportTypeLookupTableDto implements IPagedResultDtoOfSupportItemSupportTypeLookupTableDto {
    totalCount!: number | undefined;
    items!: SupportItemSupportTypeLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfSupportItemSupportTypeLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(SupportItemSupportTypeLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfSupportItemSupportTypeLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfSupportItemSupportTypeLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfSupportItemSupportTypeLookupTableDto {
    totalCount: number | undefined;
    items: SupportItemSupportTypeLookupTableDto[] | undefined;
}

export class SupportItemSupportTypeLookupTableDto implements ISupportItemSupportTypeLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: ISupportItemSupportTypeLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): SupportItemSupportTypeLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new SupportItemSupportTypeLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface ISupportItemSupportTypeLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetSupportTypeForViewDto implements IPagedResultDtoOfGetSupportTypeForViewDto {
    totalCount!: number | undefined;
    items!: GetSupportTypeForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetSupportTypeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetSupportTypeForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetSupportTypeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetSupportTypeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetSupportTypeForViewDto {
    totalCount: number | undefined;
    items: GetSupportTypeForViewDto[] | undefined;
}

export class GetSupportTypeForViewDto implements IGetSupportTypeForViewDto {
    supportType!: SupportTypeDto | undefined;

    constructor(data?: IGetSupportTypeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.supportType = data["supportType"] ? SupportTypeDto.fromJS(data["supportType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetSupportTypeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetSupportTypeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["supportType"] = this.supportType ? this.supportType.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetSupportTypeForViewDto {
    supportType: SupportTypeDto | undefined;
}

export class SupportTypeDto implements ISupportTypeDto {
    type!: string | undefined;
    description!: string | undefined;
    id!: number | undefined;

    constructor(data?: ISupportTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.type = data["type"];
            this.description = data["description"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): SupportTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new SupportTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISupportTypeDto {
    type: string | undefined;
    description: string | undefined;
    id: number | undefined;
}

export class GetSupportTypeForEditOutput implements IGetSupportTypeForEditOutput {
    supportType!: CreateOrEditSupportTypeDto | undefined;

    constructor(data?: IGetSupportTypeForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.supportType = data["supportType"] ? CreateOrEditSupportTypeDto.fromJS(data["supportType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetSupportTypeForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSupportTypeForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["supportType"] = this.supportType ? this.supportType.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetSupportTypeForEditOutput {
    supportType: CreateOrEditSupportTypeDto | undefined;
}

export class CreateOrEditSupportTypeDto implements ICreateOrEditSupportTypeDto {
    type!: string;
    description!: string;
    id!: number | undefined;

    constructor(data?: ICreateOrEditSupportTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.type = data["type"];
            this.description = data["description"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditSupportTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditSupportTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditSupportTypeDto {
    type: string;
    description: string;
    id: number | undefined;
}

export class PagedResultDtoOfTenantListDto implements IPagedResultDtoOfTenantListDto {
    totalCount!: number | undefined;
    items!: TenantListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfTenantListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(TenantListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfTenantListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfTenantListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfTenantListDto {
    totalCount: number | undefined;
    items: TenantListDto[] | undefined;
}

export class TenantListDto implements ITenantListDto {
    tenancyName!: string | undefined;
    tenantType!: string | undefined;
    name!: string | undefined;
    editionDisplayName!: string | undefined;
    connectionString!: string | undefined;
    isActive!: boolean | undefined;
    creationTime!: moment.Moment | undefined;
    subscriptionEndDateUtc!: moment.Moment | undefined;
    editionId!: number | undefined;
    isInTrialPeriod!: boolean | undefined;
    id!: number | undefined;

    constructor(data?: ITenantListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.tenantType = data["tenantType"];
            this.name = data["name"];
            this.editionDisplayName = data["editionDisplayName"];
            this.connectionString = data["connectionString"];
            this.isActive = data["isActive"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.subscriptionEndDateUtc = data["subscriptionEndDateUtc"] ? moment(data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.editionId = data["editionId"];
            this.isInTrialPeriod = data["isInTrialPeriod"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantListDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["tenantType"] = this.tenantType;
        data["name"] = this.name;
        data["editionDisplayName"] = this.editionDisplayName;
        data["connectionString"] = this.connectionString;
        data["isActive"] = this.isActive;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toISOString() : <any>undefined;
        data["editionId"] = this.editionId;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITenantListDto {
    tenancyName: string | undefined;
    tenantType: string | undefined;
    name: string | undefined;
    editionDisplayName: string | undefined;
    connectionString: string | undefined;
    isActive: boolean | undefined;
    creationTime: moment.Moment | undefined;
    subscriptionEndDateUtc: moment.Moment | undefined;
    editionId: number | undefined;
    isInTrialPeriod: boolean | undefined;
    id: number | undefined;
}

export class CreateTenantInput implements ICreateTenantInput {
    tenancyName!: string;
    name!: string;
    tenantType!: string;
    adminEmailAddress!: string;
    adminPassword!: string | undefined;
    connectionString!: string | undefined;
    shouldChangePasswordOnNextLogin!: boolean | undefined;
    sendActivationEmail!: boolean | undefined;
    editionId!: number | undefined;
    isActive!: boolean | undefined;
    subscriptionEndDateUtc!: moment.Moment | undefined;
    isInTrialPeriod!: boolean | undefined;
    currencyId!: number | undefined;

    constructor(data?: ICreateTenantInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.tenantType = data["tenantType"];
            this.adminEmailAddress = data["adminEmailAddress"];
            this.adminPassword = data["adminPassword"];
            this.connectionString = data["connectionString"];
            this.shouldChangePasswordOnNextLogin = data["shouldChangePasswordOnNextLogin"];
            this.sendActivationEmail = data["sendActivationEmail"];
            this.editionId = data["editionId"];
            this.isActive = data["isActive"];
            this.subscriptionEndDateUtc = data["subscriptionEndDateUtc"] ? moment(data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.isInTrialPeriod = data["isInTrialPeriod"];
            this.currencyId = data["currencyId"];
        }
    }

    static fromJS(data: any): CreateTenantInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateTenantInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["tenantType"] = this.tenantType;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["adminPassword"] = this.adminPassword;
        data["connectionString"] = this.connectionString;
        data["shouldChangePasswordOnNextLogin"] = this.shouldChangePasswordOnNextLogin;
        data["sendActivationEmail"] = this.sendActivationEmail;
        data["editionId"] = this.editionId;
        data["isActive"] = this.isActive;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toISOString() : <any>undefined;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        data["currencyId"] = this.currencyId;
        return data; 
    }
}

export interface ICreateTenantInput {
    tenancyName: string;
    name: string;
    tenantType: string;
    adminEmailAddress: string;
    adminPassword: string | undefined;
    connectionString: string | undefined;
    shouldChangePasswordOnNextLogin: boolean | undefined;
    sendActivationEmail: boolean | undefined;
    editionId: number | undefined;
    isActive: boolean | undefined;
    subscriptionEndDateUtc: moment.Moment | undefined;
    isInTrialPeriod: boolean | undefined;
    currencyId: number | undefined;
}

export class TenantEditDto implements ITenantEditDto {
    tenancyName!: string;
    name!: string;
    connectionString!: string | undefined;
    editionId!: number | undefined;
    isActive!: boolean | undefined;
    subscriptionEndDateUtc!: moment.Moment | undefined;
    isInTrialPeriod!: boolean | undefined;
    logoId!: string | undefined;
    id!: number | undefined;

    constructor(data?: ITenantEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.connectionString = data["connectionString"];
            this.editionId = data["editionId"];
            this.isActive = data["isActive"];
            this.subscriptionEndDateUtc = data["subscriptionEndDateUtc"] ? moment(data["subscriptionEndDateUtc"].toString()) : <any>undefined;
            this.isInTrialPeriod = data["isInTrialPeriod"];
            this.logoId = data["logoId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): TenantEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["connectionString"] = this.connectionString;
        data["editionId"] = this.editionId;
        data["isActive"] = this.isActive;
        data["subscriptionEndDateUtc"] = this.subscriptionEndDateUtc ? this.subscriptionEndDateUtc.toISOString() : <any>undefined;
        data["isInTrialPeriod"] = this.isInTrialPeriod;
        data["logoId"] = this.logoId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ITenantEditDto {
    tenancyName: string;
    name: string;
    connectionString: string | undefined;
    editionId: number | undefined;
    isActive: boolean | undefined;
    subscriptionEndDateUtc: moment.Moment | undefined;
    isInTrialPeriod: boolean | undefined;
    logoId: string | undefined;
    id: number | undefined;
}

export class GetTenantFeaturesEditOutput implements IGetTenantFeaturesEditOutput {
    featureValues!: NameValueDto[] | undefined;
    features!: FlatFeatureDto[] | undefined;

    constructor(data?: IGetTenantFeaturesEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["featureValues"])) {
                this.featureValues = [] as any;
                for (let item of data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
            if (Array.isArray(data["features"])) {
                this.features = [] as any;
                for (let item of data["features"])
                    this.features!.push(FlatFeatureDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetTenantFeaturesEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetTenantFeaturesEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.featureValues)) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        if (Array.isArray(this.features)) {
            data["features"] = [];
            for (let item of this.features)
                data["features"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetTenantFeaturesEditOutput {
    featureValues: NameValueDto[] | undefined;
    features: FlatFeatureDto[] | undefined;
}

export class UpdateTenantFeaturesInput implements IUpdateTenantFeaturesInput {
    id!: number | undefined;
    featureValues!: NameValueDto[];

    constructor(data?: IUpdateTenantFeaturesInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.featureValues = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            if (Array.isArray(data["featureValues"])) {
                this.featureValues = [] as any;
                for (let item of data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UpdateTenantFeaturesInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateTenantFeaturesInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.featureValues)) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUpdateTenantFeaturesInput {
    id: number | undefined;
    featureValues: NameValueDto[];
}

export class EntityDto implements IEntityDto {
    id!: number | undefined;

    constructor(data?: IEntityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityDto {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IEntityDto {
    id: number | undefined;
}

export class GetMemberActivityOutput implements IGetMemberActivityOutput {
    memberActivities!: MemberActivity[] | undefined;

    constructor(data?: IGetMemberActivityOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["memberActivities"])) {
                this.memberActivities = [] as any;
                for (let item of data["memberActivities"])
                    this.memberActivities!.push(MemberActivity.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetMemberActivityOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetMemberActivityOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.memberActivities)) {
            data["memberActivities"] = [];
            for (let item of this.memberActivities)
                data["memberActivities"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetMemberActivityOutput {
    memberActivities: MemberActivity[] | undefined;
}

export class MemberActivity implements IMemberActivity {
    name!: string | undefined;
    earnings!: string | undefined;
    cases!: number | undefined;
    closed!: number | undefined;
    rate!: string | undefined;

    constructor(data?: IMemberActivity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.earnings = data["earnings"];
            this.cases = data["cases"];
            this.closed = data["closed"];
            this.rate = data["rate"];
        }
    }

    static fromJS(data: any): MemberActivity {
        data = typeof data === 'object' ? data : {};
        let result = new MemberActivity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["earnings"] = this.earnings;
        data["cases"] = this.cases;
        data["closed"] = this.closed;
        data["rate"] = this.rate;
        return data; 
    }
}

export interface IMemberActivity {
    name: string | undefined;
    earnings: string | undefined;
    cases: number | undefined;
    closed: number | undefined;
    rate: string | undefined;
}

export enum SalesSummaryDatePeriod {
    Daily = 1,
    Weekly = 2,
    Monthly = 3,
}

export enum AgedReceivablesDatePeriod {
    Daily = 1,
    Weekly = 2,
    Monthly = 3,
}

export class GetDashboardDataOutput implements IGetDashboardDataOutput {
    newIncidents!: number | undefined;
    newIncidentsChange!: number | undefined;
    newWorkOrders!: number | undefined;
    newWorkOrdersChange!: number | undefined;
    newEstimates!: number | undefined;
    newEstimatesChange!: number | undefined;
    newQuotations!: number | undefined;
    newQuotationsChange!: number | undefined;
    agedReceivables!: AgedReceivablesData[] | undefined;
    revenueForecast!: RevenueForecastData[] | undefined;
    agedReceivablesDate1!: string | undefined;
    agedReceivablesDate2!: string | undefined;
    agedReceivablesDate3!: string | undefined;
    agedReceivablesDate4!: string | undefined;
    agedReceivablesTotal1!: number | undefined;
    agedReceivablesTotal2!: number | undefined;
    agedReceivablesTotal3!: number | undefined;
    agedReceivablesTotal4!: number | undefined;
    totalProfit!: number | undefined;
    newFeedbacks!: number | undefined;
    newOrders!: number | undefined;
    newUsers!: number | undefined;
    newUsersChange!: number | undefined;
    salesSummary!: SalesSummaryData[] | undefined;
    totalSales!: number | undefined;
    revenue!: number | undefined;
    expenses!: number | undefined;
    growth!: number | undefined;
    transactionPercent!: number | undefined;
    newVisitPercent!: number | undefined;
    bouncePercent!: number | undefined;
    dailySales!: number[] | undefined;
    profitShares!: number[] | undefined;

    constructor(data?: IGetDashboardDataOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.newIncidents = data["newIncidents"];
            this.newIncidentsChange = data["newIncidentsChange"];
            this.newWorkOrders = data["newWorkOrders"];
            this.newWorkOrdersChange = data["newWorkOrdersChange"];
            this.newEstimates = data["newEstimates"];
            this.newEstimatesChange = data["newEstimatesChange"];
            this.newQuotations = data["newQuotations"];
            this.newQuotationsChange = data["newQuotationsChange"];
            if (Array.isArray(data["agedReceivables"])) {
                this.agedReceivables = [] as any;
                for (let item of data["agedReceivables"])
                    this.agedReceivables!.push(AgedReceivablesData.fromJS(item));
            }
            if (Array.isArray(data["revenueForecast"])) {
                this.revenueForecast = [] as any;
                for (let item of data["revenueForecast"])
                    this.revenueForecast!.push(RevenueForecastData.fromJS(item));
            }
            this.agedReceivablesDate1 = data["agedReceivablesDate1"];
            this.agedReceivablesDate2 = data["agedReceivablesDate2"];
            this.agedReceivablesDate3 = data["agedReceivablesDate3"];
            this.agedReceivablesDate4 = data["agedReceivablesDate4"];
            this.agedReceivablesTotal1 = data["agedReceivablesTotal1"];
            this.agedReceivablesTotal2 = data["agedReceivablesTotal2"];
            this.agedReceivablesTotal3 = data["agedReceivablesTotal3"];
            this.agedReceivablesTotal4 = data["agedReceivablesTotal4"];
            this.totalProfit = data["totalProfit"];
            this.newFeedbacks = data["newFeedbacks"];
            this.newOrders = data["newOrders"];
            this.newUsers = data["newUsers"];
            this.newUsersChange = data["newUsersChange"];
            if (Array.isArray(data["salesSummary"])) {
                this.salesSummary = [] as any;
                for (let item of data["salesSummary"])
                    this.salesSummary!.push(SalesSummaryData.fromJS(item));
            }
            this.totalSales = data["totalSales"];
            this.revenue = data["revenue"];
            this.expenses = data["expenses"];
            this.growth = data["growth"];
            this.transactionPercent = data["transactionPercent"];
            this.newVisitPercent = data["newVisitPercent"];
            this.bouncePercent = data["bouncePercent"];
            if (Array.isArray(data["dailySales"])) {
                this.dailySales = [] as any;
                for (let item of data["dailySales"])
                    this.dailySales!.push(item);
            }
            if (Array.isArray(data["profitShares"])) {
                this.profitShares = [] as any;
                for (let item of data["profitShares"])
                    this.profitShares!.push(item);
            }
        }
    }

    static fromJS(data: any): GetDashboardDataOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetDashboardDataOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["newIncidents"] = this.newIncidents;
        data["newIncidentsChange"] = this.newIncidentsChange;
        data["newWorkOrders"] = this.newWorkOrders;
        data["newWorkOrdersChange"] = this.newWorkOrdersChange;
        data["newEstimates"] = this.newEstimates;
        data["newEstimatesChange"] = this.newEstimatesChange;
        data["newQuotations"] = this.newQuotations;
        data["newQuotationsChange"] = this.newQuotationsChange;
        if (Array.isArray(this.agedReceivables)) {
            data["agedReceivables"] = [];
            for (let item of this.agedReceivables)
                data["agedReceivables"].push(item.toJSON());
        }
        if (Array.isArray(this.revenueForecast)) {
            data["revenueForecast"] = [];
            for (let item of this.revenueForecast)
                data["revenueForecast"].push(item.toJSON());
        }
        data["agedReceivablesDate1"] = this.agedReceivablesDate1;
        data["agedReceivablesDate2"] = this.agedReceivablesDate2;
        data["agedReceivablesDate3"] = this.agedReceivablesDate3;
        data["agedReceivablesDate4"] = this.agedReceivablesDate4;
        data["agedReceivablesTotal1"] = this.agedReceivablesTotal1;
        data["agedReceivablesTotal2"] = this.agedReceivablesTotal2;
        data["agedReceivablesTotal3"] = this.agedReceivablesTotal3;
        data["agedReceivablesTotal4"] = this.agedReceivablesTotal4;
        data["totalProfit"] = this.totalProfit;
        data["newFeedbacks"] = this.newFeedbacks;
        data["newOrders"] = this.newOrders;
        data["newUsers"] = this.newUsers;
        data["newUsersChange"] = this.newUsersChange;
        if (Array.isArray(this.salesSummary)) {
            data["salesSummary"] = [];
            for (let item of this.salesSummary)
                data["salesSummary"].push(item.toJSON());
        }
        data["totalSales"] = this.totalSales;
        data["revenue"] = this.revenue;
        data["expenses"] = this.expenses;
        data["growth"] = this.growth;
        data["transactionPercent"] = this.transactionPercent;
        data["newVisitPercent"] = this.newVisitPercent;
        data["bouncePercent"] = this.bouncePercent;
        if (Array.isArray(this.dailySales)) {
            data["dailySales"] = [];
            for (let item of this.dailySales)
                data["dailySales"].push(item);
        }
        if (Array.isArray(this.profitShares)) {
            data["profitShares"] = [];
            for (let item of this.profitShares)
                data["profitShares"].push(item);
        }
        return data; 
    }
}

export interface IGetDashboardDataOutput {
    newIncidents: number | undefined;
    newIncidentsChange: number | undefined;
    newWorkOrders: number | undefined;
    newWorkOrdersChange: number | undefined;
    newEstimates: number | undefined;
    newEstimatesChange: number | undefined;
    newQuotations: number | undefined;
    newQuotationsChange: number | undefined;
    agedReceivables: AgedReceivablesData[] | undefined;
    revenueForecast: RevenueForecastData[] | undefined;
    agedReceivablesDate1: string | undefined;
    agedReceivablesDate2: string | undefined;
    agedReceivablesDate3: string | undefined;
    agedReceivablesDate4: string | undefined;
    agedReceivablesTotal1: number | undefined;
    agedReceivablesTotal2: number | undefined;
    agedReceivablesTotal3: number | undefined;
    agedReceivablesTotal4: number | undefined;
    totalProfit: number | undefined;
    newFeedbacks: number | undefined;
    newOrders: number | undefined;
    newUsers: number | undefined;
    newUsersChange: number | undefined;
    salesSummary: SalesSummaryData[] | undefined;
    totalSales: number | undefined;
    revenue: number | undefined;
    expenses: number | undefined;
    growth: number | undefined;
    transactionPercent: number | undefined;
    newVisitPercent: number | undefined;
    bouncePercent: number | undefined;
    dailySales: number[] | undefined;
    profitShares: number[] | undefined;
}

export class AgedReceivablesData implements IAgedReceivablesData {
    period!: string | undefined;
    current!: number | undefined;
    over30!: number | undefined;
    over60!: number | undefined;
    over90!: number | undefined;
    over120!: number | undefined;

    constructor(data?: IAgedReceivablesData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.period = data["period"];
            this.current = data["current"];
            this.over30 = data["over30"];
            this.over60 = data["over60"];
            this.over90 = data["over90"];
            this.over120 = data["over120"];
        }
    }

    static fromJS(data: any): AgedReceivablesData {
        data = typeof data === 'object' ? data : {};
        let result = new AgedReceivablesData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["period"] = this.period;
        data["current"] = this.current;
        data["over30"] = this.over30;
        data["over60"] = this.over60;
        data["over90"] = this.over90;
        data["over120"] = this.over120;
        return data; 
    }
}

export interface IAgedReceivablesData {
    period: string | undefined;
    current: number | undefined;
    over30: number | undefined;
    over60: number | undefined;
    over90: number | undefined;
    over120: number | undefined;
}

export class RevenueForecastData implements IRevenueForecastData {
    period!: string | undefined;
    revenue!: number | undefined;

    constructor(data?: IRevenueForecastData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.period = data["period"];
            this.revenue = data["revenue"];
        }
    }

    static fromJS(data: any): RevenueForecastData {
        data = typeof data === 'object' ? data : {};
        let result = new RevenueForecastData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["period"] = this.period;
        data["revenue"] = this.revenue;
        return data; 
    }
}

export interface IRevenueForecastData {
    period: string | undefined;
    revenue: number | undefined;
}

export class SalesSummaryData implements ISalesSummaryData {
    period!: string | undefined;
    sales!: number | undefined;
    profit!: number | undefined;

    constructor(data?: ISalesSummaryData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.period = data["period"];
            this.sales = data["sales"];
            this.profit = data["profit"];
        }
    }

    static fromJS(data: any): SalesSummaryData {
        data = typeof data === 'object' ? data : {};
        let result = new SalesSummaryData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["period"] = this.period;
        data["sales"] = this.sales;
        data["profit"] = this.profit;
        return data; 
    }
}

export interface ISalesSummaryData {
    period: string | undefined;
    sales: number | undefined;
    profit: number | undefined;
}

export class GetSalesSummaryOutput implements IGetSalesSummaryOutput {
    salesSummary!: SalesSummaryData[] | undefined;

    constructor(data?: IGetSalesSummaryOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["salesSummary"])) {
                this.salesSummary = [] as any;
                for (let item of data["salesSummary"])
                    this.salesSummary!.push(SalesSummaryData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetSalesSummaryOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetSalesSummaryOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.salesSummary)) {
            data["salesSummary"] = [];
            for (let item of this.salesSummary)
                data["salesSummary"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetSalesSummaryOutput {
    salesSummary: SalesSummaryData[] | undefined;
}

export class GetRevenueForecastOutput implements IGetRevenueForecastOutput {
    revenueForecast!: RevenueForecastData[] | undefined;

    constructor(data?: IGetRevenueForecastOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["revenueForecast"])) {
                this.revenueForecast = [] as any;
                for (let item of data["revenueForecast"])
                    this.revenueForecast!.push(RevenueForecastData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetRevenueForecastOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRevenueForecastOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.revenueForecast)) {
            data["revenueForecast"] = [];
            for (let item of this.revenueForecast)
                data["revenueForecast"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetRevenueForecastOutput {
    revenueForecast: RevenueForecastData[] | undefined;
}

export class GetAgedReceivablesOutput implements IGetAgedReceivablesOutput {
    agedReceivables!: AgedReceivablesData[] | undefined;

    constructor(data?: IGetAgedReceivablesOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["agedReceivables"])) {
                this.agedReceivables = [] as any;
                for (let item of data["agedReceivables"])
                    this.agedReceivables!.push(AgedReceivablesData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetAgedReceivablesOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetAgedReceivablesOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.agedReceivables)) {
            data["agedReceivables"] = [];
            for (let item of this.agedReceivables)
                data["agedReceivables"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetAgedReceivablesOutput {
    agedReceivables: AgedReceivablesData[] | undefined;
}

export class GetRegionalStatsOutput implements IGetRegionalStatsOutput {
    stats!: RegionalStatCountry[] | undefined;

    constructor(data?: IGetRegionalStatsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["stats"])) {
                this.stats = [] as any;
                for (let item of data["stats"])
                    this.stats!.push(RegionalStatCountry.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetRegionalStatsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetRegionalStatsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.stats)) {
            data["stats"] = [];
            for (let item of this.stats)
                data["stats"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGetRegionalStatsOutput {
    stats: RegionalStatCountry[] | undefined;
}

export class RegionalStatCountry implements IRegionalStatCountry {
    countryName!: string | undefined;
    sales!: number | undefined;
    change!: number[] | undefined;
    averagePrice!: number | undefined;
    totalPrice!: number | undefined;

    constructor(data?: IRegionalStatCountry) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.countryName = data["countryName"];
            this.sales = data["sales"];
            if (Array.isArray(data["change"])) {
                this.change = [] as any;
                for (let item of data["change"])
                    this.change!.push(item);
            }
            this.averagePrice = data["averagePrice"];
            this.totalPrice = data["totalPrice"];
        }
    }

    static fromJS(data: any): RegionalStatCountry {
        data = typeof data === 'object' ? data : {};
        let result = new RegionalStatCountry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["countryName"] = this.countryName;
        data["sales"] = this.sales;
        if (Array.isArray(this.change)) {
            data["change"] = [];
            for (let item of this.change)
                data["change"].push(item);
        }
        data["averagePrice"] = this.averagePrice;
        data["totalPrice"] = this.totalPrice;
        return data; 
    }
}

export interface IRegionalStatCountry {
    countryName: string | undefined;
    sales: number | undefined;
    change: number[] | undefined;
    averagePrice: number | undefined;
    totalPrice: number | undefined;
}

export class GetGeneralStatsOutput implements IGetGeneralStatsOutput {
    transactionPercent!: number | undefined;
    newVisitPercent!: number | undefined;
    bouncePercent!: number | undefined;

    constructor(data?: IGetGeneralStatsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.transactionPercent = data["transactionPercent"];
            this.newVisitPercent = data["newVisitPercent"];
            this.bouncePercent = data["bouncePercent"];
        }
    }

    static fromJS(data: any): GetGeneralStatsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetGeneralStatsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["transactionPercent"] = this.transactionPercent;
        data["newVisitPercent"] = this.newVisitPercent;
        data["bouncePercent"] = this.bouncePercent;
        return data; 
    }
}

export interface IGetGeneralStatsOutput {
    transactionPercent: number | undefined;
    newVisitPercent: number | undefined;
    bouncePercent: number | undefined;
}

export class UserOrganizationUnit implements IUserOrganizationUnit {
    tenantId!: number | undefined;
    userId!: number | undefined;
    organizationUnitId!: number | undefined;
    isDeleted!: boolean | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IUserOrganizationUnit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.organizationUnitId = data["organizationUnitId"];
            this.isDeleted = data["isDeleted"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserOrganizationUnit {
        data = typeof data === 'object' ? data : {};
        let result = new UserOrganizationUnit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["organizationUnitId"] = this.organizationUnitId;
        data["isDeleted"] = this.isDeleted;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserOrganizationUnit {
    tenantId: number | undefined;
    userId: number | undefined;
    organizationUnitId: number | undefined;
    isDeleted: boolean | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class UserToken implements IUserToken {
    tenantId!: number | undefined;
    userId!: number | undefined;
    loginProvider!: string | undefined;
    name!: string | undefined;
    value!: string | undefined;
    expireDate!: moment.Moment | undefined;
    id!: number | undefined;

    constructor(data?: IUserToken) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.loginProvider = data["loginProvider"];
            this.name = data["name"];
            this.value = data["value"];
            this.expireDate = data["expireDate"] ? moment(data["expireDate"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserToken {
        data = typeof data === 'object' ? data : {};
        let result = new UserToken();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["loginProvider"] = this.loginProvider;
        data["name"] = this.name;
        data["value"] = this.value;
        data["expireDate"] = this.expireDate ? this.expireDate.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserToken {
    tenantId: number | undefined;
    userId: number | undefined;
    loginProvider: string | undefined;
    name: string | undefined;
    value: string | undefined;
    expireDate: moment.Moment | undefined;
    id: number | undefined;
}

export class User implements IUser {
    profilePictureId!: string | undefined;
    shouldChangePasswordOnNextLogin!: boolean | undefined;
    signInTokenExpireTimeUtc!: moment.Moment | undefined;
    signInToken!: string | undefined;
    googleAuthenticatorKey!: string | undefined;
    organizationUnits!: UserOrganizationUnit[] | undefined;
    normalizedUserName!: string;
    normalizedEmailAddress!: string;
    concurrencyStamp!: string | undefined;
    tokens!: UserToken[] | undefined;
    deleterUser!: User | undefined;
    creatorUser!: User | undefined;
    lastModifierUser!: User | undefined;
    authenticationSource!: string | undefined;
    userName!: string;
    tenantId!: number | undefined;
    emailAddress!: string;
    name!: string;
    surname!: string;
    readonly fullName!: string | undefined;
    password!: string;
    emailConfirmationCode!: string | undefined;
    passwordResetCode!: string | undefined;
    lockoutEndDateUtc!: moment.Moment | undefined;
    accessFailedCount!: number | undefined;
    isLockoutEnabled!: boolean | undefined;
    phoneNumber!: string | undefined;
    isPhoneNumberConfirmed!: boolean | undefined;
    securityStamp!: string | undefined;
    isTwoFactorEnabled!: boolean | undefined;
    logins!: UserLogin[] | undefined;
    roles!: UserRole[] | undefined;
    claims!: UserClaim[] | undefined;
    permissions!: UserPermissionSetting[] | undefined;
    settings!: Setting[] | undefined;
    isEmailConfirmed!: boolean | undefined;
    isActive!: boolean | undefined;
    isDeleted!: boolean | undefined;
    deleterUserId!: number | undefined;
    deletionTime!: moment.Moment | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.profilePictureId = data["profilePictureId"];
            this.shouldChangePasswordOnNextLogin = data["shouldChangePasswordOnNextLogin"];
            this.signInTokenExpireTimeUtc = data["signInTokenExpireTimeUtc"] ? moment(data["signInTokenExpireTimeUtc"].toString()) : <any>undefined;
            this.signInToken = data["signInToken"];
            this.googleAuthenticatorKey = data["googleAuthenticatorKey"];
            if (Array.isArray(data["organizationUnits"])) {
                this.organizationUnits = [] as any;
                for (let item of data["organizationUnits"])
                    this.organizationUnits!.push(UserOrganizationUnit.fromJS(item));
            }
            this.normalizedUserName = data["normalizedUserName"];
            this.normalizedEmailAddress = data["normalizedEmailAddress"];
            this.concurrencyStamp = data["concurrencyStamp"];
            if (Array.isArray(data["tokens"])) {
                this.tokens = [] as any;
                for (let item of data["tokens"])
                    this.tokens!.push(UserToken.fromJS(item));
            }
            this.deleterUser = data["deleterUser"] ? User.fromJS(data["deleterUser"]) : <any>undefined;
            this.creatorUser = data["creatorUser"] ? User.fromJS(data["creatorUser"]) : <any>undefined;
            this.lastModifierUser = data["lastModifierUser"] ? User.fromJS(data["lastModifierUser"]) : <any>undefined;
            this.authenticationSource = data["authenticationSource"];
            this.userName = data["userName"];
            this.tenantId = data["tenantId"];
            this.emailAddress = data["emailAddress"];
            this.name = data["name"];
            this.surname = data["surname"];
            (<any>this).fullName = data["fullName"];
            this.password = data["password"];
            this.emailConfirmationCode = data["emailConfirmationCode"];
            this.passwordResetCode = data["passwordResetCode"];
            this.lockoutEndDateUtc = data["lockoutEndDateUtc"] ? moment(data["lockoutEndDateUtc"].toString()) : <any>undefined;
            this.accessFailedCount = data["accessFailedCount"];
            this.isLockoutEnabled = data["isLockoutEnabled"];
            this.phoneNumber = data["phoneNumber"];
            this.isPhoneNumberConfirmed = data["isPhoneNumberConfirmed"];
            this.securityStamp = data["securityStamp"];
            this.isTwoFactorEnabled = data["isTwoFactorEnabled"];
            if (Array.isArray(data["logins"])) {
                this.logins = [] as any;
                for (let item of data["logins"])
                    this.logins!.push(UserLogin.fromJS(item));
            }
            if (Array.isArray(data["roles"])) {
                this.roles = [] as any;
                for (let item of data["roles"])
                    this.roles!.push(UserRole.fromJS(item));
            }
            if (Array.isArray(data["claims"])) {
                this.claims = [] as any;
                for (let item of data["claims"])
                    this.claims!.push(UserClaim.fromJS(item));
            }
            if (Array.isArray(data["permissions"])) {
                this.permissions = [] as any;
                for (let item of data["permissions"])
                    this.permissions!.push(UserPermissionSetting.fromJS(item));
            }
            if (Array.isArray(data["settings"])) {
                this.settings = [] as any;
                for (let item of data["settings"])
                    this.settings!.push(Setting.fromJS(item));
            }
            this.isEmailConfirmed = data["isEmailConfirmed"];
            this.isActive = data["isActive"];
            this.isDeleted = data["isDeleted"];
            this.deleterUserId = data["deleterUserId"];
            this.deletionTime = data["deletionTime"] ? moment(data["deletionTime"].toString()) : <any>undefined;
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["profilePictureId"] = this.profilePictureId;
        data["shouldChangePasswordOnNextLogin"] = this.shouldChangePasswordOnNextLogin;
        data["signInTokenExpireTimeUtc"] = this.signInTokenExpireTimeUtc ? this.signInTokenExpireTimeUtc.toISOString() : <any>undefined;
        data["signInToken"] = this.signInToken;
        data["googleAuthenticatorKey"] = this.googleAuthenticatorKey;
        if (Array.isArray(this.organizationUnits)) {
            data["organizationUnits"] = [];
            for (let item of this.organizationUnits)
                data["organizationUnits"].push(item.toJSON());
        }
        data["normalizedUserName"] = this.normalizedUserName;
        data["normalizedEmailAddress"] = this.normalizedEmailAddress;
        data["concurrencyStamp"] = this.concurrencyStamp;
        if (Array.isArray(this.tokens)) {
            data["tokens"] = [];
            for (let item of this.tokens)
                data["tokens"].push(item.toJSON());
        }
        data["deleterUser"] = this.deleterUser ? this.deleterUser.toJSON() : <any>undefined;
        data["creatorUser"] = this.creatorUser ? this.creatorUser.toJSON() : <any>undefined;
        data["lastModifierUser"] = this.lastModifierUser ? this.lastModifierUser.toJSON() : <any>undefined;
        data["authenticationSource"] = this.authenticationSource;
        data["userName"] = this.userName;
        data["tenantId"] = this.tenantId;
        data["emailAddress"] = this.emailAddress;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["fullName"] = this.fullName;
        data["password"] = this.password;
        data["emailConfirmationCode"] = this.emailConfirmationCode;
        data["passwordResetCode"] = this.passwordResetCode;
        data["lockoutEndDateUtc"] = this.lockoutEndDateUtc ? this.lockoutEndDateUtc.toISOString() : <any>undefined;
        data["accessFailedCount"] = this.accessFailedCount;
        data["isLockoutEnabled"] = this.isLockoutEnabled;
        data["phoneNumber"] = this.phoneNumber;
        data["isPhoneNumberConfirmed"] = this.isPhoneNumberConfirmed;
        data["securityStamp"] = this.securityStamp;
        data["isTwoFactorEnabled"] = this.isTwoFactorEnabled;
        if (Array.isArray(this.logins)) {
            data["logins"] = [];
            for (let item of this.logins)
                data["logins"].push(item.toJSON());
        }
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        if (Array.isArray(this.claims)) {
            data["claims"] = [];
            for (let item of this.claims)
                data["claims"].push(item.toJSON());
        }
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (Array.isArray(this.settings)) {
            data["settings"] = [];
            for (let item of this.settings)
                data["settings"].push(item.toJSON());
        }
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        data["isActive"] = this.isActive;
        data["isDeleted"] = this.isDeleted;
        data["deleterUserId"] = this.deleterUserId;
        data["deletionTime"] = this.deletionTime ? this.deletionTime.toISOString() : <any>undefined;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUser {
    profilePictureId: string | undefined;
    shouldChangePasswordOnNextLogin: boolean | undefined;
    signInTokenExpireTimeUtc: moment.Moment | undefined;
    signInToken: string | undefined;
    googleAuthenticatorKey: string | undefined;
    organizationUnits: UserOrganizationUnit[] | undefined;
    normalizedUserName: string;
    normalizedEmailAddress: string;
    concurrencyStamp: string | undefined;
    tokens: UserToken[] | undefined;
    deleterUser: User | undefined;
    creatorUser: User | undefined;
    lastModifierUser: User | undefined;
    authenticationSource: string | undefined;
    userName: string;
    tenantId: number | undefined;
    emailAddress: string;
    name: string;
    surname: string;
    fullName: string | undefined;
    password: string;
    emailConfirmationCode: string | undefined;
    passwordResetCode: string | undefined;
    lockoutEndDateUtc: moment.Moment | undefined;
    accessFailedCount: number | undefined;
    isLockoutEnabled: boolean | undefined;
    phoneNumber: string | undefined;
    isPhoneNumberConfirmed: boolean | undefined;
    securityStamp: string | undefined;
    isTwoFactorEnabled: boolean | undefined;
    logins: UserLogin[] | undefined;
    roles: UserRole[] | undefined;
    claims: UserClaim[] | undefined;
    permissions: UserPermissionSetting[] | undefined;
    settings: Setting[] | undefined;
    isEmailConfirmed: boolean | undefined;
    isActive: boolean | undefined;
    isDeleted: boolean | undefined;
    deleterUserId: number | undefined;
    deletionTime: moment.Moment | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class UserLogin implements IUserLogin {
    tenantId!: number | undefined;
    userId!: number | undefined;
    loginProvider!: string;
    providerKey!: string;
    id!: number | undefined;

    constructor(data?: IUserLogin) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.loginProvider = data["loginProvider"];
            this.providerKey = data["providerKey"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserLogin {
        data = typeof data === 'object' ? data : {};
        let result = new UserLogin();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["loginProvider"] = this.loginProvider;
        data["providerKey"] = this.providerKey;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserLogin {
    tenantId: number | undefined;
    userId: number | undefined;
    loginProvider: string;
    providerKey: string;
    id: number | undefined;
}

export class UserRole implements IUserRole {
    tenantId!: number | undefined;
    userId!: number | undefined;
    roleId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IUserRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.roleId = data["roleId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserRole {
        data = typeof data === 'object' ? data : {};
        let result = new UserRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["roleId"] = this.roleId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserRole {
    tenantId: number | undefined;
    userId: number | undefined;
    roleId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class UserClaim implements IUserClaim {
    tenantId!: number | undefined;
    userId!: number | undefined;
    claimType!: string | undefined;
    claimValue!: string | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IUserClaim) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.claimType = data["claimType"];
            this.claimValue = data["claimValue"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserClaim {
        data = typeof data === 'object' ? data : {};
        let result = new UserClaim();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["claimType"] = this.claimType;
        data["claimValue"] = this.claimValue;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserClaim {
    tenantId: number | undefined;
    userId: number | undefined;
    claimType: string | undefined;
    claimValue: string | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class UserPermissionSetting implements IUserPermissionSetting {
    userId!: number | undefined;
    tenantId!: number | undefined;
    name!: string;
    isGranted!: boolean | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IUserPermissionSetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.tenantId = data["tenantId"];
            this.name = data["name"];
            this.isGranted = data["isGranted"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserPermissionSetting {
        data = typeof data === 'object' ? data : {};
        let result = new UserPermissionSetting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["tenantId"] = this.tenantId;
        data["name"] = this.name;
        data["isGranted"] = this.isGranted;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserPermissionSetting {
    userId: number | undefined;
    tenantId: number | undefined;
    name: string;
    isGranted: boolean | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class Setting implements ISetting {
    tenantId!: number | undefined;
    userId!: number | undefined;
    name!: string;
    value!: string | undefined;
    lastModificationTime!: moment.Moment | undefined;
    lastModifierUserId!: number | undefined;
    creationTime!: moment.Moment | undefined;
    creatorUserId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ISetting) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
            this.name = data["name"];
            this.value = data["value"];
            this.lastModificationTime = data["lastModificationTime"] ? moment(data["lastModificationTime"].toString()) : <any>undefined;
            this.lastModifierUserId = data["lastModifierUserId"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.creatorUserId = data["creatorUserId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): Setting {
        data = typeof data === 'object' ? data : {};
        let result = new Setting();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        data["name"] = this.name;
        data["value"] = this.value;
        data["lastModificationTime"] = this.lastModificationTime ? this.lastModificationTime.toISOString() : <any>undefined;
        data["lastModifierUserId"] = this.lastModifierUserId;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["creatorUserId"] = this.creatorUserId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ISetting {
    tenantId: number | undefined;
    userId: number | undefined;
    name: string;
    value: string | undefined;
    lastModificationTime: moment.Moment | undefined;
    lastModifierUserId: number | undefined;
    creationTime: moment.Moment | undefined;
    creatorUserId: number | undefined;
    id: number | undefined;
}

export class RegisterTenantInput implements IRegisterTenantInput {
    tenancyName!: string;
    name!: string;
    tenantType!: string;
    adminEmailAddress!: string;
    adminPassword!: string | undefined;
    captchaResponse!: string | undefined;
    subscriptionStartType!: SubscriptionStartType | undefined;
    editionId!: number | undefined;

    constructor(data?: IRegisterTenantInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.tenantType = data["tenantType"];
            this.adminEmailAddress = data["adminEmailAddress"];
            this.adminPassword = data["adminPassword"];
            this.captchaResponse = data["captchaResponse"];
            this.subscriptionStartType = data["subscriptionStartType"];
            this.editionId = data["editionId"];
        }
    }

    static fromJS(data: any): RegisterTenantInput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterTenantInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["tenantType"] = this.tenantType;
        data["adminEmailAddress"] = this.adminEmailAddress;
        data["adminPassword"] = this.adminPassword;
        data["captchaResponse"] = this.captchaResponse;
        data["subscriptionStartType"] = this.subscriptionStartType;
        data["editionId"] = this.editionId;
        return data; 
    }
}

export interface IRegisterTenantInput {
    tenancyName: string;
    name: string;
    tenantType: string;
    adminEmailAddress: string;
    adminPassword: string | undefined;
    captchaResponse: string | undefined;
    subscriptionStartType: SubscriptionStartType | undefined;
    editionId: number | undefined;
}

export enum SubscriptionStartType {
    Free = 1,
    Trial = 2,
    Paid = 3,
}

export class RegisterTenantOutput implements IRegisterTenantOutput {
    tenantId!: number | undefined;
    tenancyName!: string | undefined;
    name!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    isTenantActive!: boolean | undefined;
    isActive!: boolean | undefined;
    isEmailConfirmationRequired!: boolean | undefined;

    constructor(data?: IRegisterTenantOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.tenancyName = data["tenancyName"];
            this.name = data["name"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.isTenantActive = data["isTenantActive"];
            this.isActive = data["isActive"];
            this.isEmailConfirmationRequired = data["isEmailConfirmationRequired"];
        }
    }

    static fromJS(data: any): RegisterTenantOutput {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterTenantOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["tenancyName"] = this.tenancyName;
        data["name"] = this.name;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["isTenantActive"] = this.isTenantActive;
        data["isActive"] = this.isActive;
        data["isEmailConfirmationRequired"] = this.isEmailConfirmationRequired;
        return data; 
    }
}

export interface IRegisterTenantOutput {
    tenantId: number | undefined;
    tenancyName: string | undefined;
    name: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    isTenantActive: boolean | undefined;
    isActive: boolean | undefined;
    isEmailConfirmationRequired: boolean | undefined;
}

export class EditionsSelectOutput implements IEditionsSelectOutput {
    allFeatures!: FlatFeatureSelectDto[] | undefined;
    editionsWithFeatures!: EditionWithFeaturesDto[] | undefined;

    constructor(data?: IEditionsSelectOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["allFeatures"])) {
                this.allFeatures = [] as any;
                for (let item of data["allFeatures"])
                    this.allFeatures!.push(FlatFeatureSelectDto.fromJS(item));
            }
            if (Array.isArray(data["editionsWithFeatures"])) {
                this.editionsWithFeatures = [] as any;
                for (let item of data["editionsWithFeatures"])
                    this.editionsWithFeatures!.push(EditionWithFeaturesDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EditionsSelectOutput {
        data = typeof data === 'object' ? data : {};
        let result = new EditionsSelectOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.allFeatures)) {
            data["allFeatures"] = [];
            for (let item of this.allFeatures)
                data["allFeatures"].push(item.toJSON());
        }
        if (Array.isArray(this.editionsWithFeatures)) {
            data["editionsWithFeatures"] = [];
            for (let item of this.editionsWithFeatures)
                data["editionsWithFeatures"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IEditionsSelectOutput {
    allFeatures: FlatFeatureSelectDto[] | undefined;
    editionsWithFeatures: EditionWithFeaturesDto[] | undefined;
}

export class FlatFeatureSelectDto implements IFlatFeatureSelectDto {
    parentName!: string | undefined;
    name!: string | undefined;
    displayName!: string | undefined;
    description!: string | undefined;
    defaultValue!: string | undefined;
    inputType!: IInputType | undefined;
    textHtmlColor!: string | undefined;

    constructor(data?: IFlatFeatureSelectDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.parentName = data["parentName"];
            this.name = data["name"];
            this.displayName = data["displayName"];
            this.description = data["description"];
            this.defaultValue = data["defaultValue"];
            this.inputType = data["inputType"] ? IInputType.fromJS(data["inputType"]) : <any>undefined;
            this.textHtmlColor = data["textHtmlColor"];
        }
    }

    static fromJS(data: any): FlatFeatureSelectDto {
        data = typeof data === 'object' ? data : {};
        let result = new FlatFeatureSelectDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parentName"] = this.parentName;
        data["name"] = this.name;
        data["displayName"] = this.displayName;
        data["description"] = this.description;
        data["defaultValue"] = this.defaultValue;
        data["inputType"] = this.inputType ? this.inputType.toJSON() : <any>undefined;
        data["textHtmlColor"] = this.textHtmlColor;
        return data; 
    }
}

export interface IFlatFeatureSelectDto {
    parentName: string | undefined;
    name: string | undefined;
    displayName: string | undefined;
    description: string | undefined;
    defaultValue: string | undefined;
    inputType: IInputType | undefined;
    textHtmlColor: string | undefined;
}

export class EditionWithFeaturesDto implements IEditionWithFeaturesDto {
    edition!: EditionSelectDto | undefined;
    featureValues!: NameValueDto[] | undefined;

    constructor(data?: IEditionWithFeaturesDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.edition = data["edition"] ? EditionSelectDto.fromJS(data["edition"]) : <any>undefined;
            if (Array.isArray(data["featureValues"])) {
                this.featureValues = [] as any;
                for (let item of data["featureValues"])
                    this.featureValues!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EditionWithFeaturesDto {
        data = typeof data === 'object' ? data : {};
        let result = new EditionWithFeaturesDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["edition"] = this.edition ? this.edition.toJSON() : <any>undefined;
        if (Array.isArray(this.featureValues)) {
            data["featureValues"] = [];
            for (let item of this.featureValues)
                data["featureValues"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IEditionWithFeaturesDto {
    edition: EditionSelectDto | undefined;
    featureValues: NameValueDto[] | undefined;
}

export class IInputType implements IIInputType {
    readonly name!: string | undefined;
    readonly attributes!: { [key: string]: any; } | undefined;
    validator!: IValueValidator | undefined;

    constructor(data?: IIInputType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            (<any>this).name = data["name"];
            if (data["attributes"]) {
                (<any>this).attributes = {} as any;
                for (let key in data["attributes"]) {
                    if (data["attributes"].hasOwnProperty(key))
                        (<any>this).attributes![key] = data["attributes"][key];
                }
            }
            this.validator = data["validator"] ? IValueValidator.fromJS(data["validator"]) : <any>undefined;
        }
    }

    static fromJS(data: any): IInputType {
        data = typeof data === 'object' ? data : {};
        let result = new IInputType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        if (this.attributes) {
            data["attributes"] = {};
            for (let key in this.attributes) {
                if (this.attributes.hasOwnProperty(key))
                    data["attributes"][key] = this.attributes[key];
            }
        }
        data["validator"] = this.validator ? this.validator.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IIInputType {
    name: string | undefined;
    attributes: { [key: string]: any; } | undefined;
    validator: IValueValidator | undefined;
}

export class TenantSettingsEditDto implements ITenantSettingsEditDto {
    general!: GeneralSettingsEditDto | undefined;
    userManagement!: TenantUserManagementSettingsEditDto;
    email!: TenantEmailSettingsEditDto | undefined;
    ldap!: LdapSettingsEditDto | undefined;
    security!: SecuritySettingsEditDto;
    billing!: TenantBillingSettingsEditDto | undefined;
    otherSettings!: TenantOtherSettingsEditDto | undefined;

    constructor(data?: ITenantSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.userManagement = new TenantUserManagementSettingsEditDto();
            this.security = new SecuritySettingsEditDto();
        }
    }

    init(data?: any) {
        if (data) {
            this.general = data["general"] ? GeneralSettingsEditDto.fromJS(data["general"]) : <any>undefined;
            this.userManagement = data["userManagement"] ? TenantUserManagementSettingsEditDto.fromJS(data["userManagement"]) : new TenantUserManagementSettingsEditDto();
            this.email = data["email"] ? TenantEmailSettingsEditDto.fromJS(data["email"]) : <any>undefined;
            this.ldap = data["ldap"] ? LdapSettingsEditDto.fromJS(data["ldap"]) : <any>undefined;
            this.security = data["security"] ? SecuritySettingsEditDto.fromJS(data["security"]) : new SecuritySettingsEditDto();
            this.billing = data["billing"] ? TenantBillingSettingsEditDto.fromJS(data["billing"]) : <any>undefined;
            this.otherSettings = data["otherSettings"] ? TenantOtherSettingsEditDto.fromJS(data["otherSettings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TenantSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["general"] = this.general ? this.general.toJSON() : <any>undefined;
        data["userManagement"] = this.userManagement ? this.userManagement.toJSON() : <any>undefined;
        data["email"] = this.email ? this.email.toJSON() : <any>undefined;
        data["ldap"] = this.ldap ? this.ldap.toJSON() : <any>undefined;
        data["security"] = this.security ? this.security.toJSON() : <any>undefined;
        data["billing"] = this.billing ? this.billing.toJSON() : <any>undefined;
        data["otherSettings"] = this.otherSettings ? this.otherSettings.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ITenantSettingsEditDto {
    general: GeneralSettingsEditDto | undefined;
    userManagement: TenantUserManagementSettingsEditDto;
    email: TenantEmailSettingsEditDto | undefined;
    ldap: LdapSettingsEditDto | undefined;
    security: SecuritySettingsEditDto;
    billing: TenantBillingSettingsEditDto | undefined;
    otherSettings: TenantOtherSettingsEditDto | undefined;
}

export class TenantUserManagementSettingsEditDto implements ITenantUserManagementSettingsEditDto {
    allowSelfRegistration!: boolean | undefined;
    isNewRegisteredUserActiveByDefault!: boolean | undefined;
    isEmailConfirmationRequiredForLogin!: boolean | undefined;
    useCaptchaOnRegistration!: boolean | undefined;
    useCaptchaOnLogin!: boolean | undefined;
    isCookieConsentEnabled!: boolean | undefined;
    isQuickThemeSelectEnabled!: boolean | undefined;
    sessionTimeOutSettings!: SessionTimeOutSettingsEditDto | undefined;

    constructor(data?: ITenantUserManagementSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.allowSelfRegistration = data["allowSelfRegistration"];
            this.isNewRegisteredUserActiveByDefault = data["isNewRegisteredUserActiveByDefault"];
            this.isEmailConfirmationRequiredForLogin = data["isEmailConfirmationRequiredForLogin"];
            this.useCaptchaOnRegistration = data["useCaptchaOnRegistration"];
            this.useCaptchaOnLogin = data["useCaptchaOnLogin"];
            this.isCookieConsentEnabled = data["isCookieConsentEnabled"];
            this.isQuickThemeSelectEnabled = data["isQuickThemeSelectEnabled"];
            this.sessionTimeOutSettings = data["sessionTimeOutSettings"] ? SessionTimeOutSettingsEditDto.fromJS(data["sessionTimeOutSettings"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TenantUserManagementSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantUserManagementSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["allowSelfRegistration"] = this.allowSelfRegistration;
        data["isNewRegisteredUserActiveByDefault"] = this.isNewRegisteredUserActiveByDefault;
        data["isEmailConfirmationRequiredForLogin"] = this.isEmailConfirmationRequiredForLogin;
        data["useCaptchaOnRegistration"] = this.useCaptchaOnRegistration;
        data["useCaptchaOnLogin"] = this.useCaptchaOnLogin;
        data["isCookieConsentEnabled"] = this.isCookieConsentEnabled;
        data["isQuickThemeSelectEnabled"] = this.isQuickThemeSelectEnabled;
        data["sessionTimeOutSettings"] = this.sessionTimeOutSettings ? this.sessionTimeOutSettings.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ITenantUserManagementSettingsEditDto {
    allowSelfRegistration: boolean | undefined;
    isNewRegisteredUserActiveByDefault: boolean | undefined;
    isEmailConfirmationRequiredForLogin: boolean | undefined;
    useCaptchaOnRegistration: boolean | undefined;
    useCaptchaOnLogin: boolean | undefined;
    isCookieConsentEnabled: boolean | undefined;
    isQuickThemeSelectEnabled: boolean | undefined;
    sessionTimeOutSettings: SessionTimeOutSettingsEditDto | undefined;
}

export class TenantEmailSettingsEditDto implements ITenantEmailSettingsEditDto {
    useHostDefaultEmailSettings!: boolean | undefined;
    defaultFromAddress!: string | undefined;
    defaultFromDisplayName!: string | undefined;
    smtpHost!: string | undefined;
    smtpPort!: number | undefined;
    smtpUserName!: string | undefined;
    smtpPassword!: string | undefined;
    smtpDomain!: string | undefined;
    smtpEnableSsl!: boolean | undefined;
    smtpUseDefaultCredentials!: boolean | undefined;

    constructor(data?: ITenantEmailSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.useHostDefaultEmailSettings = data["useHostDefaultEmailSettings"];
            this.defaultFromAddress = data["defaultFromAddress"];
            this.defaultFromDisplayName = data["defaultFromDisplayName"];
            this.smtpHost = data["smtpHost"];
            this.smtpPort = data["smtpPort"];
            this.smtpUserName = data["smtpUserName"];
            this.smtpPassword = data["smtpPassword"];
            this.smtpDomain = data["smtpDomain"];
            this.smtpEnableSsl = data["smtpEnableSsl"];
            this.smtpUseDefaultCredentials = data["smtpUseDefaultCredentials"];
        }
    }

    static fromJS(data: any): TenantEmailSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantEmailSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["useHostDefaultEmailSettings"] = this.useHostDefaultEmailSettings;
        data["defaultFromAddress"] = this.defaultFromAddress;
        data["defaultFromDisplayName"] = this.defaultFromDisplayName;
        data["smtpHost"] = this.smtpHost;
        data["smtpPort"] = this.smtpPort;
        data["smtpUserName"] = this.smtpUserName;
        data["smtpPassword"] = this.smtpPassword;
        data["smtpDomain"] = this.smtpDomain;
        data["smtpEnableSsl"] = this.smtpEnableSsl;
        data["smtpUseDefaultCredentials"] = this.smtpUseDefaultCredentials;
        return data; 
    }
}

export interface ITenantEmailSettingsEditDto {
    useHostDefaultEmailSettings: boolean | undefined;
    defaultFromAddress: string | undefined;
    defaultFromDisplayName: string | undefined;
    smtpHost: string | undefined;
    smtpPort: number | undefined;
    smtpUserName: string | undefined;
    smtpPassword: string | undefined;
    smtpDomain: string | undefined;
    smtpEnableSsl: boolean | undefined;
    smtpUseDefaultCredentials: boolean | undefined;
}

export class LdapSettingsEditDto implements ILdapSettingsEditDto {
    isModuleEnabled!: boolean | undefined;
    isEnabled!: boolean | undefined;
    domain!: string | undefined;
    userName!: string | undefined;
    password!: string | undefined;

    constructor(data?: ILdapSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isModuleEnabled = data["isModuleEnabled"];
            this.isEnabled = data["isEnabled"];
            this.domain = data["domain"];
            this.userName = data["userName"];
            this.password = data["password"];
        }
    }

    static fromJS(data: any): LdapSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new LdapSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isModuleEnabled"] = this.isModuleEnabled;
        data["isEnabled"] = this.isEnabled;
        data["domain"] = this.domain;
        data["userName"] = this.userName;
        data["password"] = this.password;
        return data; 
    }
}

export interface ILdapSettingsEditDto {
    isModuleEnabled: boolean | undefined;
    isEnabled: boolean | undefined;
    domain: string | undefined;
    userName: string | undefined;
    password: string | undefined;
}

export class TenantBillingSettingsEditDto implements ITenantBillingSettingsEditDto {
    legalName!: string | undefined;
    address!: string | undefined;
    taxVatNo!: string | undefined;

    constructor(data?: ITenantBillingSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.legalName = data["legalName"];
            this.address = data["address"];
            this.taxVatNo = data["taxVatNo"];
        }
    }

    static fromJS(data: any): TenantBillingSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantBillingSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["legalName"] = this.legalName;
        data["address"] = this.address;
        data["taxVatNo"] = this.taxVatNo;
        return data; 
    }
}

export interface ITenantBillingSettingsEditDto {
    legalName: string | undefined;
    address: string | undefined;
    taxVatNo: string | undefined;
}

export class TenantOtherSettingsEditDto implements ITenantOtherSettingsEditDto {
    isQuickThemeSelectEnabled!: boolean | undefined;

    constructor(data?: ITenantOtherSettingsEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.isQuickThemeSelectEnabled = data["isQuickThemeSelectEnabled"];
        }
    }

    static fromJS(data: any): TenantOtherSettingsEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new TenantOtherSettingsEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isQuickThemeSelectEnabled"] = this.isQuickThemeSelectEnabled;
        return data; 
    }
}

export interface ITenantOtherSettingsEditDto {
    isQuickThemeSelectEnabled: boolean | undefined;
}

export enum SettingScopes {
    Application = 1,
    Tenant = 2,
    User = 4,
    All = 7,
}

export class ListResultDtoOfNameValueDto implements IListResultDtoOfNameValueDto {
    items!: NameValueDto[] | undefined;

    constructor(data?: IListResultDtoOfNameValueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(NameValueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfNameValueDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfNameValueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfNameValueDto {
    items: NameValueDto[] | undefined;
}

export class AuthenticateModel implements IAuthenticateModel {
    userNameOrEmailAddress!: string;
    password!: string;
    twoFactorVerificationCode!: string | undefined;
    rememberClient!: boolean | undefined;
    twoFactorRememberClientToken!: string | undefined;
    singleSignIn!: boolean | undefined;
    returnUrl!: string | undefined;
    captchaResponse!: string | undefined;

    constructor(data?: IAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userNameOrEmailAddress = data["userNameOrEmailAddress"];
            this.password = data["password"];
            this.twoFactorVerificationCode = data["twoFactorVerificationCode"];
            this.rememberClient = data["rememberClient"];
            this.twoFactorRememberClientToken = data["twoFactorRememberClientToken"];
            this.singleSignIn = data["singleSignIn"];
            this.returnUrl = data["returnUrl"];
            this.captchaResponse = data["captchaResponse"];
        }
    }

    static fromJS(data: any): AuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userNameOrEmailAddress"] = this.userNameOrEmailAddress;
        data["password"] = this.password;
        data["twoFactorVerificationCode"] = this.twoFactorVerificationCode;
        data["rememberClient"] = this.rememberClient;
        data["twoFactorRememberClientToken"] = this.twoFactorRememberClientToken;
        data["singleSignIn"] = this.singleSignIn;
        data["returnUrl"] = this.returnUrl;
        data["captchaResponse"] = this.captchaResponse;
        return data; 
    }
}

export interface IAuthenticateModel {
    userNameOrEmailAddress: string;
    password: string;
    twoFactorVerificationCode: string | undefined;
    rememberClient: boolean | undefined;
    twoFactorRememberClientToken: string | undefined;
    singleSignIn: boolean | undefined;
    returnUrl: string | undefined;
    captchaResponse: string | undefined;
}

export class AuthenticateResultModel implements IAuthenticateResultModel {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number | undefined;
    shouldResetPassword!: boolean | undefined;
    passwordResetCode!: string | undefined;
    userId!: number | undefined;
    requiresTwoFactorVerification!: boolean | undefined;
    twoFactorAuthProviders!: string[] | undefined;
    twoFactorRememberClientToken!: string | undefined;
    returnUrl!: string | undefined;
    refreshToken!: string | undefined;

    constructor(data?: IAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
            this.shouldResetPassword = data["shouldResetPassword"];
            this.passwordResetCode = data["passwordResetCode"];
            this.userId = data["userId"];
            this.requiresTwoFactorVerification = data["requiresTwoFactorVerification"];
            if (Array.isArray(data["twoFactorAuthProviders"])) {
                this.twoFactorAuthProviders = [] as any;
                for (let item of data["twoFactorAuthProviders"])
                    this.twoFactorAuthProviders!.push(item);
            }
            this.twoFactorRememberClientToken = data["twoFactorRememberClientToken"];
            this.returnUrl = data["returnUrl"];
            this.refreshToken = data["refreshToken"];
        }
    }

    static fromJS(data: any): AuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["shouldResetPassword"] = this.shouldResetPassword;
        data["passwordResetCode"] = this.passwordResetCode;
        data["userId"] = this.userId;
        data["requiresTwoFactorVerification"] = this.requiresTwoFactorVerification;
        if (Array.isArray(this.twoFactorAuthProviders)) {
            data["twoFactorAuthProviders"] = [];
            for (let item of this.twoFactorAuthProviders)
                data["twoFactorAuthProviders"].push(item);
        }
        data["twoFactorRememberClientToken"] = this.twoFactorRememberClientToken;
        data["returnUrl"] = this.returnUrl;
        data["refreshToken"] = this.refreshToken;
        return data; 
    }
}

export interface IAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
    shouldResetPassword: boolean | undefined;
    passwordResetCode: string | undefined;
    userId: number | undefined;
    requiresTwoFactorVerification: boolean | undefined;
    twoFactorAuthProviders: string[] | undefined;
    twoFactorRememberClientToken: string | undefined;
    returnUrl: string | undefined;
    refreshToken: string | undefined;
}

export class RefreshTokenResult implements IRefreshTokenResult {
    accessToken!: string | undefined;

    constructor(data?: IRefreshTokenResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
        }
    }

    static fromJS(data: any): RefreshTokenResult {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshTokenResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        return data; 
    }
}

export interface IRefreshTokenResult {
    accessToken: string | undefined;
}

export class SendTwoFactorAuthCodeModel implements ISendTwoFactorAuthCodeModel {
    userId!: number | undefined;
    provider!: string;

    constructor(data?: ISendTwoFactorAuthCodeModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.userId = data["userId"];
            this.provider = data["provider"];
        }
    }

    static fromJS(data: any): SendTwoFactorAuthCodeModel {
        data = typeof data === 'object' ? data : {};
        let result = new SendTwoFactorAuthCodeModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["provider"] = this.provider;
        return data; 
    }
}

export interface ISendTwoFactorAuthCodeModel {
    userId: number | undefined;
    provider: string;
}

export class ImpersonatedAuthenticateResultModel implements IImpersonatedAuthenticateResultModel {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number | undefined;

    constructor(data?: IImpersonatedAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
        }
    }

    static fromJS(data: any): ImpersonatedAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ImpersonatedAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        return data; 
    }
}

export interface IImpersonatedAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
}

export class SwitchedAccountAuthenticateResultModel implements ISwitchedAccountAuthenticateResultModel {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number | undefined;

    constructor(data?: ISwitchedAccountAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
        }
    }

    static fromJS(data: any): SwitchedAccountAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new SwitchedAccountAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        return data; 
    }
}

export interface ISwitchedAccountAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
}

export class ExternalLoginProviderInfoModel implements IExternalLoginProviderInfoModel {
    name!: string | undefined;
    clientId!: string | undefined;
    additionalParams!: { [key: string]: string; } | undefined;

    constructor(data?: IExternalLoginProviderInfoModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.clientId = data["clientId"];
            if (data["additionalParams"]) {
                this.additionalParams = {} as any;
                for (let key in data["additionalParams"]) {
                    if (data["additionalParams"].hasOwnProperty(key))
                        this.additionalParams![key] = data["additionalParams"][key];
                }
            }
        }
    }

    static fromJS(data: any): ExternalLoginProviderInfoModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalLoginProviderInfoModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["clientId"] = this.clientId;
        if (this.additionalParams) {
            data["additionalParams"] = {};
            for (let key in this.additionalParams) {
                if (this.additionalParams.hasOwnProperty(key))
                    data["additionalParams"][key] = this.additionalParams[key];
            }
        }
        return data; 
    }
}

export interface IExternalLoginProviderInfoModel {
    name: string | undefined;
    clientId: string | undefined;
    additionalParams: { [key: string]: string; } | undefined;
}

export class ExternalAuthenticateModel implements IExternalAuthenticateModel {
    authProvider!: string;
    providerKey!: string;
    providerAccessCode!: string;
    returnUrl!: string | undefined;
    singleSignIn!: boolean | undefined;

    constructor(data?: IExternalAuthenticateModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.authProvider = data["authProvider"];
            this.providerKey = data["providerKey"];
            this.providerAccessCode = data["providerAccessCode"];
            this.returnUrl = data["returnUrl"];
            this.singleSignIn = data["singleSignIn"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authProvider"] = this.authProvider;
        data["providerKey"] = this.providerKey;
        data["providerAccessCode"] = this.providerAccessCode;
        data["returnUrl"] = this.returnUrl;
        data["singleSignIn"] = this.singleSignIn;
        return data; 
    }
}

export interface IExternalAuthenticateModel {
    authProvider: string;
    providerKey: string;
    providerAccessCode: string;
    returnUrl: string | undefined;
    singleSignIn: boolean | undefined;
}

export class ExternalAuthenticateResultModel implements IExternalAuthenticateResultModel {
    accessToken!: string | undefined;
    encryptedAccessToken!: string | undefined;
    expireInSeconds!: number | undefined;
    waitingForActivation!: boolean | undefined;
    returnUrl!: string | undefined;

    constructor(data?: IExternalAuthenticateResultModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.accessToken = data["accessToken"];
            this.encryptedAccessToken = data["encryptedAccessToken"];
            this.expireInSeconds = data["expireInSeconds"];
            this.waitingForActivation = data["waitingForActivation"];
            this.returnUrl = data["returnUrl"];
        }
    }

    static fromJS(data: any): ExternalAuthenticateResultModel {
        data = typeof data === 'object' ? data : {};
        let result = new ExternalAuthenticateResultModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["encryptedAccessToken"] = this.encryptedAccessToken;
        data["expireInSeconds"] = this.expireInSeconds;
        data["waitingForActivation"] = this.waitingForActivation;
        data["returnUrl"] = this.returnUrl;
        return data; 
    }
}

export interface IExternalAuthenticateResultModel {
    accessToken: string | undefined;
    encryptedAccessToken: string | undefined;
    expireInSeconds: number | undefined;
    waitingForActivation: boolean | undefined;
    returnUrl: string | undefined;
}

export class PagedResultDtoOfGetUomForViewDto implements IPagedResultDtoOfGetUomForViewDto {
    totalCount!: number | undefined;
    items!: GetUomForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetUomForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetUomForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetUomForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetUomForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetUomForViewDto {
    totalCount: number | undefined;
    items: GetUomForViewDto[] | undefined;
}

export class GetUomForViewDto implements IGetUomForViewDto {
    uom!: UomDto | undefined;

    constructor(data?: IGetUomForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.uom = data["uom"] ? UomDto.fromJS(data["uom"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetUomForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetUomForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["uom"] = this.uom ? this.uom.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetUomForViewDto {
    uom: UomDto | undefined;
}

export class UomDto implements IUomDto {
    unitOfMeasurement!: string | undefined;
    id!: number | undefined;

    constructor(data?: IUomDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.unitOfMeasurement = data["unitOfMeasurement"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UomDto {
        data = typeof data === 'object' ? data : {};
        let result = new UomDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["unitOfMeasurement"] = this.unitOfMeasurement;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUomDto {
    unitOfMeasurement: string | undefined;
    id: number | undefined;
}

export class GetUomForEditOutput implements IGetUomForEditOutput {
    uom!: CreateOrEditUomDto | undefined;

    constructor(data?: IGetUomForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.uom = data["uom"] ? CreateOrEditUomDto.fromJS(data["uom"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetUomForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUomForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["uom"] = this.uom ? this.uom.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetUomForEditOutput {
    uom: CreateOrEditUomDto | undefined;
}

export class CreateOrEditUomDto implements ICreateOrEditUomDto {
    unitOfMeasurement!: string;
    id!: number | undefined;

    constructor(data?: ICreateOrEditUomDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.unitOfMeasurement = data["unitOfMeasurement"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditUomDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditUomDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["unitOfMeasurement"] = this.unitOfMeasurement;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditUomDto {
    unitOfMeasurement: string;
    id: number | undefined;
}

export class PagedResultDtoOfUomLookupTableDto implements IPagedResultDtoOfUomLookupTableDto {
    totalCount!: number | undefined;
    items!: UomLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfUomLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(UomLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUomLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUomLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfUomLookupTableDto {
    totalCount: number | undefined;
    items: UomLookupTableDto[] | undefined;
}

export class UomLookupTableDto implements IUomLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IUomLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): UomLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new UomLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IUomLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class GetUsageMetricRecordForEditOutput implements IGetUsageMetricRecordForEditOutput {
    usageMetricRecord!: CreateOrEditUsageMetricRecordDto | undefined;
    usageMetricMetric!: string | undefined;

    constructor(data?: IGetUsageMetricRecordForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.usageMetricRecord = data["usageMetricRecord"] ? CreateOrEditUsageMetricRecordDto.fromJS(data["usageMetricRecord"]) : <any>undefined;
            this.usageMetricMetric = data["usageMetricMetric"];
        }
    }

    static fromJS(data: any): GetUsageMetricRecordForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUsageMetricRecordForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["usageMetricRecord"] = this.usageMetricRecord ? this.usageMetricRecord.toJSON() : <any>undefined;
        data["usageMetricMetric"] = this.usageMetricMetric;
        return data; 
    }
}

export interface IGetUsageMetricRecordForEditOutput {
    usageMetricRecord: CreateOrEditUsageMetricRecordDto | undefined;
    usageMetricMetric: string | undefined;
}

export class CreateOrEditUsageMetricRecordDto implements ICreateOrEditUsageMetricRecordDto {
    reference!: string | undefined;
    startTime!: moment.Moment | undefined;
    endTime!: moment.Moment | undefined;
    unitsConsumed!: number | undefined;
    usageMetricId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditUsageMetricRecordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reference = data["reference"];
            this.startTime = data["startTime"] ? moment(data["startTime"].toString()) : <any>undefined;
            this.endTime = data["endTime"] ? moment(data["endTime"].toString()) : <any>undefined;
            this.unitsConsumed = data["unitsConsumed"];
            this.usageMetricId = data["usageMetricId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditUsageMetricRecordDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditUsageMetricRecordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reference"] = this.reference;
        data["startTime"] = this.startTime ? this.startTime.toISOString() : <any>undefined;
        data["endTime"] = this.endTime ? this.endTime.toISOString() : <any>undefined;
        data["unitsConsumed"] = this.unitsConsumed;
        data["usageMetricId"] = this.usageMetricId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditUsageMetricRecordDto {
    reference: string | undefined;
    startTime: moment.Moment | undefined;
    endTime: moment.Moment | undefined;
    unitsConsumed: number | undefined;
    usageMetricId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfUsageMetricRecordUsageMetricLookupTableDto implements IPagedResultDtoOfUsageMetricRecordUsageMetricLookupTableDto {
    totalCount!: number | undefined;
    items!: UsageMetricRecordUsageMetricLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfUsageMetricRecordUsageMetricLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(UsageMetricRecordUsageMetricLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUsageMetricRecordUsageMetricLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUsageMetricRecordUsageMetricLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfUsageMetricRecordUsageMetricLookupTableDto {
    totalCount: number | undefined;
    items: UsageMetricRecordUsageMetricLookupTableDto[] | undefined;
}

export class UsageMetricRecordUsageMetricLookupTableDto implements IUsageMetricRecordUsageMetricLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IUsageMetricRecordUsageMetricLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): UsageMetricRecordUsageMetricLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new UsageMetricRecordUsageMetricLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IUsageMetricRecordUsageMetricLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetUsageMetricForViewDto implements IPagedResultDtoOfGetUsageMetricForViewDto {
    totalCount!: number | undefined;
    items!: GetUsageMetricForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetUsageMetricForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetUsageMetricForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetUsageMetricForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetUsageMetricForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetUsageMetricForViewDto {
    totalCount: number | undefined;
    items: GetUsageMetricForViewDto[] | undefined;
}

export class GetUsageMetricForEditOutput implements IGetUsageMetricForEditOutput {
    usageMetric!: CreateOrEditUsageMetricDto | undefined;
    leaseItemItem!: string | undefined;
    uomUnitOfMeasurement!: string | undefined;
    assetReference!: string | undefined;

    constructor(data?: IGetUsageMetricForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.usageMetric = data["usageMetric"] ? CreateOrEditUsageMetricDto.fromJS(data["usageMetric"]) : <any>undefined;
            this.leaseItemItem = data["leaseItemItem"];
            this.uomUnitOfMeasurement = data["uomUnitOfMeasurement"];
            this.assetReference = data["assetReference"];
        }
    }

    static fromJS(data: any): GetUsageMetricForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUsageMetricForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["usageMetric"] = this.usageMetric ? this.usageMetric.toJSON() : <any>undefined;
        data["leaseItemItem"] = this.leaseItemItem;
        data["uomUnitOfMeasurement"] = this.uomUnitOfMeasurement;
        data["assetReference"] = this.assetReference;
        return data; 
    }
}

export interface IGetUsageMetricForEditOutput {
    usageMetric: CreateOrEditUsageMetricDto | undefined;
    leaseItemItem: string | undefined;
    uomUnitOfMeasurement: string | undefined;
    assetReference: string | undefined;
}

export class CreateOrEditUsageMetricDto implements ICreateOrEditUsageMetricDto {
    metric!: string;
    description!: string | undefined;
    leaseItemId!: number | undefined;
    assetId!: number | undefined;
    uomId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditUsageMetricDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.metric = data["metric"];
            this.description = data["description"];
            this.leaseItemId = data["leaseItemId"];
            this.assetId = data["assetId"];
            this.uomId = data["uomId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditUsageMetricDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditUsageMetricDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["metric"] = this.metric;
        data["description"] = this.description;
        data["leaseItemId"] = this.leaseItemId;
        data["assetId"] = this.assetId;
        data["uomId"] = this.uomId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditUsageMetricDto {
    metric: string;
    description: string | undefined;
    leaseItemId: number | undefined;
    assetId: number | undefined;
    uomId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfUsageMetricLeaseItemLookupTableDto implements IPagedResultDtoOfUsageMetricLeaseItemLookupTableDto {
    totalCount!: number | undefined;
    items!: UsageMetricLeaseItemLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfUsageMetricLeaseItemLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(UsageMetricLeaseItemLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUsageMetricLeaseItemLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUsageMetricLeaseItemLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfUsageMetricLeaseItemLookupTableDto {
    totalCount: number | undefined;
    items: UsageMetricLeaseItemLookupTableDto[] | undefined;
}

export class UsageMetricLeaseItemLookupTableDto implements IUsageMetricLeaseItemLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IUsageMetricLeaseItemLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): UsageMetricLeaseItemLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new UsageMetricLeaseItemLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IUsageMetricLeaseItemLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfUsageMetricAssetLookupTableDto implements IPagedResultDtoOfUsageMetricAssetLookupTableDto {
    totalCount!: number | undefined;
    items!: UsageMetricAssetLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfUsageMetricAssetLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(UsageMetricAssetLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUsageMetricAssetLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUsageMetricAssetLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfUsageMetricAssetLookupTableDto {
    totalCount: number | undefined;
    items: UsageMetricAssetLookupTableDto[] | undefined;
}

export class UsageMetricAssetLookupTableDto implements IUsageMetricAssetLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IUsageMetricAssetLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): UsageMetricAssetLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new UsageMetricAssetLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IUsageMetricAssetLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfUserListDto implements IPagedResultDtoOfUserListDto {
    totalCount!: number | undefined;
    items!: UserListDto[] | undefined;

    constructor(data?: IPagedResultDtoOfUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(UserListDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfUserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfUserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfUserListDto {
    totalCount: number | undefined;
    items: UserListDto[] | undefined;
}

export class UserListDto implements IUserListDto {
    name!: string | undefined;
    surname!: string | undefined;
    userName!: string | undefined;
    emailAddress!: string | undefined;
    phoneNumber!: string | undefined;
    profilePictureId!: string | undefined;
    isEmailConfirmed!: boolean | undefined;
    roles!: UserListRoleDto[] | undefined;
    isActive!: boolean | undefined;
    creationTime!: moment.Moment | undefined;
    id!: number | undefined;

    constructor(data?: IUserListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.phoneNumber = data["phoneNumber"];
            this.profilePictureId = data["profilePictureId"];
            this.isEmailConfirmed = data["isEmailConfirmed"];
            if (Array.isArray(data["roles"])) {
                this.roles = [] as any;
                for (let item of data["roles"])
                    this.roles!.push(UserListRoleDto.fromJS(item));
            }
            this.isActive = data["isActive"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
            this.id = data["id"];
        }
    }

    static fromJS(data: any): UserListDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["profilePictureId"] = this.profilePictureId;
        data["isEmailConfirmed"] = this.isEmailConfirmed;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        data["isActive"] = this.isActive;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        data["id"] = this.id;
        return data; 
    }
}

export interface IUserListDto {
    name: string | undefined;
    surname: string | undefined;
    userName: string | undefined;
    emailAddress: string | undefined;
    phoneNumber: string | undefined;
    profilePictureId: string | undefined;
    isEmailConfirmed: boolean | undefined;
    roles: UserListRoleDto[] | undefined;
    isActive: boolean | undefined;
    creationTime: moment.Moment | undefined;
    id: number | undefined;
}

export class UserListRoleDto implements IUserListRoleDto {
    roleId!: number | undefined;
    roleName!: string | undefined;

    constructor(data?: IUserListRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.roleId = data["roleId"];
            this.roleName = data["roleName"];
        }
    }

    static fromJS(data: any): UserListRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserListRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        return data; 
    }
}

export interface IUserListRoleDto {
    roleId: number | undefined;
    roleName: string | undefined;
}

export class GetUserForEditOutput implements IGetUserForEditOutput {
    profilePictureId!: string | undefined;
    user!: UserEditDto | undefined;
    roles!: UserRoleDto[] | undefined;
    allOrganizationUnits!: OrganizationUnitDto[] | undefined;
    memberedOrganizationUnits!: string[] | undefined;

    constructor(data?: IGetUserForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.profilePictureId = data["profilePictureId"];
            this.user = data["user"] ? UserEditDto.fromJS(data["user"]) : <any>undefined;
            if (Array.isArray(data["roles"])) {
                this.roles = [] as any;
                for (let item of data["roles"])
                    this.roles!.push(UserRoleDto.fromJS(item));
            }
            if (Array.isArray(data["allOrganizationUnits"])) {
                this.allOrganizationUnits = [] as any;
                for (let item of data["allOrganizationUnits"])
                    this.allOrganizationUnits!.push(OrganizationUnitDto.fromJS(item));
            }
            if (Array.isArray(data["memberedOrganizationUnits"])) {
                this.memberedOrganizationUnits = [] as any;
                for (let item of data["memberedOrganizationUnits"])
                    this.memberedOrganizationUnits!.push(item);
            }
        }
    }

    static fromJS(data: any): GetUserForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["profilePictureId"] = this.profilePictureId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        if (Array.isArray(this.allOrganizationUnits)) {
            data["allOrganizationUnits"] = [];
            for (let item of this.allOrganizationUnits)
                data["allOrganizationUnits"].push(item.toJSON());
        }
        if (Array.isArray(this.memberedOrganizationUnits)) {
            data["memberedOrganizationUnits"] = [];
            for (let item of this.memberedOrganizationUnits)
                data["memberedOrganizationUnits"].push(item);
        }
        return data; 
    }
}

export interface IGetUserForEditOutput {
    profilePictureId: string | undefined;
    user: UserEditDto | undefined;
    roles: UserRoleDto[] | undefined;
    allOrganizationUnits: OrganizationUnitDto[] | undefined;
    memberedOrganizationUnits: string[] | undefined;
}

export class UserEditDto implements IUserEditDto {
    id!: number | undefined;
    name!: string;
    surname!: string;
    userName!: string;
    emailAddress!: string;
    phoneNumber!: string | undefined;
    password!: string | undefined;
    isActive!: boolean | undefined;
    shouldChangePasswordOnNextLogin!: boolean | undefined;
    isTwoFactorEnabled!: boolean | undefined;
    isLockoutEnabled!: boolean | undefined;

    constructor(data?: IUserEditDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.name = data["name"];
            this.surname = data["surname"];
            this.userName = data["userName"];
            this.emailAddress = data["emailAddress"];
            this.phoneNumber = data["phoneNumber"];
            this.password = data["password"];
            this.isActive = data["isActive"];
            this.shouldChangePasswordOnNextLogin = data["shouldChangePasswordOnNextLogin"];
            this.isTwoFactorEnabled = data["isTwoFactorEnabled"];
            this.isLockoutEnabled = data["isLockoutEnabled"];
        }
    }

    static fromJS(data: any): UserEditDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserEditDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["surname"] = this.surname;
        data["userName"] = this.userName;
        data["emailAddress"] = this.emailAddress;
        data["phoneNumber"] = this.phoneNumber;
        data["password"] = this.password;
        data["isActive"] = this.isActive;
        data["shouldChangePasswordOnNextLogin"] = this.shouldChangePasswordOnNextLogin;
        data["isTwoFactorEnabled"] = this.isTwoFactorEnabled;
        data["isLockoutEnabled"] = this.isLockoutEnabled;
        return data; 
    }
}

export interface IUserEditDto {
    id: number | undefined;
    name: string;
    surname: string;
    userName: string;
    emailAddress: string;
    phoneNumber: string | undefined;
    password: string | undefined;
    isActive: boolean | undefined;
    shouldChangePasswordOnNextLogin: boolean | undefined;
    isTwoFactorEnabled: boolean | undefined;
    isLockoutEnabled: boolean | undefined;
}

export class UserRoleDto implements IUserRoleDto {
    roleId!: number | undefined;
    roleName!: string | undefined;
    roleDisplayName!: string | undefined;
    isAssigned!: boolean | undefined;
    inheritedFromOrganizationUnit!: boolean | undefined;

    constructor(data?: IUserRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.roleId = data["roleId"];
            this.roleName = data["roleName"];
            this.roleDisplayName = data["roleDisplayName"];
            this.isAssigned = data["isAssigned"];
            this.inheritedFromOrganizationUnit = data["inheritedFromOrganizationUnit"];
        }
    }

    static fromJS(data: any): UserRoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserRoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleId"] = this.roleId;
        data["roleName"] = this.roleName;
        data["roleDisplayName"] = this.roleDisplayName;
        data["isAssigned"] = this.isAssigned;
        data["inheritedFromOrganizationUnit"] = this.inheritedFromOrganizationUnit;
        return data; 
    }
}

export interface IUserRoleDto {
    roleId: number | undefined;
    roleName: string | undefined;
    roleDisplayName: string | undefined;
    isAssigned: boolean | undefined;
    inheritedFromOrganizationUnit: boolean | undefined;
}

export class GetUserPermissionsForEditOutput implements IGetUserPermissionsForEditOutput {
    permissions!: FlatPermissionDto[] | undefined;
    grantedPermissionNames!: string[] | undefined;

    constructor(data?: IGetUserPermissionsForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["permissions"])) {
                this.permissions = [] as any;
                for (let item of data["permissions"])
                    this.permissions!.push(FlatPermissionDto.fromJS(item));
            }
            if (Array.isArray(data["grantedPermissionNames"])) {
                this.grantedPermissionNames = [] as any;
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames!.push(item);
            }
        }
    }

    static fromJS(data: any): GetUserPermissionsForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetUserPermissionsForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item.toJSON());
        }
        if (Array.isArray(this.grantedPermissionNames)) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }
}

export interface IGetUserPermissionsForEditOutput {
    permissions: FlatPermissionDto[] | undefined;
    grantedPermissionNames: string[] | undefined;
}

export class EntityDtoOfInt64 implements IEntityDtoOfInt64 {
    id!: number | undefined;

    constructor(data?: IEntityDtoOfInt64) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
        }
    }

    static fromJS(data: any): EntityDtoOfInt64 {
        data = typeof data === 'object' ? data : {};
        let result = new EntityDtoOfInt64();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IEntityDtoOfInt64 {
    id: number | undefined;
}

export class UpdateUserPermissionsInput implements IUpdateUserPermissionsInput {
    id!: number | undefined;
    grantedPermissionNames!: string[];

    constructor(data?: IUpdateUserPermissionsInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.grantedPermissionNames = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            if (Array.isArray(data["grantedPermissionNames"])) {
                this.grantedPermissionNames = [] as any;
                for (let item of data["grantedPermissionNames"])
                    this.grantedPermissionNames!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateUserPermissionsInput {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserPermissionsInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.grantedPermissionNames)) {
            data["grantedPermissionNames"] = [];
            for (let item of this.grantedPermissionNames)
                data["grantedPermissionNames"].push(item);
        }
        return data; 
    }
}

export interface IUpdateUserPermissionsInput {
    id: number | undefined;
    grantedPermissionNames: string[];
}

export class CreateOrUpdateUserInput implements ICreateOrUpdateUserInput {
    user!: UserEditDto;
    assignedRoleNames!: string[];
    sendActivationEmail!: boolean | undefined;
    setRandomPassword!: boolean | undefined;
    organizationUnits!: number[] | undefined;

    constructor(data?: ICreateOrUpdateUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new UserEditDto();
            this.assignedRoleNames = [];
        }
    }

    init(data?: any) {
        if (data) {
            this.user = data["user"] ? UserEditDto.fromJS(data["user"]) : new UserEditDto();
            if (Array.isArray(data["assignedRoleNames"])) {
                this.assignedRoleNames = [] as any;
                for (let item of data["assignedRoleNames"])
                    this.assignedRoleNames!.push(item);
            }
            this.sendActivationEmail = data["sendActivationEmail"];
            this.setRandomPassword = data["setRandomPassword"];
            if (Array.isArray(data["organizationUnits"])) {
                this.organizationUnits = [] as any;
                for (let item of data["organizationUnits"])
                    this.organizationUnits!.push(item);
            }
        }
    }

    static fromJS(data: any): CreateOrUpdateUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrUpdateUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (Array.isArray(this.assignedRoleNames)) {
            data["assignedRoleNames"] = [];
            for (let item of this.assignedRoleNames)
                data["assignedRoleNames"].push(item);
        }
        data["sendActivationEmail"] = this.sendActivationEmail;
        data["setRandomPassword"] = this.setRandomPassword;
        if (Array.isArray(this.organizationUnits)) {
            data["organizationUnits"] = [];
            for (let item of this.organizationUnits)
                data["organizationUnits"].push(item);
        }
        return data; 
    }
}

export interface ICreateOrUpdateUserInput {
    user: UserEditDto;
    assignedRoleNames: string[];
    sendActivationEmail: boolean | undefined;
    setRandomPassword: boolean | undefined;
    organizationUnits: number[] | undefined;
}

export class LinkToUserInput implements ILinkToUserInput {
    tenancyName!: string | undefined;
    usernameOrEmailAddress!: string;
    password!: string;

    constructor(data?: ILinkToUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.usernameOrEmailAddress = data["usernameOrEmailAddress"];
            this.password = data["password"];
        }
    }

    static fromJS(data: any): LinkToUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new LinkToUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["usernameOrEmailAddress"] = this.usernameOrEmailAddress;
        data["password"] = this.password;
        return data; 
    }
}

export interface ILinkToUserInput {
    tenancyName: string | undefined;
    usernameOrEmailAddress: string;
    password: string;
}

export class PagedResultDtoOfLinkedUserDto implements IPagedResultDtoOfLinkedUserDto {
    totalCount!: number | undefined;
    items!: LinkedUserDto[] | undefined;

    constructor(data?: IPagedResultDtoOfLinkedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(LinkedUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfLinkedUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfLinkedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfLinkedUserDto {
    totalCount: number | undefined;
    items: LinkedUserDto[] | undefined;
}

export class LinkedUserDto implements ILinkedUserDto {
    tenantId!: number | undefined;
    tenancyName!: string | undefined;
    username!: string | undefined;
    id!: number | undefined;

    constructor(data?: ILinkedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.tenancyName = data["tenancyName"];
            this.username = data["username"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): LinkedUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new LinkedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["tenancyName"] = this.tenancyName;
        data["username"] = this.username;
        data["id"] = this.id;
        return data; 
    }
}

export interface ILinkedUserDto {
    tenantId: number | undefined;
    tenancyName: string | undefined;
    username: string | undefined;
    id: number | undefined;
}

export class ListResultDtoOfLinkedUserDto implements IListResultDtoOfLinkedUserDto {
    items!: LinkedUserDto[] | undefined;

    constructor(data?: IListResultDtoOfLinkedUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(LinkedUserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfLinkedUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfLinkedUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfLinkedUserDto {
    items: LinkedUserDto[] | undefined;
}

export class UnlinkUserInput implements IUnlinkUserInput {
    tenantId!: number | undefined;
    userId!: number | undefined;

    constructor(data?: IUnlinkUserInput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenantId = data["tenantId"];
            this.userId = data["userId"];
        }
    }

    static fromJS(data: any): UnlinkUserInput {
        data = typeof data === 'object' ? data : {};
        let result = new UnlinkUserInput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenantId"] = this.tenantId;
        data["userId"] = this.userId;
        return data; 
    }
}

export interface IUnlinkUserInput {
    tenantId: number | undefined;
    userId: number | undefined;
}

export class ListResultDtoOfUserLoginAttemptDto implements IListResultDtoOfUserLoginAttemptDto {
    items!: UserLoginAttemptDto[] | undefined;

    constructor(data?: IListResultDtoOfUserLoginAttemptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(UserLoginAttemptDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ListResultDtoOfUserLoginAttemptDto {
        data = typeof data === 'object' ? data : {};
        let result = new ListResultDtoOfUserLoginAttemptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IListResultDtoOfUserLoginAttemptDto {
    items: UserLoginAttemptDto[] | undefined;
}

export class UserLoginAttemptDto implements IUserLoginAttemptDto {
    tenancyName!: string | undefined;
    userNameOrEmail!: string | undefined;
    clientIpAddress!: string | undefined;
    clientName!: string | undefined;
    browserInfo!: string | undefined;
    result!: string | undefined;
    creationTime!: moment.Moment | undefined;

    constructor(data?: IUserLoginAttemptDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.tenancyName = data["tenancyName"];
            this.userNameOrEmail = data["userNameOrEmail"];
            this.clientIpAddress = data["clientIpAddress"];
            this.clientName = data["clientName"];
            this.browserInfo = data["browserInfo"];
            this.result = data["result"];
            this.creationTime = data["creationTime"] ? moment(data["creationTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UserLoginAttemptDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserLoginAttemptDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tenancyName"] = this.tenancyName;
        data["userNameOrEmail"] = this.userNameOrEmail;
        data["clientIpAddress"] = this.clientIpAddress;
        data["clientName"] = this.clientName;
        data["browserInfo"] = this.browserInfo;
        data["result"] = this.result;
        data["creationTime"] = this.creationTime ? this.creationTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IUserLoginAttemptDto {
    tenancyName: string | undefined;
    userNameOrEmail: string | undefined;
    clientIpAddress: string | undefined;
    clientName: string | undefined;
    browserInfo: string | undefined;
    result: string | undefined;
    creationTime: moment.Moment | undefined;
}

export class PagedResultDtoOfGetVendorChargeDetailForViewDto implements IPagedResultDtoOfGetVendorChargeDetailForViewDto {
    totalCount!: number | undefined;
    items!: GetVendorChargeDetailForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetVendorChargeDetailForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetVendorChargeDetailForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetVendorChargeDetailForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetVendorChargeDetailForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetVendorChargeDetailForViewDto {
    totalCount: number | undefined;
    items: GetVendorChargeDetailForViewDto[] | undefined;
}

export class GetVendorChargeDetailForViewDto implements IGetVendorChargeDetailForViewDto {
    vendorChargeDetail!: VendorChargeDetailDto | undefined;

    constructor(data?: IGetVendorChargeDetailForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.vendorChargeDetail = data["vendorChargeDetail"] ? VendorChargeDetailDto.fromJS(data["vendorChargeDetail"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetVendorChargeDetailForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetVendorChargeDetailForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vendorChargeDetail"] = this.vendorChargeDetail ? this.vendorChargeDetail.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetVendorChargeDetailForViewDto {
    vendorChargeDetail: VendorChargeDetailDto | undefined;
}

export class VendorChargeDetailDto implements IVendorChargeDetailDto {
    invoiceDetail!: string | undefined;
    quantity!: number | undefined;
    unitPrice!: number | undefined;
    tax!: number | undefined;
    subTotal!: number | undefined;
    id!: number | undefined;

    constructor(data?: IVendorChargeDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.invoiceDetail = data["invoiceDetail"];
            this.quantity = data["quantity"];
            this.unitPrice = data["unitPrice"];
            this.tax = data["tax"];
            this.subTotal = data["subTotal"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): VendorChargeDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new VendorChargeDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["invoiceDetail"] = this.invoiceDetail;
        data["quantity"] = this.quantity;
        data["unitPrice"] = this.unitPrice;
        data["tax"] = this.tax;
        data["subTotal"] = this.subTotal;
        data["id"] = this.id;
        return data; 
    }
}

export interface IVendorChargeDetailDto {
    invoiceDetail: string | undefined;
    quantity: number | undefined;
    unitPrice: number | undefined;
    tax: number | undefined;
    subTotal: number | undefined;
    id: number | undefined;
}

export class GetVendorChargeDetailForEditOutput implements IGetVendorChargeDetailForEditOutput {
    vendorChargeDetail!: CreateOrEditVendorChargeDetailDto | undefined;

    constructor(data?: IGetVendorChargeDetailForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.vendorChargeDetail = data["vendorChargeDetail"] ? CreateOrEditVendorChargeDetailDto.fromJS(data["vendorChargeDetail"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetVendorChargeDetailForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetVendorChargeDetailForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vendorChargeDetail"] = this.vendorChargeDetail ? this.vendorChargeDetail.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetVendorChargeDetailForEditOutput {
    vendorChargeDetail: CreateOrEditVendorChargeDetailDto | undefined;
}

export class CreateOrEditVendorChargeDetailDto implements ICreateOrEditVendorChargeDetailDto {
    invoiceDetail!: string;
    quantity!: number | undefined;
    unitPrice!: number | undefined;
    tax!: number | undefined;
    subTotal!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditVendorChargeDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.invoiceDetail = data["invoiceDetail"];
            this.quantity = data["quantity"];
            this.unitPrice = data["unitPrice"];
            this.tax = data["tax"];
            this.subTotal = data["subTotal"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditVendorChargeDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditVendorChargeDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["invoiceDetail"] = this.invoiceDetail;
        data["quantity"] = this.quantity;
        data["unitPrice"] = this.unitPrice;
        data["tax"] = this.tax;
        data["subTotal"] = this.subTotal;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditVendorChargeDetailDto {
    invoiceDetail: string;
    quantity: number | undefined;
    unitPrice: number | undefined;
    tax: number | undefined;
    subTotal: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfGetVendorChargeForViewDto implements IPagedResultDtoOfGetVendorChargeForViewDto {
    totalCount!: number | undefined;
    items!: GetVendorChargeForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetVendorChargeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetVendorChargeForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetVendorChargeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetVendorChargeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetVendorChargeForViewDto {
    totalCount: number | undefined;
    items: GetVendorChargeForViewDto[] | undefined;
}

export class GetVendorChargeForViewDto implements IGetVendorChargeForViewDto {
    vendorCharge!: VendorChargeDto | undefined;
    vendorName!: string | undefined;
    supportContractTitle!: string | undefined;
    workOrderSubject!: string | undefined;
    vendorChargeStatusStatus!: string | undefined;

    constructor(data?: IGetVendorChargeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.vendorCharge = data["vendorCharge"] ? VendorChargeDto.fromJS(data["vendorCharge"]) : <any>undefined;
            this.vendorName = data["vendorName"];
            this.supportContractTitle = data["supportContractTitle"];
            this.workOrderSubject = data["workOrderSubject"];
            this.vendorChargeStatusStatus = data["vendorChargeStatusStatus"];
        }
    }

    static fromJS(data: any): GetVendorChargeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetVendorChargeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vendorCharge"] = this.vendorCharge ? this.vendorCharge.toJSON() : <any>undefined;
        data["vendorName"] = this.vendorName;
        data["supportContractTitle"] = this.supportContractTitle;
        data["workOrderSubject"] = this.workOrderSubject;
        data["vendorChargeStatusStatus"] = this.vendorChargeStatusStatus;
        return data; 
    }
}

export interface IGetVendorChargeForViewDto {
    vendorCharge: VendorChargeDto | undefined;
    vendorName: string | undefined;
    supportContractTitle: string | undefined;
    workOrderSubject: string | undefined;
    vendorChargeStatusStatus: string | undefined;
}

export class VendorChargeDto implements IVendorChargeDto {
    reference!: string | undefined;
    description!: string | undefined;
    dateIssued!: moment.Moment | undefined;
    dateDue!: moment.Moment | undefined;
    totalTax!: number | undefined;
    totalPrice!: number | undefined;
    vendorId!: number | undefined;
    supportContractId!: number | undefined;
    workOrderId!: number | undefined;
    vendorChargeStatusId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IVendorChargeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reference = data["reference"];
            this.description = data["description"];
            this.dateIssued = data["dateIssued"] ? moment(data["dateIssued"].toString()) : <any>undefined;
            this.dateDue = data["dateDue"] ? moment(data["dateDue"].toString()) : <any>undefined;
            this.totalTax = data["totalTax"];
            this.totalPrice = data["totalPrice"];
            this.vendorId = data["vendorId"];
            this.supportContractId = data["supportContractId"];
            this.workOrderId = data["workOrderId"];
            this.vendorChargeStatusId = data["vendorChargeStatusId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): VendorChargeDto {
        data = typeof data === 'object' ? data : {};
        let result = new VendorChargeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reference"] = this.reference;
        data["description"] = this.description;
        data["dateIssued"] = this.dateIssued ? this.dateIssued.toISOString() : <any>undefined;
        data["dateDue"] = this.dateDue ? this.dateDue.toISOString() : <any>undefined;
        data["totalTax"] = this.totalTax;
        data["totalPrice"] = this.totalPrice;
        data["vendorId"] = this.vendorId;
        data["supportContractId"] = this.supportContractId;
        data["workOrderId"] = this.workOrderId;
        data["vendorChargeStatusId"] = this.vendorChargeStatusId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IVendorChargeDto {
    reference: string | undefined;
    description: string | undefined;
    dateIssued: moment.Moment | undefined;
    dateDue: moment.Moment | undefined;
    totalTax: number | undefined;
    totalPrice: number | undefined;
    vendorId: number | undefined;
    supportContractId: number | undefined;
    workOrderId: number | undefined;
    vendorChargeStatusId: number | undefined;
    id: number | undefined;
}

export class GetVendorChargeForEditOutput implements IGetVendorChargeForEditOutput {
    vendorCharge!: CreateOrEditVendorChargeDto | undefined;
    vendorName!: string | undefined;
    supportContractTitle!: string | undefined;
    workOrderSubject!: string | undefined;
    vendorChargeStatusStatus!: string | undefined;

    constructor(data?: IGetVendorChargeForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.vendorCharge = data["vendorCharge"] ? CreateOrEditVendorChargeDto.fromJS(data["vendorCharge"]) : <any>undefined;
            this.vendorName = data["vendorName"];
            this.supportContractTitle = data["supportContractTitle"];
            this.workOrderSubject = data["workOrderSubject"];
            this.vendorChargeStatusStatus = data["vendorChargeStatusStatus"];
        }
    }

    static fromJS(data: any): GetVendorChargeForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetVendorChargeForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vendorCharge"] = this.vendorCharge ? this.vendorCharge.toJSON() : <any>undefined;
        data["vendorName"] = this.vendorName;
        data["supportContractTitle"] = this.supportContractTitle;
        data["workOrderSubject"] = this.workOrderSubject;
        data["vendorChargeStatusStatus"] = this.vendorChargeStatusStatus;
        return data; 
    }
}

export interface IGetVendorChargeForEditOutput {
    vendorCharge: CreateOrEditVendorChargeDto | undefined;
    vendorName: string | undefined;
    supportContractTitle: string | undefined;
    workOrderSubject: string | undefined;
    vendorChargeStatusStatus: string | undefined;
}

export class CreateOrEditVendorChargeDto implements ICreateOrEditVendorChargeDto {
    reference!: string;
    description!: string;
    dateIssued!: moment.Moment | undefined;
    dateDue!: moment.Moment | undefined;
    totalTax!: number | undefined;
    totalPrice!: number | undefined;
    vendorId!: number | undefined;
    supportContractId!: number | undefined;
    workOrderId!: number | undefined;
    vendorChargeStatusId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditVendorChargeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reference = data["reference"];
            this.description = data["description"];
            this.dateIssued = data["dateIssued"] ? moment(data["dateIssued"].toString()) : <any>undefined;
            this.dateDue = data["dateDue"] ? moment(data["dateDue"].toString()) : <any>undefined;
            this.totalTax = data["totalTax"];
            this.totalPrice = data["totalPrice"];
            this.vendorId = data["vendorId"];
            this.supportContractId = data["supportContractId"];
            this.workOrderId = data["workOrderId"];
            this.vendorChargeStatusId = data["vendorChargeStatusId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditVendorChargeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditVendorChargeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reference"] = this.reference;
        data["description"] = this.description;
        data["dateIssued"] = this.dateIssued ? this.dateIssued.toISOString() : <any>undefined;
        data["dateDue"] = this.dateDue ? this.dateDue.toISOString() : <any>undefined;
        data["totalTax"] = this.totalTax;
        data["totalPrice"] = this.totalPrice;
        data["vendorId"] = this.vendorId;
        data["supportContractId"] = this.supportContractId;
        data["workOrderId"] = this.workOrderId;
        data["vendorChargeStatusId"] = this.vendorChargeStatusId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditVendorChargeDto {
    reference: string;
    description: string;
    dateIssued: moment.Moment | undefined;
    dateDue: moment.Moment | undefined;
    totalTax: number | undefined;
    totalPrice: number | undefined;
    vendorId: number | undefined;
    supportContractId: number | undefined;
    workOrderId: number | undefined;
    vendorChargeStatusId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfVendorChargeVendorLookupTableDto implements IPagedResultDtoOfVendorChargeVendorLookupTableDto {
    totalCount!: number | undefined;
    items!: VendorChargeVendorLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfVendorChargeVendorLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(VendorChargeVendorLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfVendorChargeVendorLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfVendorChargeVendorLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfVendorChargeVendorLookupTableDto {
    totalCount: number | undefined;
    items: VendorChargeVendorLookupTableDto[] | undefined;
}

export class VendorChargeVendorLookupTableDto implements IVendorChargeVendorLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IVendorChargeVendorLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): VendorChargeVendorLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new VendorChargeVendorLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IVendorChargeVendorLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfVendorChargeSupportContractLookupTableDto implements IPagedResultDtoOfVendorChargeSupportContractLookupTableDto {
    totalCount!: number | undefined;
    items!: VendorChargeSupportContractLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfVendorChargeSupportContractLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(VendorChargeSupportContractLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfVendorChargeSupportContractLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfVendorChargeSupportContractLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfVendorChargeSupportContractLookupTableDto {
    totalCount: number | undefined;
    items: VendorChargeSupportContractLookupTableDto[] | undefined;
}

export class VendorChargeSupportContractLookupTableDto implements IVendorChargeSupportContractLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IVendorChargeSupportContractLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): VendorChargeSupportContractLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new VendorChargeSupportContractLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IVendorChargeSupportContractLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfVendorChargeWorkOrderLookupTableDto implements IPagedResultDtoOfVendorChargeWorkOrderLookupTableDto {
    totalCount!: number | undefined;
    items!: VendorChargeWorkOrderLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfVendorChargeWorkOrderLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(VendorChargeWorkOrderLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfVendorChargeWorkOrderLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfVendorChargeWorkOrderLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfVendorChargeWorkOrderLookupTableDto {
    totalCount: number | undefined;
    items: VendorChargeWorkOrderLookupTableDto[] | undefined;
}

export class VendorChargeWorkOrderLookupTableDto implements IVendorChargeWorkOrderLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IVendorChargeWorkOrderLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): VendorChargeWorkOrderLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new VendorChargeWorkOrderLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IVendorChargeWorkOrderLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfVendorChargeVendorChargeStatusLookupTableDto implements IPagedResultDtoOfVendorChargeVendorChargeStatusLookupTableDto {
    totalCount!: number | undefined;
    items!: VendorChargeVendorChargeStatusLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfVendorChargeVendorChargeStatusLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(VendorChargeVendorChargeStatusLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfVendorChargeVendorChargeStatusLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfVendorChargeVendorChargeStatusLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfVendorChargeVendorChargeStatusLookupTableDto {
    totalCount: number | undefined;
    items: VendorChargeVendorChargeStatusLookupTableDto[] | undefined;
}

export class VendorChargeVendorChargeStatusLookupTableDto implements IVendorChargeVendorChargeStatusLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IVendorChargeVendorChargeStatusLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): VendorChargeVendorChargeStatusLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new VendorChargeVendorChargeStatusLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IVendorChargeVendorChargeStatusLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetVendorChargeStatusForViewDto implements IPagedResultDtoOfGetVendorChargeStatusForViewDto {
    totalCount!: number | undefined;
    items!: GetVendorChargeStatusForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetVendorChargeStatusForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetVendorChargeStatusForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetVendorChargeStatusForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetVendorChargeStatusForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetVendorChargeStatusForViewDto {
    totalCount: number | undefined;
    items: GetVendorChargeStatusForViewDto[] | undefined;
}

export class GetVendorChargeStatusForViewDto implements IGetVendorChargeStatusForViewDto {
    vendorChargeStatus!: VendorChargeStatusDto | undefined;

    constructor(data?: IGetVendorChargeStatusForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.vendorChargeStatus = data["vendorChargeStatus"] ? VendorChargeStatusDto.fromJS(data["vendorChargeStatus"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetVendorChargeStatusForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetVendorChargeStatusForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vendorChargeStatus"] = this.vendorChargeStatus ? this.vendorChargeStatus.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetVendorChargeStatusForViewDto {
    vendorChargeStatus: VendorChargeStatusDto | undefined;
}

export class VendorChargeStatusDto implements IVendorChargeStatusDto {
    status!: string | undefined;
    description!: string | undefined;
    id!: number | undefined;

    constructor(data?: IVendorChargeStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"];
            this.description = data["description"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): VendorChargeStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new VendorChargeStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }
}

export interface IVendorChargeStatusDto {
    status: string | undefined;
    description: string | undefined;
    id: number | undefined;
}

export class GetVendorChargeStatusForEditOutput implements IGetVendorChargeStatusForEditOutput {
    vendorChargeStatus!: CreateOrEditVendorChargeStatusDto | undefined;

    constructor(data?: IGetVendorChargeStatusForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.vendorChargeStatus = data["vendorChargeStatus"] ? CreateOrEditVendorChargeStatusDto.fromJS(data["vendorChargeStatus"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetVendorChargeStatusForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetVendorChargeStatusForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vendorChargeStatus"] = this.vendorChargeStatus ? this.vendorChargeStatus.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetVendorChargeStatusForEditOutput {
    vendorChargeStatus: CreateOrEditVendorChargeStatusDto | undefined;
}

export class CreateOrEditVendorChargeStatusDto implements ICreateOrEditVendorChargeStatusDto {
    status!: string;
    description!: string;
    id!: number | undefined;

    constructor(data?: ICreateOrEditVendorChargeStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"];
            this.description = data["description"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditVendorChargeStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditVendorChargeStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditVendorChargeStatusDto {
    status: string;
    description: string;
    id: number | undefined;
}

export class PagedResultDtoOfGetVendorForViewDto implements IPagedResultDtoOfGetVendorForViewDto {
    totalCount!: number | undefined;
    items!: GetVendorForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetVendorForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetVendorForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetVendorForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetVendorForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetVendorForViewDto {
    totalCount: number | undefined;
    items: GetVendorForViewDto[] | undefined;
}

export class GetVendorForViewDto implements IGetVendorForViewDto {
    vendor!: VendorDto | undefined;
    ssicCodeCode!: string | undefined;
    currencyCode!: string | undefined;

    constructor(data?: IGetVendorForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.vendor = data["vendor"] ? VendorDto.fromJS(data["vendor"]) : <any>undefined;
            this.ssicCodeCode = data["ssicCodeCode"];
            this.currencyCode = data["currencyCode"];
        }
    }

    static fromJS(data: any): GetVendorForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetVendorForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vendor"] = this.vendor ? this.vendor.toJSON() : <any>undefined;
        data["ssicCodeCode"] = this.ssicCodeCode;
        data["currencyCode"] = this.currencyCode;
        return data; 
    }
}

export interface IGetVendorForViewDto {
    vendor: VendorDto | undefined;
    ssicCodeCode: string | undefined;
    currencyCode: string | undefined;
}

export class GetVendorForEditOutput implements IGetVendorForEditOutput {
    vendor!: CreateOrEditVendorDto | undefined;
    ssicCodeCode!: string | undefined;
    currencyCode!: string | undefined;

    constructor(data?: IGetVendorForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.vendor = data["vendor"] ? CreateOrEditVendorDto.fromJS(data["vendor"]) : <any>undefined;
            this.ssicCodeCode = data["ssicCodeCode"];
            this.currencyCode = data["currencyCode"];
        }
    }

    static fromJS(data: any): GetVendorForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetVendorForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["vendor"] = this.vendor ? this.vendor.toJSON() : <any>undefined;
        data["ssicCodeCode"] = this.ssicCodeCode;
        data["currencyCode"] = this.currencyCode;
        return data; 
    }
}

export interface IGetVendorForEditOutput {
    vendor: CreateOrEditVendorDto | undefined;
    ssicCodeCode: string | undefined;
    currencyCode: string | undefined;
}

export class CreateOrEditVendorDto implements ICreateOrEditVendorDto {
    reference!: string;
    name!: string;
    identifier!: string;
    logoUrl!: string | undefined;
    website!: string | undefined;
    vendorLoc8GUID!: string | undefined;
    ssicCodeId!: number | undefined;
    currencyId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditVendorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.reference = data["reference"];
            this.name = data["name"];
            this.identifier = data["identifier"];
            this.logoUrl = data["logoUrl"];
            this.website = data["website"];
            this.vendorLoc8GUID = data["vendorLoc8GUID"];
            this.ssicCodeId = data["ssicCodeId"];
            this.currencyId = data["currencyId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditVendorDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditVendorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reference"] = this.reference;
        data["name"] = this.name;
        data["identifier"] = this.identifier;
        data["logoUrl"] = this.logoUrl;
        data["website"] = this.website;
        data["vendorLoc8GUID"] = this.vendorLoc8GUID;
        data["ssicCodeId"] = this.ssicCodeId;
        data["currencyId"] = this.currencyId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditVendorDto {
    reference: string;
    name: string;
    identifier: string;
    logoUrl: string | undefined;
    website: string | undefined;
    vendorLoc8GUID: string | undefined;
    ssicCodeId: number | undefined;
    currencyId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfVendorSsicCodeLookupTableDto implements IPagedResultDtoOfVendorSsicCodeLookupTableDto {
    totalCount!: number | undefined;
    items!: VendorSsicCodeLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfVendorSsicCodeLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(VendorSsicCodeLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfVendorSsicCodeLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfVendorSsicCodeLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfVendorSsicCodeLookupTableDto {
    totalCount: number | undefined;
    items: VendorSsicCodeLookupTableDto[] | undefined;
}

export class VendorSsicCodeLookupTableDto implements IVendorSsicCodeLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IVendorSsicCodeLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): VendorSsicCodeLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new VendorSsicCodeLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IVendorSsicCodeLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfVendorCurrencyLookupTableDto implements IPagedResultDtoOfVendorCurrencyLookupTableDto {
    totalCount!: number | undefined;
    items!: VendorCurrencyLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfVendorCurrencyLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(VendorCurrencyLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfVendorCurrencyLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfVendorCurrencyLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfVendorCurrencyLookupTableDto {
    totalCount: number | undefined;
    items: VendorCurrencyLookupTableDto[] | undefined;
}

export class VendorCurrencyLookupTableDto implements IVendorCurrencyLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IVendorCurrencyLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): VendorCurrencyLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new VendorCurrencyLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IVendorCurrencyLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetWarehouseForViewDto implements IPagedResultDtoOfGetWarehouseForViewDto {
    totalCount!: number | undefined;
    items!: GetWarehouseForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetWarehouseForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetWarehouseForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetWarehouseForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetWarehouseForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetWarehouseForViewDto {
    totalCount: number | undefined;
    items: GetWarehouseForViewDto[] | undefined;
}

export class GetWarehouseForViewDto implements IGetWarehouseForViewDto {
    warehouse!: WarehouseDto | undefined;

    constructor(data?: IGetWarehouseForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.warehouse = data["warehouse"] ? WarehouseDto.fromJS(data["warehouse"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetWarehouseForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetWarehouseForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["warehouse"] = this.warehouse ? this.warehouse.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetWarehouseForViewDto {
    warehouse: WarehouseDto | undefined;
}

export class WarehouseDto implements IWarehouseDto {
    name!: string | undefined;
    addressLine1!: string | undefined;
    addressLine2!: string | undefined;
    postalCode!: string | undefined;
    city!: string | undefined;
    state!: string | undefined;
    country!: string | undefined;
    id!: number | undefined;

    constructor(data?: IWarehouseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.addressLine1 = data["addressLine1"];
            this.addressLine2 = data["addressLine2"];
            this.postalCode = data["postalCode"];
            this.city = data["city"];
            this.state = data["state"];
            this.country = data["country"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): WarehouseDto {
        data = typeof data === 'object' ? data : {};
        let result = new WarehouseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["addressLine1"] = this.addressLine1;
        data["addressLine2"] = this.addressLine2;
        data["postalCode"] = this.postalCode;
        data["city"] = this.city;
        data["state"] = this.state;
        data["country"] = this.country;
        data["id"] = this.id;
        return data; 
    }
}

export interface IWarehouseDto {
    name: string | undefined;
    addressLine1: string | undefined;
    addressLine2: string | undefined;
    postalCode: string | undefined;
    city: string | undefined;
    state: string | undefined;
    country: string | undefined;
    id: number | undefined;
}

export class GetWarehouseForEditOutput implements IGetWarehouseForEditOutput {
    warehouse!: CreateOrEditWarehouseDto | undefined;

    constructor(data?: IGetWarehouseForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.warehouse = data["warehouse"] ? CreateOrEditWarehouseDto.fromJS(data["warehouse"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetWarehouseForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetWarehouseForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["warehouse"] = this.warehouse ? this.warehouse.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetWarehouseForEditOutput {
    warehouse: CreateOrEditWarehouseDto | undefined;
}

export class CreateOrEditWarehouseDto implements ICreateOrEditWarehouseDto {
    name!: string;
    addressLine1!: string | undefined;
    addressLine2!: string | undefined;
    postalCode!: string | undefined;
    city!: string | undefined;
    state!: string | undefined;
    country!: string | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditWarehouseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"];
            this.addressLine1 = data["addressLine1"];
            this.addressLine2 = data["addressLine2"];
            this.postalCode = data["postalCode"];
            this.city = data["city"];
            this.state = data["state"];
            this.country = data["country"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditWarehouseDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditWarehouseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["addressLine1"] = this.addressLine1;
        data["addressLine2"] = this.addressLine2;
        data["postalCode"] = this.postalCode;
        data["city"] = this.city;
        data["state"] = this.state;
        data["country"] = this.country;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditWarehouseDto {
    name: string;
    addressLine1: string | undefined;
    addressLine2: string | undefined;
    postalCode: string | undefined;
    city: string | undefined;
    state: string | undefined;
    country: string | undefined;
    id: number | undefined;
}

export class GetLatestWebLogsOutput implements IGetLatestWebLogsOutput {
    latestWebLogLines!: string[] | undefined;

    constructor(data?: IGetLatestWebLogsOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["latestWebLogLines"])) {
                this.latestWebLogLines = [] as any;
                for (let item of data["latestWebLogLines"])
                    this.latestWebLogLines!.push(item);
            }
        }
    }

    static fromJS(data: any): GetLatestWebLogsOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetLatestWebLogsOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.latestWebLogLines)) {
            data["latestWebLogLines"] = [];
            for (let item of this.latestWebLogLines)
                data["latestWebLogLines"].push(item);
        }
        return data; 
    }
}

export interface IGetLatestWebLogsOutput {
    latestWebLogLines: string[] | undefined;
}

export class PagedResultDtoOfGetWorkOrderActionForViewDto implements IPagedResultDtoOfGetWorkOrderActionForViewDto {
    totalCount!: number | undefined;
    items!: GetWorkOrderActionForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetWorkOrderActionForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetWorkOrderActionForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetWorkOrderActionForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetWorkOrderActionForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetWorkOrderActionForViewDto {
    totalCount: number | undefined;
    items: GetWorkOrderActionForViewDto[] | undefined;
}

export class GetWorkOrderActionForViewDto implements IGetWorkOrderActionForViewDto {
    workOrderAction!: WorkOrderActionDto | undefined;

    constructor(data?: IGetWorkOrderActionForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.workOrderAction = data["workOrderAction"] ? WorkOrderActionDto.fromJS(data["workOrderAction"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetWorkOrderActionForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetWorkOrderActionForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workOrderAction"] = this.workOrderAction ? this.workOrderAction.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetWorkOrderActionForViewDto {
    workOrderAction: WorkOrderActionDto | undefined;
}

export class WorkOrderActionDto implements IWorkOrderActionDto {
    action!: string | undefined;
    description!: string | undefined;
    id!: number | undefined;

    constructor(data?: IWorkOrderActionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.action = data["action"];
            this.description = data["description"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): WorkOrderActionDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkOrderActionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["action"] = this.action;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }
}

export interface IWorkOrderActionDto {
    action: string | undefined;
    description: string | undefined;
    id: number | undefined;
}

export class GetWorkOrderActionForEditOutput implements IGetWorkOrderActionForEditOutput {
    workOrderAction!: CreateOrEditWorkOrderActionDto | undefined;

    constructor(data?: IGetWorkOrderActionForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.workOrderAction = data["workOrderAction"] ? CreateOrEditWorkOrderActionDto.fromJS(data["workOrderAction"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetWorkOrderActionForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetWorkOrderActionForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workOrderAction"] = this.workOrderAction ? this.workOrderAction.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetWorkOrderActionForEditOutput {
    workOrderAction: CreateOrEditWorkOrderActionDto | undefined;
}

export class CreateOrEditWorkOrderActionDto implements ICreateOrEditWorkOrderActionDto {
    action!: string;
    description!: string;
    id!: number | undefined;

    constructor(data?: ICreateOrEditWorkOrderActionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.action = data["action"];
            this.description = data["description"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditWorkOrderActionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditWorkOrderActionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["action"] = this.action;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditWorkOrderActionDto {
    action: string;
    description: string;
    id: number | undefined;
}

export class PagedResultDtoOfGetWorkOrderPriorityForViewDto implements IPagedResultDtoOfGetWorkOrderPriorityForViewDto {
    totalCount!: number | undefined;
    items!: GetWorkOrderPriorityForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetWorkOrderPriorityForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetWorkOrderPriorityForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetWorkOrderPriorityForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetWorkOrderPriorityForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetWorkOrderPriorityForViewDto {
    totalCount: number | undefined;
    items: GetWorkOrderPriorityForViewDto[] | undefined;
}

export class GetWorkOrderPriorityForViewDto implements IGetWorkOrderPriorityForViewDto {
    workOrderPriority!: WorkOrderPriorityDto | undefined;

    constructor(data?: IGetWorkOrderPriorityForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.workOrderPriority = data["workOrderPriority"] ? WorkOrderPriorityDto.fromJS(data["workOrderPriority"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetWorkOrderPriorityForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetWorkOrderPriorityForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workOrderPriority"] = this.workOrderPriority ? this.workOrderPriority.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetWorkOrderPriorityForViewDto {
    workOrderPriority: WorkOrderPriorityDto | undefined;
}

export class WorkOrderPriorityDto implements IWorkOrderPriorityDto {
    priority!: string | undefined;
    priorityLevel!: number | undefined;
    id!: number | undefined;

    constructor(data?: IWorkOrderPriorityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.priority = data["priority"];
            this.priorityLevel = data["priorityLevel"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): WorkOrderPriorityDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkOrderPriorityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["priority"] = this.priority;
        data["priorityLevel"] = this.priorityLevel;
        data["id"] = this.id;
        return data; 
    }
}

export interface IWorkOrderPriorityDto {
    priority: string | undefined;
    priorityLevel: number | undefined;
    id: number | undefined;
}

export class GetWorkOrderPriorityForEditOutput implements IGetWorkOrderPriorityForEditOutput {
    workOrderPriority!: CreateOrEditWorkOrderPriorityDto | undefined;

    constructor(data?: IGetWorkOrderPriorityForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.workOrderPriority = data["workOrderPriority"] ? CreateOrEditWorkOrderPriorityDto.fromJS(data["workOrderPriority"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetWorkOrderPriorityForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetWorkOrderPriorityForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workOrderPriority"] = this.workOrderPriority ? this.workOrderPriority.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetWorkOrderPriorityForEditOutput {
    workOrderPriority: CreateOrEditWorkOrderPriorityDto | undefined;
}

export class CreateOrEditWorkOrderPriorityDto implements ICreateOrEditWorkOrderPriorityDto {
    priority!: string;
    priorityLevel!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditWorkOrderPriorityDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.priority = data["priority"];
            this.priorityLevel = data["priorityLevel"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditWorkOrderPriorityDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditWorkOrderPriorityDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["priority"] = this.priority;
        data["priorityLevel"] = this.priorityLevel;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditWorkOrderPriorityDto {
    priority: string;
    priorityLevel: number | undefined;
    id: number | undefined;
}

export class GetWorkorderItemsForViewDto implements IGetWorkorderItemsForViewDto {
    supportItem!: SupportItemDto | undefined;
    consumed!: number | undefined;

    constructor(data?: IGetWorkorderItemsForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.supportItem = data["supportItem"] ? SupportItemDto.fromJS(data["supportItem"]) : <any>undefined;
            this.consumed = data["consumed"];
        }
    }

    static fromJS(data: any): GetWorkorderItemsForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetWorkorderItemsForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["supportItem"] = this.supportItem ? this.supportItem.toJSON() : <any>undefined;
        data["consumed"] = this.consumed;
        return data; 
    }
}

export interface IGetWorkorderItemsForViewDto {
    supportItem: SupportItemDto | undefined;
    consumed: number | undefined;
}

export class GetWorkOrderForEditOutput implements IGetWorkOrderForEditOutput {
    workOrder!: CreateOrEditWorkOrderDto | undefined;
    workOrderPriorityPriority!: string | undefined;
    workOrderTypeType!: string | undefined;
    vendorName!: string | undefined;
    incidentDescription!: string | undefined;
    supportItemDescription!: string | undefined;
    userName!: string | undefined;
    customerName!: string | undefined;
    assetOwnershipAssetDisplayName!: string | undefined;
    workOrderStatusStatus!: string | undefined;
    tenantType!: string | undefined;

    constructor(data?: IGetWorkOrderForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.workOrder = data["workOrder"] ? CreateOrEditWorkOrderDto.fromJS(data["workOrder"]) : <any>undefined;
            this.workOrderPriorityPriority = data["workOrderPriorityPriority"];
            this.workOrderTypeType = data["workOrderTypeType"];
            this.vendorName = data["vendorName"];
            this.incidentDescription = data["incidentDescription"];
            this.supportItemDescription = data["supportItemDescription"];
            this.userName = data["userName"];
            this.customerName = data["customerName"];
            this.assetOwnershipAssetDisplayName = data["assetOwnershipAssetDisplayName"];
            this.workOrderStatusStatus = data["workOrderStatusStatus"];
            this.tenantType = data["tenantType"];
        }
    }

    static fromJS(data: any): GetWorkOrderForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetWorkOrderForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workOrder"] = this.workOrder ? this.workOrder.toJSON() : <any>undefined;
        data["workOrderPriorityPriority"] = this.workOrderPriorityPriority;
        data["workOrderTypeType"] = this.workOrderTypeType;
        data["vendorName"] = this.vendorName;
        data["incidentDescription"] = this.incidentDescription;
        data["supportItemDescription"] = this.supportItemDescription;
        data["userName"] = this.userName;
        data["customerName"] = this.customerName;
        data["assetOwnershipAssetDisplayName"] = this.assetOwnershipAssetDisplayName;
        data["workOrderStatusStatus"] = this.workOrderStatusStatus;
        data["tenantType"] = this.tenantType;
        return data; 
    }
}

export interface IGetWorkOrderForEditOutput {
    workOrder: CreateOrEditWorkOrderDto | undefined;
    workOrderPriorityPriority: string | undefined;
    workOrderTypeType: string | undefined;
    vendorName: string | undefined;
    incidentDescription: string | undefined;
    supportItemDescription: string | undefined;
    userName: string | undefined;
    customerName: string | undefined;
    assetOwnershipAssetDisplayName: string | undefined;
    workOrderStatusStatus: string | undefined;
    tenantType: string | undefined;
}

export class CreateOrEditWorkOrderDto implements ICreateOrEditWorkOrderDto {
    loc8GUID!: string | undefined;
    subject!: string;
    description!: string | undefined;
    location!: string | undefined;
    startDate!: moment.Moment | undefined;
    endDate!: moment.Moment | undefined;
    remarks!: string | undefined;
    attachments!: string | undefined;
    workOrderPriorityId!: number | undefined;
    workOrderTypeId!: number | undefined;
    vendorId!: number | undefined;
    incidentId!: number | undefined;
    supportItemId!: number | undefined;
    userId!: number | undefined;
    customerId!: number | undefined;
    assetOwnershipId!: number | undefined;
    workOrderStatusId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditWorkOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.loc8GUID = data["loc8GUID"];
            this.subject = data["subject"];
            this.description = data["description"];
            this.location = data["location"];
            this.startDate = data["startDate"] ? moment(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? moment(data["endDate"].toString()) : <any>undefined;
            this.remarks = data["remarks"];
            this.attachments = data["attachments"];
            this.workOrderPriorityId = data["workOrderPriorityId"];
            this.workOrderTypeId = data["workOrderTypeId"];
            this.vendorId = data["vendorId"];
            this.incidentId = data["incidentId"];
            this.supportItemId = data["supportItemId"];
            this.userId = data["userId"];
            this.customerId = data["customerId"];
            this.assetOwnershipId = data["assetOwnershipId"];
            this.workOrderStatusId = data["workOrderStatusId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditWorkOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditWorkOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["loc8GUID"] = this.loc8GUID;
        data["subject"] = this.subject;
        data["description"] = this.description;
        data["location"] = this.location;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["remarks"] = this.remarks;
        data["attachments"] = this.attachments;
        data["workOrderPriorityId"] = this.workOrderPriorityId;
        data["workOrderTypeId"] = this.workOrderTypeId;
        data["vendorId"] = this.vendorId;
        data["incidentId"] = this.incidentId;
        data["supportItemId"] = this.supportItemId;
        data["userId"] = this.userId;
        data["customerId"] = this.customerId;
        data["assetOwnershipId"] = this.assetOwnershipId;
        data["workOrderStatusId"] = this.workOrderStatusId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditWorkOrderDto {
    loc8GUID: string | undefined;
    subject: string;
    description: string | undefined;
    location: string | undefined;
    startDate: moment.Moment | undefined;
    endDate: moment.Moment | undefined;
    remarks: string | undefined;
    attachments: string | undefined;
    workOrderPriorityId: number | undefined;
    workOrderTypeId: number | undefined;
    vendorId: number | undefined;
    incidentId: number | undefined;
    supportItemId: number | undefined;
    userId: number | undefined;
    customerId: number | undefined;
    assetOwnershipId: number | undefined;
    workOrderStatusId: number | undefined;
    id: number | undefined;
}

export class ErrorViewModel implements IErrorViewModel {
    errorInfo!: ErrorInfo | undefined;
    exception!: any | undefined;

    constructor(data?: IErrorViewModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.errorInfo = data["errorInfo"] ? ErrorInfo.fromJS(data["errorInfo"]) : <any>undefined;
            this.exception = data["exception"];
        }
    }

    static fromJS(data: any): ErrorViewModel {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorViewModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["errorInfo"] = this.errorInfo ? this.errorInfo.toJSON() : <any>undefined;
        data["exception"] = this.exception;
        return data; 
    }
}

export interface IErrorViewModel {
    errorInfo: ErrorInfo | undefined;
    exception: any | undefined;
}

export class ErrorInfo implements IErrorInfo {
    code!: number | undefined;
    message!: string | undefined;
    details!: string | undefined;
    validationErrors!: ValidationErrorInfo[] | undefined;

    constructor(data?: IErrorInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.code = data["code"];
            this.message = data["message"];
            this.details = data["details"];
            if (Array.isArray(data["validationErrors"])) {
                this.validationErrors = [] as any;
                for (let item of data["validationErrors"])
                    this.validationErrors!.push(ValidationErrorInfo.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ErrorInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ErrorInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["code"] = this.code;
        data["message"] = this.message;
        data["details"] = this.details;
        if (Array.isArray(this.validationErrors)) {
            data["validationErrors"] = [];
            for (let item of this.validationErrors)
                data["validationErrors"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IErrorInfo {
    code: number | undefined;
    message: string | undefined;
    details: string | undefined;
    validationErrors: ValidationErrorInfo[] | undefined;
}

export class ValidationErrorInfo implements IValidationErrorInfo {
    message!: string | undefined;
    members!: string[] | undefined;

    constructor(data?: IValidationErrorInfo) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.message = data["message"];
            if (Array.isArray(data["members"])) {
                this.members = [] as any;
                for (let item of data["members"])
                    this.members!.push(item);
            }
        }
    }

    static fromJS(data: any): ValidationErrorInfo {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationErrorInfo();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        if (Array.isArray(this.members)) {
            data["members"] = [];
            for (let item of this.members)
                data["members"].push(item);
        }
        return data; 
    }
}

export interface IValidationErrorInfo {
    message: string | undefined;
    members: string[] | undefined;
}

export class PagedResultDtoOfWorkOrderWorkOrderPriorityLookupTableDto implements IPagedResultDtoOfWorkOrderWorkOrderPriorityLookupTableDto {
    totalCount!: number | undefined;
    items!: WorkOrderWorkOrderPriorityLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfWorkOrderWorkOrderPriorityLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(WorkOrderWorkOrderPriorityLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfWorkOrderWorkOrderPriorityLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfWorkOrderWorkOrderPriorityLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfWorkOrderWorkOrderPriorityLookupTableDto {
    totalCount: number | undefined;
    items: WorkOrderWorkOrderPriorityLookupTableDto[] | undefined;
}

export class WorkOrderWorkOrderPriorityLookupTableDto implements IWorkOrderWorkOrderPriorityLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IWorkOrderWorkOrderPriorityLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): WorkOrderWorkOrderPriorityLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkOrderWorkOrderPriorityLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IWorkOrderWorkOrderPriorityLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfWorkOrderWorkOrderTypeLookupTableDto implements IPagedResultDtoOfWorkOrderWorkOrderTypeLookupTableDto {
    totalCount!: number | undefined;
    items!: WorkOrderWorkOrderTypeLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfWorkOrderWorkOrderTypeLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(WorkOrderWorkOrderTypeLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfWorkOrderWorkOrderTypeLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfWorkOrderWorkOrderTypeLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfWorkOrderWorkOrderTypeLookupTableDto {
    totalCount: number | undefined;
    items: WorkOrderWorkOrderTypeLookupTableDto[] | undefined;
}

export class WorkOrderWorkOrderTypeLookupTableDto implements IWorkOrderWorkOrderTypeLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IWorkOrderWorkOrderTypeLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): WorkOrderWorkOrderTypeLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkOrderWorkOrderTypeLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IWorkOrderWorkOrderTypeLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfWorkOrderVendorLookupTableDto implements IPagedResultDtoOfWorkOrderVendorLookupTableDto {
    totalCount!: number | undefined;
    items!: WorkOrderVendorLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfWorkOrderVendorLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(WorkOrderVendorLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfWorkOrderVendorLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfWorkOrderVendorLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfWorkOrderVendorLookupTableDto {
    totalCount: number | undefined;
    items: WorkOrderVendorLookupTableDto[] | undefined;
}

export class WorkOrderVendorLookupTableDto implements IWorkOrderVendorLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IWorkOrderVendorLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): WorkOrderVendorLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkOrderVendorLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IWorkOrderVendorLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfWorkOrderIncidentLookupTableDto implements IPagedResultDtoOfWorkOrderIncidentLookupTableDto {
    totalCount!: number | undefined;
    items!: WorkOrderIncidentLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfWorkOrderIncidentLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(WorkOrderIncidentLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfWorkOrderIncidentLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfWorkOrderIncidentLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfWorkOrderIncidentLookupTableDto {
    totalCount: number | undefined;
    items: WorkOrderIncidentLookupTableDto[] | undefined;
}

export class WorkOrderIncidentLookupTableDto implements IWorkOrderIncidentLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IWorkOrderIncidentLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): WorkOrderIncidentLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkOrderIncidentLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IWorkOrderIncidentLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfWorkOrderSupportItemLookupTableDto implements IPagedResultDtoOfWorkOrderSupportItemLookupTableDto {
    totalCount!: number | undefined;
    items!: WorkOrderSupportItemLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfWorkOrderSupportItemLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(WorkOrderSupportItemLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfWorkOrderSupportItemLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfWorkOrderSupportItemLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfWorkOrderSupportItemLookupTableDto {
    totalCount: number | undefined;
    items: WorkOrderSupportItemLookupTableDto[] | undefined;
}

export class WorkOrderSupportItemLookupTableDto implements IWorkOrderSupportItemLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IWorkOrderSupportItemLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): WorkOrderSupportItemLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkOrderSupportItemLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IWorkOrderSupportItemLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfWorkOrderUserLookupTableDto implements IPagedResultDtoOfWorkOrderUserLookupTableDto {
    totalCount!: number | undefined;
    items!: WorkOrderUserLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfWorkOrderUserLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(WorkOrderUserLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfWorkOrderUserLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfWorkOrderUserLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfWorkOrderUserLookupTableDto {
    totalCount: number | undefined;
    items: WorkOrderUserLookupTableDto[] | undefined;
}

export class WorkOrderUserLookupTableDto implements IWorkOrderUserLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IWorkOrderUserLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): WorkOrderUserLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkOrderUserLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IWorkOrderUserLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfWorkOrderCustomerLookupTableDto implements IPagedResultDtoOfWorkOrderCustomerLookupTableDto {
    totalCount!: number | undefined;
    items!: WorkOrderCustomerLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfWorkOrderCustomerLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(WorkOrderCustomerLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfWorkOrderCustomerLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfWorkOrderCustomerLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfWorkOrderCustomerLookupTableDto {
    totalCount: number | undefined;
    items: WorkOrderCustomerLookupTableDto[] | undefined;
}

export class WorkOrderCustomerLookupTableDto implements IWorkOrderCustomerLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IWorkOrderCustomerLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): WorkOrderCustomerLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkOrderCustomerLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IWorkOrderCustomerLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfWorkOrderAssetOwnershipLookupTableDto implements IPagedResultDtoOfWorkOrderAssetOwnershipLookupTableDto {
    totalCount!: number | undefined;
    items!: WorkOrderAssetOwnershipLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfWorkOrderAssetOwnershipLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(WorkOrderAssetOwnershipLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfWorkOrderAssetOwnershipLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfWorkOrderAssetOwnershipLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfWorkOrderAssetOwnershipLookupTableDto {
    totalCount: number | undefined;
    items: WorkOrderAssetOwnershipLookupTableDto[] | undefined;
}

export class WorkOrderAssetOwnershipLookupTableDto implements IWorkOrderAssetOwnershipLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IWorkOrderAssetOwnershipLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): WorkOrderAssetOwnershipLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkOrderAssetOwnershipLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IWorkOrderAssetOwnershipLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfWorkOrderWorkOrderStatusLookupTableDto implements IPagedResultDtoOfWorkOrderWorkOrderStatusLookupTableDto {
    totalCount!: number | undefined;
    items!: WorkOrderWorkOrderStatusLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfWorkOrderWorkOrderStatusLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(WorkOrderWorkOrderStatusLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfWorkOrderWorkOrderStatusLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfWorkOrderWorkOrderStatusLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfWorkOrderWorkOrderStatusLookupTableDto {
    totalCount: number | undefined;
    items: WorkOrderWorkOrderStatusLookupTableDto[] | undefined;
}

export class WorkOrderWorkOrderStatusLookupTableDto implements IWorkOrderWorkOrderStatusLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IWorkOrderWorkOrderStatusLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): WorkOrderWorkOrderStatusLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkOrderWorkOrderStatusLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IWorkOrderWorkOrderStatusLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class WorkOrderAssetFkListDto implements IWorkOrderAssetFkListDto {
    customerList!: WorkOrderCustomerLookupTableDto[] | undefined;
    supportItemList!: WorkOrderSupportItemLookupTableDto[] | undefined;
    assetOwnerList!: WorkOrderAssetOwnershipLookupTableDto[] | undefined;
    vendorList!: WorkOrderVendorLookupTableDto[] | undefined;

    constructor(data?: IWorkOrderAssetFkListDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (Array.isArray(data["customerList"])) {
                this.customerList = [] as any;
                for (let item of data["customerList"])
                    this.customerList!.push(WorkOrderCustomerLookupTableDto.fromJS(item));
            }
            if (Array.isArray(data["supportItemList"])) {
                this.supportItemList = [] as any;
                for (let item of data["supportItemList"])
                    this.supportItemList!.push(WorkOrderSupportItemLookupTableDto.fromJS(item));
            }
            if (Array.isArray(data["assetOwnerList"])) {
                this.assetOwnerList = [] as any;
                for (let item of data["assetOwnerList"])
                    this.assetOwnerList!.push(WorkOrderAssetOwnershipLookupTableDto.fromJS(item));
            }
            if (Array.isArray(data["vendorList"])) {
                this.vendorList = [] as any;
                for (let item of data["vendorList"])
                    this.vendorList!.push(WorkOrderVendorLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): WorkOrderAssetFkListDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkOrderAssetFkListDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.customerList)) {
            data["customerList"] = [];
            for (let item of this.customerList)
                data["customerList"].push(item.toJSON());
        }
        if (Array.isArray(this.supportItemList)) {
            data["supportItemList"] = [];
            for (let item of this.supportItemList)
                data["supportItemList"].push(item.toJSON());
        }
        if (Array.isArray(this.assetOwnerList)) {
            data["assetOwnerList"] = [];
            for (let item of this.assetOwnerList)
                data["assetOwnerList"].push(item.toJSON());
        }
        if (Array.isArray(this.vendorList)) {
            data["vendorList"] = [];
            for (let item of this.vendorList)
                data["vendorList"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IWorkOrderAssetFkListDto {
    customerList: WorkOrderCustomerLookupTableDto[] | undefined;
    supportItemList: WorkOrderSupportItemLookupTableDto[] | undefined;
    assetOwnerList: WorkOrderAssetOwnershipLookupTableDto[] | undefined;
    vendorList: WorkOrderVendorLookupTableDto[] | undefined;
}

export class PagedResultDtoOfGetWorkOrderStatusForViewDto implements IPagedResultDtoOfGetWorkOrderStatusForViewDto {
    totalCount!: number | undefined;
    items!: GetWorkOrderStatusForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetWorkOrderStatusForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetWorkOrderStatusForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetWorkOrderStatusForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetWorkOrderStatusForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetWorkOrderStatusForViewDto {
    totalCount: number | undefined;
    items: GetWorkOrderStatusForViewDto[] | undefined;
}

export class GetWorkOrderStatusForViewDto implements IGetWorkOrderStatusForViewDto {
    workOrderStatus!: WorkOrderStatusDto | undefined;

    constructor(data?: IGetWorkOrderStatusForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.workOrderStatus = data["workOrderStatus"] ? WorkOrderStatusDto.fromJS(data["workOrderStatus"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetWorkOrderStatusForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetWorkOrderStatusForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workOrderStatus"] = this.workOrderStatus ? this.workOrderStatus.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetWorkOrderStatusForViewDto {
    workOrderStatus: WorkOrderStatusDto | undefined;
}

export class WorkOrderStatusDto implements IWorkOrderStatusDto {
    status!: string | undefined;
    description!: string | undefined;
    id!: number | undefined;

    constructor(data?: IWorkOrderStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"];
            this.description = data["description"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): WorkOrderStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkOrderStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }
}

export interface IWorkOrderStatusDto {
    status: string | undefined;
    description: string | undefined;
    id: number | undefined;
}

export class GetWorkOrderStatusForEditOutput implements IGetWorkOrderStatusForEditOutput {
    workOrderStatus!: CreateOrEditWorkOrderStatusDto | undefined;

    constructor(data?: IGetWorkOrderStatusForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.workOrderStatus = data["workOrderStatus"] ? CreateOrEditWorkOrderStatusDto.fromJS(data["workOrderStatus"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetWorkOrderStatusForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetWorkOrderStatusForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workOrderStatus"] = this.workOrderStatus ? this.workOrderStatus.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetWorkOrderStatusForEditOutput {
    workOrderStatus: CreateOrEditWorkOrderStatusDto | undefined;
}

export class CreateOrEditWorkOrderStatusDto implements ICreateOrEditWorkOrderStatusDto {
    status!: string;
    description!: string;
    id!: number | undefined;

    constructor(data?: ICreateOrEditWorkOrderStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.status = data["status"];
            this.description = data["description"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditWorkOrderStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditWorkOrderStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditWorkOrderStatusDto {
    status: string;
    description: string;
    id: number | undefined;
}

export class PagedResultDtoOfGetWorkOrderTypeForViewDto implements IPagedResultDtoOfGetWorkOrderTypeForViewDto {
    totalCount!: number | undefined;
    items!: GetWorkOrderTypeForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetWorkOrderTypeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetWorkOrderTypeForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetWorkOrderTypeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetWorkOrderTypeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetWorkOrderTypeForViewDto {
    totalCount: number | undefined;
    items: GetWorkOrderTypeForViewDto[] | undefined;
}

export class GetWorkOrderTypeForViewDto implements IGetWorkOrderTypeForViewDto {
    workOrderType!: WorkOrderTypeDto | undefined;

    constructor(data?: IGetWorkOrderTypeForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.workOrderType = data["workOrderType"] ? WorkOrderTypeDto.fromJS(data["workOrderType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetWorkOrderTypeForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetWorkOrderTypeForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workOrderType"] = this.workOrderType ? this.workOrderType.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetWorkOrderTypeForViewDto {
    workOrderType: WorkOrderTypeDto | undefined;
}

export class WorkOrderTypeDto implements IWorkOrderTypeDto {
    type!: string | undefined;
    description!: string | undefined;
    id!: number | undefined;

    constructor(data?: IWorkOrderTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.type = data["type"];
            this.description = data["description"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): WorkOrderTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkOrderTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }
}

export interface IWorkOrderTypeDto {
    type: string | undefined;
    description: string | undefined;
    id: number | undefined;
}

export class GetWorkOrderTypeForEditOutput implements IGetWorkOrderTypeForEditOutput {
    workOrderType!: CreateOrEditWorkOrderTypeDto | undefined;

    constructor(data?: IGetWorkOrderTypeForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.workOrderType = data["workOrderType"] ? CreateOrEditWorkOrderTypeDto.fromJS(data["workOrderType"]) : <any>undefined;
        }
    }

    static fromJS(data: any): GetWorkOrderTypeForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetWorkOrderTypeForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workOrderType"] = this.workOrderType ? this.workOrderType.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IGetWorkOrderTypeForEditOutput {
    workOrderType: CreateOrEditWorkOrderTypeDto | undefined;
}

export class CreateOrEditWorkOrderTypeDto implements ICreateOrEditWorkOrderTypeDto {
    type!: string;
    description!: string;
    id!: number | undefined;

    constructor(data?: ICreateOrEditWorkOrderTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.type = data["type"];
            this.description = data["description"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditWorkOrderTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditWorkOrderTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["description"] = this.description;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditWorkOrderTypeDto {
    type: string;
    description: string;
    id: number | undefined;
}

export class GetWorkorderUpdateItemsForViewDto implements IGetWorkorderUpdateItemsForViewDto {
    item!: ItemTypeDto | undefined;
    consumed!: number | undefined;

    constructor(data?: IGetWorkorderUpdateItemsForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.item = data["item"] ? ItemTypeDto.fromJS(data["item"]) : <any>undefined;
            this.consumed = data["consumed"];
        }
    }

    static fromJS(data: any): GetWorkorderUpdateItemsForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetWorkorderUpdateItemsForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["item"] = this.item ? this.item.toJSON() : <any>undefined;
        data["consumed"] = this.consumed;
        return data; 
    }
}

export interface IGetWorkorderUpdateItemsForViewDto {
    item: ItemTypeDto | undefined;
    consumed: number | undefined;
}

export class GetWorkOrderUpdateForEditOutput implements IGetWorkOrderUpdateForEditOutput {
    workOrderUpdate!: CreateOrEditWorkOrderUpdateDto | undefined;
    workOrderUpdateSubject!: string | undefined;
    itemTypeType!: string | undefined;
    workOrderUpdateActionAction!: string | undefined;
    assetPartName!: string | undefined;

    constructor(data?: IGetWorkOrderUpdateForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.workOrderUpdate = data["workOrderUpdate"] ? CreateOrEditWorkOrderUpdateDto.fromJS(data["workOrderUpdate"]) : <any>undefined;
            this.workOrderUpdateSubject = data["workOrderUpdateSubject"];
            this.itemTypeType = data["itemTypeType"];
            this.workOrderUpdateActionAction = data["workOrderUpdateActionAction"];
            this.assetPartName = data["assetPartName"];
        }
    }

    static fromJS(data: any): GetWorkOrderUpdateForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetWorkOrderUpdateForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["workOrderUpdate"] = this.workOrderUpdate ? this.workOrderUpdate.toJSON() : <any>undefined;
        data["workOrderUpdateSubject"] = this.workOrderUpdateSubject;
        data["itemTypeType"] = this.itemTypeType;
        data["workOrderUpdateActionAction"] = this.workOrderUpdateActionAction;
        data["assetPartName"] = this.assetPartName;
        return data; 
    }
}

export interface IGetWorkOrderUpdateForEditOutput {
    workOrderUpdate: CreateOrEditWorkOrderUpdateDto | undefined;
    workOrderUpdateSubject: string | undefined;
    itemTypeType: string | undefined;
    workOrderUpdateActionAction: string | undefined;
    assetPartName: string | undefined;
}

export class CreateOrEditWorkOrderUpdateDto implements ICreateOrEditWorkOrderUpdateDto {
    comments!: string | undefined;
    number!: number | undefined;
    completed!: boolean | undefined;
    workOrderId!: number | undefined;
    itemTypeId!: number | undefined;
    workOrderActionId!: number | undefined;
    assetPartId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditWorkOrderUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.comments = data["comments"];
            this.number = data["number"];
            this.completed = data["completed"];
            this.workOrderId = data["workOrderId"];
            this.itemTypeId = data["itemTypeId"];
            this.workOrderActionId = data["workOrderActionId"];
            this.assetPartId = data["assetPartId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditWorkOrderUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditWorkOrderUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["comments"] = this.comments;
        data["number"] = this.number;
        data["completed"] = this.completed;
        data["workOrderId"] = this.workOrderId;
        data["itemTypeId"] = this.itemTypeId;
        data["workOrderActionId"] = this.workOrderActionId;
        data["assetPartId"] = this.assetPartId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditWorkOrderUpdateDto {
    comments: string | undefined;
    number: number | undefined;
    completed: boolean | undefined;
    workOrderId: number | undefined;
    itemTypeId: number | undefined;
    workOrderActionId: number | undefined;
    assetPartId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfWorkOrderUpdateAssetPartLookupTableDto implements IPagedResultDtoOfWorkOrderUpdateAssetPartLookupTableDto {
    totalCount!: number | undefined;
    items!: WorkOrderUpdateAssetPartLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfWorkOrderUpdateAssetPartLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(WorkOrderUpdateAssetPartLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfWorkOrderUpdateAssetPartLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfWorkOrderUpdateAssetPartLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfWorkOrderUpdateAssetPartLookupTableDto {
    totalCount: number | undefined;
    items: WorkOrderUpdateAssetPartLookupTableDto[] | undefined;
}

export class WorkOrderUpdateAssetPartLookupTableDto implements IWorkOrderUpdateAssetPartLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IWorkOrderUpdateAssetPartLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): WorkOrderUpdateAssetPartLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkOrderUpdateAssetPartLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IWorkOrderUpdateAssetPartLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfWorkOrderUpdateWorkOrderActionLookupTableDto implements IPagedResultDtoOfWorkOrderUpdateWorkOrderActionLookupTableDto {
    totalCount!: number | undefined;
    items!: WorkOrderUpdateWorkOrderActionLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfWorkOrderUpdateWorkOrderActionLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(WorkOrderUpdateWorkOrderActionLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfWorkOrderUpdateWorkOrderActionLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfWorkOrderUpdateWorkOrderActionLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfWorkOrderUpdateWorkOrderActionLookupTableDto {
    totalCount: number | undefined;
    items: WorkOrderUpdateWorkOrderActionLookupTableDto[] | undefined;
}

export class WorkOrderUpdateWorkOrderActionLookupTableDto implements IWorkOrderUpdateWorkOrderActionLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IWorkOrderUpdateWorkOrderActionLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): WorkOrderUpdateWorkOrderActionLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new WorkOrderUpdateWorkOrderActionLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IWorkOrderUpdateWorkOrderActionLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class PagedResultDtoOfGetXeroInvoiceForViewDto implements IPagedResultDtoOfGetXeroInvoiceForViewDto {
    totalCount!: number | undefined;
    items!: GetXeroInvoiceForViewDto[] | undefined;

    constructor(data?: IPagedResultDtoOfGetXeroInvoiceForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(GetXeroInvoiceForViewDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfGetXeroInvoiceForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfGetXeroInvoiceForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfGetXeroInvoiceForViewDto {
    totalCount: number | undefined;
    items: GetXeroInvoiceForViewDto[] | undefined;
}

export class GetXeroInvoiceForViewDto implements IGetXeroInvoiceForViewDto {
    xeroInvoice!: XeroInvoiceDto | undefined;
    customerInvoiceCustomerReference!: string | undefined;

    constructor(data?: IGetXeroInvoiceForViewDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.xeroInvoice = data["xeroInvoice"] ? XeroInvoiceDto.fromJS(data["xeroInvoice"]) : <any>undefined;
            this.customerInvoiceCustomerReference = data["customerInvoiceCustomerReference"];
        }
    }

    static fromJS(data: any): GetXeroInvoiceForViewDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetXeroInvoiceForViewDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["xeroInvoice"] = this.xeroInvoice ? this.xeroInvoice.toJSON() : <any>undefined;
        data["customerInvoiceCustomerReference"] = this.customerInvoiceCustomerReference;
        return data; 
    }
}

export interface IGetXeroInvoiceForViewDto {
    xeroInvoice: XeroInvoiceDto | undefined;
    customerInvoiceCustomerReference: string | undefined;
}

export class XeroInvoiceDto implements IXeroInvoiceDto {
    xeroInvoiceCreated!: boolean | undefined;
    apiResponse!: string | undefined;
    failed!: boolean | undefined;
    exception!: string | undefined;
    xeroReference!: string | undefined;
    customerInvoiceId!: number | undefined;
    id!: number | undefined;

    constructor(data?: IXeroInvoiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.xeroInvoiceCreated = data["xeroInvoiceCreated"];
            this.apiResponse = data["apiResponse"];
            this.failed = data["failed"];
            this.exception = data["exception"];
            this.xeroReference = data["xeroReference"];
            this.customerInvoiceId = data["customerInvoiceId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): XeroInvoiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new XeroInvoiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["xeroInvoiceCreated"] = this.xeroInvoiceCreated;
        data["apiResponse"] = this.apiResponse;
        data["failed"] = this.failed;
        data["exception"] = this.exception;
        data["xeroReference"] = this.xeroReference;
        data["customerInvoiceId"] = this.customerInvoiceId;
        data["id"] = this.id;
        return data; 
    }
}

export interface IXeroInvoiceDto {
    xeroInvoiceCreated: boolean | undefined;
    apiResponse: string | undefined;
    failed: boolean | undefined;
    exception: string | undefined;
    xeroReference: string | undefined;
    customerInvoiceId: number | undefined;
    id: number | undefined;
}

export class GetXeroInvoiceForEditOutput implements IGetXeroInvoiceForEditOutput {
    xeroInvoice!: CreateOrEditXeroInvoiceDto | undefined;
    customerInvoiceCustomerReference!: string | undefined;

    constructor(data?: IGetXeroInvoiceForEditOutput) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.xeroInvoice = data["xeroInvoice"] ? CreateOrEditXeroInvoiceDto.fromJS(data["xeroInvoice"]) : <any>undefined;
            this.customerInvoiceCustomerReference = data["customerInvoiceCustomerReference"];
        }
    }

    static fromJS(data: any): GetXeroInvoiceForEditOutput {
        data = typeof data === 'object' ? data : {};
        let result = new GetXeroInvoiceForEditOutput();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["xeroInvoice"] = this.xeroInvoice ? this.xeroInvoice.toJSON() : <any>undefined;
        data["customerInvoiceCustomerReference"] = this.customerInvoiceCustomerReference;
        return data; 
    }
}

export interface IGetXeroInvoiceForEditOutput {
    xeroInvoice: CreateOrEditXeroInvoiceDto | undefined;
    customerInvoiceCustomerReference: string | undefined;
}

export class CreateOrEditXeroInvoiceDto implements ICreateOrEditXeroInvoiceDto {
    xeroInvoiceCreated!: boolean | undefined;
    apiResponse!: string | undefined;
    failed!: boolean | undefined;
    exception!: string | undefined;
    xeroReference!: string | undefined;
    customerInvoiceId!: number | undefined;
    id!: number | undefined;

    constructor(data?: ICreateOrEditXeroInvoiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.xeroInvoiceCreated = data["xeroInvoiceCreated"];
            this.apiResponse = data["apiResponse"];
            this.failed = data["failed"];
            this.exception = data["exception"];
            this.xeroReference = data["xeroReference"];
            this.customerInvoiceId = data["customerInvoiceId"];
            this.id = data["id"];
        }
    }

    static fromJS(data: any): CreateOrEditXeroInvoiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateOrEditXeroInvoiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["xeroInvoiceCreated"] = this.xeroInvoiceCreated;
        data["apiResponse"] = this.apiResponse;
        data["failed"] = this.failed;
        data["exception"] = this.exception;
        data["xeroReference"] = this.xeroReference;
        data["customerInvoiceId"] = this.customerInvoiceId;
        data["id"] = this.id;
        return data; 
    }
}

export interface ICreateOrEditXeroInvoiceDto {
    xeroInvoiceCreated: boolean | undefined;
    apiResponse: string | undefined;
    failed: boolean | undefined;
    exception: string | undefined;
    xeroReference: string | undefined;
    customerInvoiceId: number | undefined;
    id: number | undefined;
}

export class PagedResultDtoOfXeroInvoiceCustomerInvoiceLookupTableDto implements IPagedResultDtoOfXeroInvoiceCustomerInvoiceLookupTableDto {
    totalCount!: number | undefined;
    items!: XeroInvoiceCustomerInvoiceLookupTableDto[] | undefined;

    constructor(data?: IPagedResultDtoOfXeroInvoiceCustomerInvoiceLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.totalCount = data["totalCount"];
            if (Array.isArray(data["items"])) {
                this.items = [] as any;
                for (let item of data["items"])
                    this.items!.push(XeroInvoiceCustomerInvoiceLookupTableDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultDtoOfXeroInvoiceCustomerInvoiceLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultDtoOfXeroInvoiceCustomerInvoiceLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedResultDtoOfXeroInvoiceCustomerInvoiceLookupTableDto {
    totalCount: number | undefined;
    items: XeroInvoiceCustomerInvoiceLookupTableDto[] | undefined;
}

export class XeroInvoiceCustomerInvoiceLookupTableDto implements IXeroInvoiceCustomerInvoiceLookupTableDto {
    id!: number | undefined;
    displayName!: string | undefined;

    constructor(data?: IXeroInvoiceCustomerInvoiceLookupTableDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.displayName = data["displayName"];
        }
    }

    static fromJS(data: any): XeroInvoiceCustomerInvoiceLookupTableDto {
        data = typeof data === 'object' ? data : {};
        let result = new XeroInvoiceCustomerInvoiceLookupTableDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["displayName"] = this.displayName;
        return data; 
    }
}

export interface IXeroInvoiceCustomerInvoiceLookupTableDto {
    id: number | undefined;
    displayName: string | undefined;
}

export class AdditionalData implements IAdditionalData {
    paypal!: { [key: string]: string; } | undefined;
    stripe!: { [key: string]: string; } | undefined;

    constructor(data?: IAdditionalData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["Paypal"]) {
                this.paypal = {} as any;
                for (let key in data["Paypal"]) {
                    if (data["Paypal"].hasOwnProperty(key))
                        this.paypal![key] = data["Paypal"][key];
                }
            }
            if (data["Stripe"]) {
                this.stripe = {} as any;
                for (let key in data["Stripe"]) {
                    if (data["Stripe"].hasOwnProperty(key))
                        this.stripe![key] = data["Stripe"][key];
                }
            }
        }
    }

    static fromJS(data: any): AdditionalData {
        data = typeof data === 'object' ? data : {};
        let result = new AdditionalData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.paypal) {
            data["Paypal"] = {};
            for (let key in this.paypal) {
                if (this.paypal.hasOwnProperty(key))
                    data["Paypal"][key] = this.paypal[key];
            }
        }
        if (this.stripe) {
            data["Stripe"] = {};
            for (let key in this.stripe) {
                if (this.stripe.hasOwnProperty(key))
                    data["Stripe"][key] = this.stripe[key];
            }
        }
        return data; 
    }
}

export interface IAdditionalData {
    paypal: { [key: string]: string; } | undefined;
    stripe: { [key: string]: string; } | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = event => { 
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob); 
        }
    });
}